<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TXT to EPUB Converter</title>
    <style>
        @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css');
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jschardet/3.0.0/jschardet.min.js"></script>
    <style>
        :root {
            --primary-color: #4361ee;
            --primary-dark: #3a56d4;
            --primary-light: #ebefff;
            --secondary-color: #48bfe3;
            --secondary-dark: #3ca9cd;
            --success-color: #34a853;
            --warning-color: #f7b801;
            --danger-color: #ef476f;
            --dark-color: #212529;
            --text-color: #343a40;
            --light-text: #6c757d;
            --light-gray: #f8f9fa;
            --mid-gray: #e9ecef;
            --dark-gray: #ced4da;
            --white: #ffffff;
            --sidebar-width: 300px;
            --icons-width: 48px;
            --header-height: 60px;
            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        body {
            background-color: var(--light-gray);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .app-container {
            display: flex;
            min-height: 100vh;
            position: relative;
        }
        
        /* Convert button styles */
        #removeTxtBtn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid transparent;
            margin-right: 16px;
        }

        #removeTxtBtn:hover {
            border: 1px solid;

        }

        .filbt {
            margin: 24px 0 18px;
            display: flex;
        }

        .convert-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 28px;
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            color: var(--white);
            border: none;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.2);
            position: relative;
            overflow: hidden;
            min-width: 200px;
            margin: 0 auto;
            border-radius: 0 8px 8px 0;
        }
        
        
        /* Responsive convert button */
        @media (max-width: 768px) {
            .filbt {
                display: block;
            }

            .convert-btn {
                width: 100%;
                max-width: 300px;
                padding: 12px 24px;
                font-size: 15px;
                border-radius: var(--border-radius);
                margin-top: 10px;
            }

            .file-preview {
                border-radius: var(--border-radius);
            }
        }
        
        @media (max-width: 576px) {
            .filbt {
                display: block;
            }

            .convert-btn {
                max-width: 100%;
                padding: 10px 20px;
                font-size: 14px;
                border-radius: var(--border-radius);
                margin-top: 8px;
            }

            .file-preview {
                border-radius: var(--border-radius);
            }
            
        }
        
        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background-color: var(--white);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 100;
        }
        
        .header h1 {
            color: var(--primary-color);
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0;
            flex: 1;
        }
        
        .header-actions button {
            margin-left: 8px;
            display: none;
        }
        
        /* Redesigned Sidebar Styles */
        .sidebar {
            position: relative;
            display: flex;
            height: calc(100vh - var(--header-height));
            top: var(--header-height);
            left: 0;
            z-index: 90;
            transition: var(--transition);
        }

        /* Icons Column */
        .sidebar-icons {
            width: var(--icons-width);
            height: 100%;
            background-color: var(--white);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            z-index: 91;
        }

        .sidebar-icon {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 12px;
            color: var(--text-color);
            cursor: pointer;
            transition: var(--transition);
        }

        .sidebar-icon:hover {
            background-color: var(--primary-light);
            color: var(--primary-color);
        }

        .sidebar-icon.active {
            background-color: var(--primary-light);
            color: var(--primary-color);
        }

        /* Content Panel */
        .sidebar-content {
            width: 0;
            height: 100%;
            background-color: var(--white);
            overflow: hidden;
            transition: width 0.3s ease;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
        }

        .sidebar-content.expanded {
            width: calc(var(--sidebar-width) - var(--icons-width));
        }

        /* Settings Sections */
        .settings-section {
            display: none;
            padding: 20px;
            height: 100%;
            overflow-y: auto;
        }

        .settings-section.active {
            display: block;
        }

        .settings-header {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--mid-gray);
            padding-bottom: 10px;
        }

        .settings-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary-dark);
            margin: 0;
            display: flex;
            align-items: center;
        }

        .settings-header h3 i {
            margin-right: 8px;
        }

        /* Main Content Adjustment */
        .main-content {
            flex: 1;
            margin-top: var(--header-height);
            padding: 24px;
            transition: var(--transition);
        }

        /* Responsive Styles */
        @media (max-width: 992px) {
            /* Mobile view - sidebar is hidden by default */
            .sidebar {
                position: fixed;
                left: calc(-1 * var(--sidebar-width));
                width: var(--sidebar-width);
                flex-direction: column;
            }
            .header-actions button {
            margin-left: 8px;
            display: block;
        }
            
            .sidebar.sidebar-visible {
                left: 0;
            }
            
            .sidebar-icons {
                width: 100%;
                height: auto;
                flex-direction: row;
                justify-content: flex-start;
                flex-wrap: wrap;
                padding: 8px;
                gap: 8px;
            }
            
            .sidebar-icon {
                margin-bottom: 0;
            }
            
            .sidebar-content {
                width: 100%;
                height: calc(100% - 52px);
            }
            
            .sidebar-content.expanded {
                width: 100%;
            }
            
            .main-content {
                margin-left: 0;
            }
        }
        
        /* Form elements */
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
        }
        
        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--dark-gray);
            border-radius: 4px;
            font-size: 14px;
            transition: var(--transition);
        }
        
        .form-control:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
        }
        
        .radio-group {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }
        
        .radio-option {
            margin-right: 16px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .radio-option input[type="radio"] {
            margin-right: 4px;
        }
        
        /* Buttons */
        .btn {
            display: inline-block;
            padding: 10px 16px;
            background-color: var(--primary-color);
            color: var(--white);
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            text-align: center;
        }
        
        .btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .btn:active {
            transform: translateY(0);
            box-shadow: none;
        }
        
        .btn-secondary {
            background-color: var(--secondary-color);
        }
        
        .btn-secondary:hover {
            background-color: var(--secondary-dark);
        }
        
        .btn-success {
            background-color: var(--success-color);
        }
        
        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
        }
        
        .btn-outline:hover {
            background-color: var(--primary-light);
            color: var(--primary-dark);
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 13px;
        }
        
        .btn-block {
            display: block;
            width: 100%;
        }
        
        .btn-disabled,
        .convert-btn:disabled { /* Added rule for disabled convert button */
            background: var(--dark-gray) !important; /* Use !important to override gradient */
            color: var(--light-text) !important;
            cursor: not-allowed !important;
            opacity: 0.7 !important;
            box-shadow: none !important;
        }
        
        .btn-disabled:hover,
        .convert-btn:disabled:hover { /* Added rule for disabled convert button hover */
            background-color: var(--dark-gray) !important;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Drop area */
         /* 改进后的上传区域容器 */
        .content-card {
            background-color: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 10px;
        }

        .file-format-badge {
            display: inline-block;
            background-color: var(--primary-light);
            color: var(--primary-dark);
            padding: 2px 10px;
            border-radius: var(--border-radius);
            font-weight: 500;
            margin: 0 4px;
        }

        .drop-area {
            border: 2px dashed var(--dark-gray);
            border-radius: var(--border-radius);
            padding: 48px 24px;
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
            position: relative;
            background-color: rgba(67, 97, 238, 0.05);
        }

        .drop-area:hover {
            border-color: var(--primary-color);
            background-color: rgba(67, 97, 238, 0.1);
            transform: translateY(-1px);
        }
        
        .drop-area.active {
            border-color: var(--primary-color);
            background-color: var(--primary-light);
        }
        
        .drop-area h3 {
            margin-bottom: 8px;
            color: var(--text-color);
            font-weight: 500;
        }
        
        .drop-area p {
            color: var(--light-text);
            margin-bottom: 16px;
        }
        
        .drop-area input {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
            z-index: 10;
        }

        
        /* File preview */
        .file-preview {
            display: none;
            align-items: center;
            padding: 10px;
            background-color: var(--light-gray);
            flex: 1;
            border-radius: 8px 0 0 8px;
        }
        
        .file-preview i {
            font-size: 24px;
            margin-right: 16px;
        }
        
        .file-details {
            flex: 1;
        }
        
        .file-details h4 {
            font-weight: 500;
            font-size: 15px;
        }
        
        /* Cover preview */
        .cover-preview-container {
            text-align: center;
            margin: 16px 0;
        }
        
        .cover-preview {
            max-width: 150px;
            max-height: 225px;
            border: 1px solid var(--mid-gray);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
            margin: 0 auto;
        }
        
        .cover-status {
            margin: 8px 0;
            font-style: italic;
            color: var(--light-text);
            font-size: 13px;
        }
        
        /* Progress area */
        .progress-area {
            display: none;
            text-align: center;
        }
        
        .progress-bar-container {
            height: 8px;
            background-color: var(--mid-gray);
            border-radius: 4px;
            margin: 16px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 3px solid var(--primary-light);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Result area */
        .result-area {
            display: none;
            text-align: center;
        }
        
        .result-icon {
            color: var(--success-color);
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .result-card {
            background-color: var(--light-gray);
            border-radius: var(--border-radius);
            padding: 16px;
            margin-top: 16px;
        }
        
        .result-actions {
            margin-top: 16px;
            display: flex;
            justify-content: center;
            gap: 12px;
        }
        
        .result-actions .btn {
            min-width: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .result-actions .btn i {
            margin-right: 8px;
        }
        
        @media (max-width: 576px) {
            .result-actions {
                flex-direction: column;
                gap: 10px;
            }
            
            .result-actions .btn {
                width: 100%;
                margin: 0;
            }
        }
        
        /* Debug area */
        .debug-area {
            margin-top: 16px;
            padding: 12px;
            background-color: var(--dark-color);
            border-radius: var(--border-radius);
            display: none;
        }
        
        .debug-area h3 {
            margin-bottom: 8px;
            color: var(--white);
            font-size: 14px;
        }
        
        .debug-log {
            height: 200px;
            overflow-y: auto;
            background-color: #1e1e1e;
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .debug-log div {
            margin-bottom: 4px;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }
        
        /* Configuration summary */
        .config-summary {
            border-left: 3px solid var(--primary-color);
            padding-left: 12px;
            margin: 16px 0;
            font-size: 13px;
        }
        
        .summary-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
        }
        
        .summary-text {
            flex: 1;
        }
        
        /* 骨架屏样式 */
        .skeleton {
            background-color: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);;
            border-radius: 4px;
            animation: pulse 1.2s infinite linear;
        }
        @keyframes pulse {
            0% {
                background-position: -200px 0;
            }
            100% {
                background-position: 200px 0;
            }
        }

        .summary-cover {
            width: 120px;
            border: 1px solid var(--mid-gray);
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--light-gray);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .summary-cover img {
            max-width: 100%;
            max-height: 100%;
            object-fit: cover;
        }
        
        #summaryCoverPlaceholder {
            color: var(--light-text);
            font-size: 12px;
            text-align: center;
            padding: 10px;
        }
        
        .config-summary h4 {
            margin-bottom: 8px;
            color: var(--primary-dark);
        }
        
        .config-summary p {
            margin: 4px 0;
            color: var(--text-color);
        }

        /* Other responsive adjustments */
        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }
            
            .btn {
                padding: 8px 12px;
                font-size: 13px;
            }
            
            .drop-area {
                padding: 32px 16px;
            }
            
            .drop-area i {
                font-size: 36px;
            }
            
        }
        
        @media (max-width: 576px) {
            :root {
                --sidebar-width: 270px;
            }
            
            .header h1 {
                font-size: 1rem;
            }
            
            .main-content {
                padding: 16px;
            }
            
            .btn-sm-block {
                display: block;
                width: 100%;
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>小说 TXT to EPUB 转换</h1>
            <div class="header-actions">
                <button id="toggleSidebarBtn" class="btn btn-sm btn-outline">
                    <i class="fas fa-sliders-h"></i> 设置
                </button>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-icons" id="sidebarIcons">
                <div class="sidebar-icon" data-section="bookInfoSection">
                    <i class="fas fa-book"></i>
                </div>
                <div class="sidebar-icon" data-section="chapterSection">
                    <i class="fas fa-list-ol"></i>
                </div>
                <div class="sidebar-icon" data-section="coverSection">
                    <i class="fas fa-image"></i>
                </div>
                <div class="sidebar-icon" data-section="appearanceSection">
                    <i class="fas fa-cogs"></i>
                </div>
                <div class="sidebar-icon" data-section="debugSection">
                    <i class="fas fa-bug"></i>
                </div>
            </div>
            
            <div class="sidebar-content" id="sidebarContent">
                <div class="settings-section" id="bookInfoSection">
                    <div class="settings-header">
                        <h3>书籍信息</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="bookTitle">书名</label>
                            <input type="text" id="bookTitle" class="form-control" placeholder="输入书名">
                        </div>
                        <div class="form-group">
                            <label for="bookAuthor">作者</label>
                            <input type="text" id="bookAuthor" class="form-control" placeholder="输入作者">
                        </div>
                        <div class="form-group">
                            <label for="bookLanguage">语言</label>
                            <select id="bookLanguage" class="form-control">
                                <option value="zh-CN">中文（简体）</option>
                                <option value="zh-TW">中文（繁体）</option>
                                <option value="en">English</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="chapterSection">
                    <div class="settings-header">
                        <h3>识别章节或卷/部</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="chapterPattern">章节</label>
                            <select id="chapterPattern" class="form-control">
                                <option value="auto">自动识别章节</option>
                                <option value="chinese">中文模式 (第X章)</option>
                                <option value="english">英文模式 (Chapter X)</option>
                                <option value="numbered">数字 (1., 2., etc)</option>
                                <option value="custom">自定义</option>
                            </select>
                        </div>
                        <div id="customChapterArea" style="display: none;">
                            <div class="form-group">
                                <label for="customChapterPattern">正则表达式</label>
                                <input type="text" id="customChapterPattern" class="form-control" placeholder="e.g. ^第[0-9一二三四五六七八九十零〇百千两 ]+[章]">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="volumePattern">卷/部</label>
                            <select id="volumePattern" class="form-control">
                                <option value="auto">自动识别卷名</option>
                                <option value="chinese">中文模式 (第X卷/第X部)</option>
                                <option value="english">英文模式 (Volume X/Book X)</option>
                                <option value="disabled">不识别</option>
                                <option value="custom">自定义</option>
                            </select>
                        </div>
                        <div id="customVolumeArea" style="display: none;">
                            <div class="form-group">
                                <label for="customVolumePattern">正则表达式</label>
                                <input type="text" id="customVolumePattern" class="form-control" placeholder="e.g. ^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部]">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="maxTitleLength">标题最大长度（字符）</label>
                            <input type="number" id="maxTitleLength" class="form-control" min="1" max="100" value="35">
                        </div>
                        <div class="form-group">
                            <label for="unknownTitleName">未知章节命名</label>
                            <input type="text" id="unknownTitleName" class="form-control" value="章节正文">
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="coverSection">
                    <div class="settings-header">
                        <h3>封面</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label>封面源</label>
                            <div class="radio-group">
                                <div class="radio-option">
                                    <input type="radio" id="coverSearch" name="coverOption" value="search" checked>
                                    <label for="coverSearch">起点网</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" id="coverUpload" name="coverOption" value="upload">
                                    <label for="coverUpload">本地上传</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" id="coverNone" name="coverOption" value="none">
                                    <label for="coverNone">无封面</label>
                                </div>
                            </div>
                        </div>
                        
                        <div id="coverUploadArea" style="display: none;">
                            <div class="form-group">
                                <button class="btn btn-outline btn-sm btn-block" id="selectCoverBtn">
                                    <i class="fas fa-upload"></i> 上传图片
                                </button>
                                <input type="file" id="coverInput" accept="image/*" hidden>
                                <p id="coverFileName" style="margin-top: 8px; display: none; font-size: 13px;"></p>
                            </div>
                        </div>
                        
                        <div class="cover-preview-container" id="coverPreviewArea">
                            <img id="coverPreview" class="cover-preview">
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="appearanceSection">
                    <div class="settings-header">
                        <h3>文本设置</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="indent">段落首行缩进（字符）</label>
                            <input type="number" id="indent" class="form-control" min="0" max="8" value="2">
                        </div>
                        <div class="form-group">
                            <label for="titleAlign">标题对齐</label>
                            <select id="titleAlign" class="form-control">
                                <option value="center">居中</option>
                                <option value="left">左对齐</option>
                                <option value="right">右对齐</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="fontFamily">字体</label>
                            <select id="fontFamily" class="form-control">
                                <option value="default">默认（系统字体）</option>
                                <option value="serif">衬线字体</option>
                                <option value="sans">无衬线字体</option>
                                <option value="mono">等宽字体</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="fontSize">基础字号</label>
                            <select id="fontSize" class="form-control">
                                <option value="100%">默认字号</option>
                                <option value="90%">小字号</option>
                                <option value="110%">大字号</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="lineHeight">行高</label>
                            <select id="lineHeight" class="form-control">
                                <option value="1.5">Default (1.5)</option>
                                <option value="1.2">Compact (1.2)</option>
                                <option value="1.8">Spacious (1.8)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="paragraphSpacing">段间距</label>
                            <select id="paragraphSpacing" class="form-control">
                                <option value="1em">Default (1em)</option>
                                <option value="0.5em">Compact (0.5em)</option>
                                <option value="1.5em">Spacious (1.5em)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="debugSection">
                    <div class="settings-header">
                        <h3>调试</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="debugMode">Debug Mode</label>
                            <select id="debugMode" class="form-control">
                                <option value="off">Off</option>
                                <option value="on">On</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content" id="mainContent">
            <div class="content-card upload-area" id="uploadCard">
                <div class="drop-area" id="dropArea">
                    <h3>上传<span class="file-format-badge">TXT</span>文本文件</h3>
                    <p>点击此区域选择文件，或将文件拖放到此处</p>
                    <button class="btn" id="selectFileBtn">选择文件</button>
                    <input type="file" id="fileInput" accept=".txt" hidden>
                </div>

                <div id="fileInfo" style="display: none; margin-top: 16px;">
                    <div class="config-summary" id="configSummary">
                        <div class="summary-container">
                            <div class="summary-text">
                                <h4>文本摘要</h4>
                                <div id="configDetails">
                                    <p><strong>标题:</strong> <span id="summaryTitle"></span></p>
                                    <p><strong>作者:</strong> <span id="summaryAuthor"></span></p>
                                    <p><strong>封面源:</strong> <span id="summaryCover"></span></p>
                                    <p><strong>大小:</strong> <span id="txtFileSize"></span></p>
                                    <p><strong>编码:</strong> <span id="txtEncoding"></span></p>
                                </div>
                            </div>
                            <div class="summary-cover skeleton">
                                <img id="summaryCoverPreview" src="" alt="Book Cover" style="display: none;">
                                <div id="summaryCoverPlaceholder">No cover selected</div>
                            </div>
                        </div>
                    </div>

                    <div class="filbt">
                        <div class="file-preview" id="txtPreview">
                            <i class="fas fa-file-alt"></i>
                            <div class="file-details">
                                <h4 id="txtFileName">filename.txt</h4>
                            </div>
                            <span id="removeTxtBtn"><i class="fas fa-times" style="margin: 0; font-size: medium;"></i></span>
                        </div>
                        <button class="convert-btn" id="convertBtn">
                            <span class="convert-btn-text">转换</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="content-card progress-area" id="progressCard" style="display: none;">
                <div class="loading-spinner"></div>
                <h3 id="progressTitle">此过程需要一些时间，请稍后...</h3>
                <p id="progressStatus"></p>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>

            <div class="content-card result-area" id="resultCard" style="display: none;">
                <i class="fas fa-check-circle result-icon"></i>
                <h3>转换完成!</h3>
                <p>您的epub文件准备下载</p>
                
                <div class="result-card">
                    <h4 id="resultFileName"></h4>
                    <p id="resultFileSize"></p>
                    
                    <div class="result-actions">
                        <button class="btn btn-primary" id="downloadBtn">
                            <i class="fas fa-download"></i> 下载
                        </button>
                        <button class="btn btn-outline" id="convertNewBtn">
                            <i class="fas fa-redo"></i> 转换更多文件
                        </button>
                    </div>
                </div>
            </div>

            <div class="debug-area" id="debugAreaDOM"> <h3>Debug Log</h3>
                <div class="debug-log" id="debugLog"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements - Main UI
    const sidebar = document.getElementById('sidebar');
    const sidebarContent = document.getElementById('sidebarContent');
    const mainContent = document.getElementById('mainContent');
    const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
    
    // DOM Elements - Settings Sections
    const settingsSections = document.querySelectorAll('.settings-section');
    const sidebarIcons = document.querySelectorAll('.sidebar-icon');
    
    // DOM Elements - File Upload
    const dropArea = document.getElementById('dropArea');
    const fileInput = document.getElementById('fileInput');
    const selectFileBtn = document.getElementById('selectFileBtn');
    const fileInfo = document.getElementById('fileInfo');
    const txtPreview = document.getElementById('txtPreview');
    const txtFileName = document.getElementById('txtFileName');
    const txtFileSize = document.getElementById('txtFileSize');
    const txtEncoding = document.getElementById('txtEncoding');
    const removeTxtBtn = document.getElementById('removeTxtBtn');
    
    // DOM Elements - Book Information
    const bookTitle = document.getElementById('bookTitle');
    const bookAuthor = document.getElementById('bookAuthor');
    const bookLanguage = document.getElementById('bookLanguage');
    
    // DOM Elements - Chapter Detection
    const chapterPattern = document.getElementById('chapterPattern');
    const volumePattern = document.getElementById('volumePattern');
    const customChapterArea = document.getElementById('customChapterArea');
    const customVolumeArea = document.getElementById('customVolumeArea');
    const customChapterPattern = document.getElementById('customChapterPattern');
    const customVolumePattern = document.getElementById('customVolumePattern');
    const maxTitleLength = document.getElementById('maxTitleLength');
    const unknownTitleName = document.getElementById('unknownTitleName');
    
    // DOM Elements - Cover Options
    const coverUpload = document.getElementById('coverUpload');
    const coverSearch = document.getElementById('coverSearch');
    const coverNone = document.getElementById('coverNone');
    const coverUploadArea = document.getElementById('coverUploadArea');
    // const coverSearchArea = document.getElementById('coverSearchArea'); // This element does not exist in HTML
    const coverPreviewArea = document.getElementById('coverPreviewArea');
    const coverPreview = document.getElementById('coverPreview');
    const selectCoverBtn = document.getElementById('selectCoverBtn');
    const coverInput = document.getElementById('coverInput');
    const coverFileName = document.getElementById('coverFileName');
    // const coverQuery = document.getElementById('coverQuery'); // This element does not exist in HTML
    
    // DOM Elements - Summary Section
    const summaryTitle = document.getElementById('summaryTitle');
    const summaryAuthor = document.getElementById('summaryAuthor');
    const summaryCover = document.getElementById('summaryCover');
    
    // DOM Elements - Appearance Options
    const indent = document.getElementById('indent');
    const titleAlign = document.getElementById('titleAlign');
    const fontFamily = document.getElementById('fontFamily');
    const fontSize = document.getElementById('fontSize');
    const lineHeight = document.getElementById('lineHeight');
    const paragraphSpacing = document.getElementById('paragraphSpacing');
    
    // DOM Elements - Debug
    const debugAreaDOM = document.getElementById('debugAreaDOM'); // Corrected ID
    const debugLog = document.getElementById('debugLog');
    const debugMode = document.getElementById('debugMode');
    
    // DOM Elements - Cards and Actions
    const uploadCard = document.getElementById('uploadCard');
    const progressCard = document.getElementById('progressCard');
    const resultCard = document.getElementById('resultCard');
    
    // Button and Progress Elements
    const convertBtn = document.getElementById('convertBtn');
    const progressTitle = document.getElementById('progressTitle');
    const progressStatus = document.getElementById('progressStatus');
    const progressBar = document.getElementById('progressBar');
    // const resultArea = document.getElementById('resultCard'); // Already defined as resultCard
    const resultFileName = document.getElementById('resultFileName');
    const resultFileSize = document.getElementById('resultFileSize');
    const downloadBtn = document.getElementById('downloadBtn');
    const convertNewBtn = document.getElementById('convertNewBtn');
    // const converterCard = document.getElementById('converterCard'); // This element does not exist in HTML
    
    // State Variables
    let selectedFile = null;
    let coverFile = null;
    let coverDataUrl = null;
    let epubBlob = null;
    let detectedEncoding = null;
    let fileArrayBuffer = null;
    let processedText = null;
    let isSearchingCover = false; // Flag to prevent multiple cover searches
    
    // Initialize with default state
    initializeApp();
    
    function initializeApp() {
        // Setup event listeners
        setupUIEventListeners();
        setupFileEventListeners();
        setupSettingsEventListeners();
        setupConversionEventListeners();
        
        // Initialize UI state
        updateDebugArea();
        toggleCoverOptions(); // Initialize cover options visibility
    }
    
    // UI Event Listeners - New Redesigned Sidebar Logic
    function setupUIEventListeners() {
        // Setup sidebar icon click handlers
        sidebarIcons.forEach(icon => {
            icon.addEventListener('click', function() {
                const sectionId = this.getAttribute('data-section');
                const isCurrentlyActive = this.classList.contains('active');
                
                if (isCurrentlyActive && window.innerWidth > 992) {
                    // If clicking on already active icon, collapse sidebar content
                    sidebarContent.classList.remove('expanded');
                    this.classList.remove('active');
                    
                    // Deactivate all sections
                    settingsSections.forEach(section => section.classList.remove('active'));
                } else {
                    // Normal behavior - activate the section
                    activateSection(sectionId, this);
                }
            });
        });

        // Setup sidebar toggle for mobile
        if (toggleSidebarBtn) {
            toggleSidebarBtn.addEventListener('click', function() {
                if (sidebar) sidebar.classList.toggle('sidebar-visible');
            });
        }
        
        // Close sidebar when clicking outside of it (mobile only)
        document.addEventListener('click', function(event) {
            // Only apply this in mobile view
            if (window.innerWidth <= 992) {
                // Check if the sidebar is visible and the click is outside the sidebar
                if (sidebar && sidebar.classList.contains('sidebar-visible') && 
                    !sidebar.contains(event.target) && 
                    event.target !== toggleSidebarBtn) {
                    sidebar.classList.remove('sidebar-visible');
                }
            }
        });

        // Handle responsive behavior
        window.addEventListener('resize', handleResize);
        
        // Initial resize check
        handleResize();
    }
    
    // Activate a specific settings section
    function activateSection(sectionId, iconElement) {
        // Verify sectionId exists before activating
        const sectionElement = document.getElementById(sectionId);
        if (!sectionElement) {
            log(`Section with ID ${sectionId} not found`, 'error');
            return;
        }
        
        // Deactivate all sections and icons
        settingsSections.forEach(section => section.classList.remove('active'));
        sidebarIcons.forEach(icon => icon.classList.remove('active'));
        
        // Activate the selected section and icon
        sectionElement.classList.add('active');
        if (iconElement) iconElement.classList.add('active'); // Check if iconElement exists
        
        // Expand the sidebar content
        if (sidebarContent) sidebarContent.classList.add('expanded');
    }

    // Handle responsive behavior
    function handleResize() {
        if (window.innerWidth <= 992) {
            // Mobile: Hide sidebar by default
            if (sidebar) sidebar.classList.remove('sidebar-visible');
            
            // Ensure sidebar content is fully visible when shown
            if (sidebarContent) sidebarContent.classList.add('expanded');

            // Find the first sidebar icon and use it to activate the default section
            const firstIcon = sidebarIcons[0];
            if (firstIcon) {
                const defaultSectionId = firstIcon.getAttribute('data-section');
                if (defaultSectionId) {
                    activateSection(defaultSectionId, firstIcon);
                }
            }
        } else {
            // Desktop: Reset mobile-specific classes
            if (sidebar) sidebar.classList.remove('sidebar-visible');
            
            // Check if any section is active
            const hasActiveSection = Array.from(sidebarIcons).some(icon => 
                icon.classList.contains('active')
            );
            
            // If a section is active, ensure content is expanded
            if (hasActiveSection) {
                if (sidebarContent) sidebarContent.classList.add('expanded');
            } else {
                if (sidebarContent) sidebarContent.classList.remove('expanded');
            }
        }
    }
    
    // File Event Listeners - Simplified
    function setupFileEventListeners() {
        if (!dropArea || !fileInput || !selectFileBtn || !removeTxtBtn) {
            log('Required file upload elements not found', 'error');
            return;
        }
        
        dropArea.addEventListener('click', function(e) {
            if (e.target !== selectFileBtn && !selectFileBtn.contains(e.target)) {
                fileInput.click();
            }
        });
        
        selectFileBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInput.click();
        });
        
        fileInput.addEventListener('change', handleFileSelect);
        
        removeTxtBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeFile();
        });
        
        // Drag and drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        dropArea.addEventListener('drop', handleDrop, false);
    }
    
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    function highlight() {
        if (dropArea) {
            dropArea.classList.add('active');
        }
    }
    
    function unhighlight() {
        if (dropArea) {
            dropArea.classList.remove('active');
        }
    }
    
    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        if (files.length > 0) {
            // Look for TXT file first
            let txtFileFound = false;
            for (let i = 0; i < files.length; i++) {
                if (files[i].name.toLowerCase().endsWith('.txt')) {
                    // Create a new FileList to assign to fileInput.files
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(files[i]);
                    fileInput.files = dataTransfer.files;
                    handleFileSelect();
                    txtFileFound = true;
                    break;
                }
            }
            
            // Look for image files if cover upload is enabled
            if (coverUpload && coverUpload.checked) {
                for (let i = 0; i < files.length; i++) {
                    if (files[i].type.startsWith('image/')) {
                         // Create a new FileList to assign to coverInput.files
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(files[i]);
                        coverInput.files = dataTransfer.files;
                        handleCoverSelect();
                        break;
                    }
                }
            }
            if (!txtFileFound) {
                 log('No .txt file found in dropped files.', 'warning');
            }
        }
    }
    
    function handleFileSelect() {
        if (fileInput.files.length > 0) {
            selectedFile = fileInput.files[0];
            
            // Check if it's a text file
            if (!selectedFile.name.toLowerCase().endsWith('.txt')) {
                log('Error: Not a .txt file', 'error');
                alert('Please select a valid .txt file');
                removeFile();
                return;
            }
            
            // Display file info
            if (txtFileName) txtFileName.textContent = selectedFile.name;
            if (txtFileSize) txtFileSize.textContent = formatFileSize(selectedFile.size);
            if (txtPreview) txtPreview.style.display = 'flex';
            if (fileInfo) fileInfo.style.display = 'block';
            if (dropArea) dropArea.style.display = 'none';
            
            // Detect encoding and update UI
            detectEncoding(selectedFile).then(encodingInfo => {
                detectedEncoding = encodingInfo.encoding;
                if (txtEncoding) txtEncoding.textContent = `${encodingInfo.encoding} (Confidence: ${Math.round(encodingInfo.confidence * 100)}%)`;
                log(`Detected encoding: ${encodingInfo.encoding} with confidence ${Math.round(encodingInfo.confidence * 100)}%`);
                
                // Extract title and author from filename
                extractTitleAuthor(selectedFile.name);
                updateSummary();

                // automatically search for cover if enabled
                if (coverSearch && coverSearch.checked) {
                    searchQidianCover();
                }
            }).catch(error => {
                log(`Error detecting encoding: ${error.message}`, 'error');
                if (txtEncoding) txtEncoding.textContent = 'Encoding: Unknown (error)';
                
                
                // Extract title and author anyway
                extractTitleAuthor(selectedFile.name);
                updateSummary(); // Update summary even if encoding detection fails
                
                // automatically search for cover if enabled
                if (coverSearch && coverSearch.checked) {
                    searchQidianCover();
                }
            });
        }
    }
    
    function handleCoverSelect() {
        if (coverInput.files.length > 0) {
            coverFile = coverInput.files[0];
            
            // Check if it's an image
            if (!coverFile.type.startsWith('image/')) {
                log('Error: Not an image file', 'error');
                alert('Please select a valid image file for the cover');
                coverFile = null;
                coverInput.value = ''; // Clear the input
                if(coverFileName) coverFileName.textContent = '';
                if(coverFileName) coverFileName.style.display = 'none';
                if(coverPreview) coverPreview.src = '';
                if(coverPreview) coverPreview.style.display = 'none';
                updateSummary(); // Update summary to reflect no cover
                return;
            }
            
            if(coverFileName) coverFileName.textContent = `已选择: ${coverFile.name}`;
            if(coverFileName) coverFileName.style.display = 'block';
            
            // Preview the cover
            const reader = new FileReader();
            reader.onload = function(e) {
                coverDataUrl = e.target.result;
                if(coverPreview) coverPreview.src = coverDataUrl;
                if(coverPreview) coverPreview.style.display = 'block';
                
                updateSummary(); // Update summary with the new cover
                log('Cover image loaded successfully');
            };
            
            reader.onerror = function(error) {
                log(`Error reading cover file: ${error}`, 'error');
                coverDataUrl = null; // Reset coverDataUrl on error
                updateSummary(); // Update summary to reflect no cover
            };
            
            reader.readAsDataURL(coverFile);
        }
    }
    
    function removeFile() {
        selectedFile = null;
        fileArrayBuffer = null;
        processedText = null;
        if (fileInput) fileInput.value = '';
        if (txtPreview) txtPreview.style.display = 'none';
        if (fileInfo) fileInfo.style.display = 'none';
        if (dropArea) dropArea.style.display = 'block';
        if (txtFileName) txtFileName.textContent = '';
        if (txtFileSize) txtFileSize.textContent = '';
        if (txtEncoding) txtEncoding.textContent = '';
        
        // Reset cover related to the file
        coverFile = null;
        coverDataUrl = null;
        if (coverInput) coverInput.value = '';
        if (coverFileName) {
            coverFileName.textContent = '';
            coverFileName.style.display = 'none';
        }
        if (coverPreview) {
            coverPreview.src = '';
            coverPreview.style.display = 'none';
        }
        if (bookTitle) bookTitle.value = ''; // Clear book title
        if (bookAuthor) bookAuthor.value = ''; // Clear book author

        updateSummary(); // Update summary after removing file and cover
        log('File and associated cover removed');
    }
    
    // Settings Event Listeners - Simplified
    function setupSettingsEventListeners() {
        // Cover options
        const coverOptionRadios = document.querySelectorAll('input[name="coverOption"]');
        coverOptionRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                toggleCoverOptions();
                if (selectedFile && coverSearch && coverSearch.checked) { // If a file is selected and "Search Online" is chosen
                    searchQidianCover();
                }
                updateSummary();
            });
        });

        if (selectCoverBtn && coverInput) {
            selectCoverBtn.addEventListener('click', () => coverInput.click());
            coverInput.addEventListener('change', handleCoverSelect);
        }
        
        // Chapter pattern
        if (chapterPattern && customChapterArea) {
            chapterPattern.addEventListener('change', function() {
                customChapterArea.style.display = chapterPattern.value === 'custom' ? 'block' : 'none';
                updateSummary();
            });
        }
        
        if (volumePattern && customVolumeArea) {
            volumePattern.addEventListener('change', function() {
                customVolumeArea.style.display = volumePattern.value === 'custom' ? 'block' : 'none';
                updateSummary();
            });
        }
        
        // Book information
        if (bookTitle) {
            bookTitle.addEventListener('input', updateSummary);
        }
        if (bookAuthor) {
            bookAuthor.addEventListener('input', updateSummary);
        }
        
        // Debug mode
        if (debugMode) {
            debugMode.addEventListener('change', updateDebugArea);
        }
    }
    
    function toggleCoverOptions() {
        const coverSearchChecked = coverSearch && coverSearch.checked;
        const coverUploadChecked = coverUpload && coverUpload.checked;

        if (coverUploadArea) coverUploadArea.style.display = coverUploadChecked ? 'block' : 'none';
        // if (coverSearchArea) coverSearchArea.style.display = coverSearchChecked ? 'block' : 'none'; // coverSearchArea does not exist
        if (coverPreviewArea) coverPreviewArea.style.display = (coverSearchChecked || coverUploadChecked) ? 'block' : 'none';

        if (coverNone && coverNone.checked) {
            if (coverPreview) {
                coverPreview.src = '';
                coverPreview.style.display = 'none';
            }
            coverDataUrl = null;
        }
        updateSummary();
    }
    
    async function searchQidianCover() {
        if (isSearchingCover) {
            log('Cover search already in progress.', 'info');
            return; // If a search is already in progress, do nothing
        }

        const bookname = bookTitle.value;
        if (!bookname) {
            log('Cannot search for cover: No book title provided.', 'warning');
            // If no book title, ensure the preview is cleared
            if (coverPreview) {
                coverPreview.src = '';
                coverPreview.style.display = 'none';
            }
            coverDataUrl = null;
            updateSummary();
            return;
        }

        isSearchingCover = true; // Set the flag to indicate a search has started
        if (convertBtn) convertBtn.disabled = true;
        if (coverPreview) { // Show a placeholder or loading state for coverPreview
            coverPreview.src = 'https://placehold.co/150x225/e9ecef/6c757d?text=Searching...';
            coverPreview.style.display = 'block';
        }
        updateSummary(); // Update summary to show searching state
        
        log(`Searching for Qidian cover with query: ${bookname}`);
        
        try {
            const corsProxy = 'https://corsproxy.io/?';
            const targetUrl = encodeURIComponent(`https://m.qidian.com/soushu/${encodeURIComponent(bookname)}.html`);
            const proxyUrl = corsProxy + targetUrl;
            
            log(`Connecting to Qidian search URL: ${targetUrl}`);
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
            
            const response = await fetch(proxyUrl, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`Failed to fetch search results: ${response.status} ${response.statusText}`);
            }
            
            const htmlContent = await response.text();
            log('Received Qidian search page, looking for cover image');
            
            const match = htmlContent.match(/data-src="([^"]+)"/);
            if (!match) {
                throw new Error('No cover image found in search results.');
            }
            
            let imageUrl = match[1];
            log(`Found image URL: ${imageUrl}`);
            
            imageUrl = 'https:' + imageUrl.slice(0, -3) + '600';
            log(`Modified to large version: ${imageUrl}`);
            
            await checkImageExists(imageUrl); // This function should return a promise
            
            coverDataUrl = imageUrl; // Set coverDataUrl on successful fetch and check
            if (coverPreview) {
                coverPreview.src = imageUrl;
                coverPreview.style.display = 'block';
            }
            log('Qidian cover search successful.');

        } catch (error) {
            log(`Qidian cover search error: ${error.message}`, 'error');
            coverDataUrl = null; // Reset on error
            if (coverPreview) {
                coverPreview.src = 'https://placehold.co/150x225/ef476f/ffffff?text=Error'; // Show error placeholder
                coverPreview.style.display = 'block';
            }
        } finally {
            isSearchingCover = false; // Reset the flag in all cases (success or error)
            if (convertBtn) convertBtn.disabled = false; // Re-enable the button
            updateSummary(); // Update summary after search attempt
        }
    }
    
    function checkImageExists(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve();
            img.onerror = () => reject(new Error('Image not found or failed to load from URL: ' + url));
            img.src = url;
        });
    }
    
    function updateSummary() {
        if (summaryTitle) summaryTitle.textContent = bookTitle && bookTitle.value ? bookTitle.value : '未设置';
        if (summaryAuthor) summaryAuthor.textContent = bookAuthor && bookAuthor.value ? bookAuthor.value : '未设置';
        
        let coverSourceText = '无封面';
        if (coverUpload && coverUpload.checked) coverSourceText = '本地上传';
        else if (coverSearch && coverSearch.checked) coverSourceText = '起点网';
        if (summaryCover) summaryCover.textContent = coverSourceText;

        const summaryCoverPreviewImg = document.getElementById('summaryCoverPreview');
        const summaryCoverPlaceholderDiv = document.getElementById('summaryCoverPlaceholder');

        if (summaryCoverPreviewImg && summaryCoverPlaceholderDiv) {
            if (coverDataUrl) {
                summaryCoverPreviewImg.src = coverDataUrl;
                summaryCoverPreviewImg.style.display = 'block';
                summaryCoverPlaceholderDiv.style.display = 'none';
            } else if (coverSearch && coverSearch.checked && isSearchingCover && bookTitle && bookTitle.value) {
                summaryCoverPreviewImg.src = 'https://placehold.co/120x180/e9ecef/6c757d?text=Searching...';
                summaryCoverPreviewImg.style.display = 'block';
                summaryCoverPlaceholderDiv.style.display = 'none';
            }
             else {
                summaryCoverPreviewImg.src = '';
                summaryCoverPreviewImg.style.display = 'none';
                summaryCoverPlaceholderDiv.textContent = (coverNone && coverNone.checked) ? '无封面' : '未选择封面';
                summaryCoverPlaceholderDiv.style.display = 'block';
            }
        }
    }
    
    // Simplified conversion functions
    function setupConversionEventListeners() {
        if (convertBtn) {
            convertBtn.addEventListener('click', startConversion);
        }
        if (downloadBtn) {
            downloadBtn.addEventListener('click', downloadEpub);
        }
        if (convertNewBtn) {
            convertNewBtn.addEventListener('click', resetConverter);
        }
    }
    
    // toggleCustomPattern and toggleCustomVolumePattern are not directly called, 
    // their logic is within setupSettingsEventListeners
    
    function updateDebugArea() {
        if (debugMode && debugAreaDOM) {
            debugAreaDOM.style.display = debugMode.value === 'on' ? 'block' : 'none';
        }
    }
    
    function log(message, level = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        
        // Log to console
        if (level === 'error') console.error(message);
        else if (level === 'warning') console.warn(message);
        else console.log(message);
        
        // Add to debug log if it exists
        if (debugLog && debugMode && debugMode.value === 'on') {
            const logEntry = document.createElement('div');
            let color = '#e0e0e0'; // Default for info
            if (level === 'error') color = '#ef476f'; // Danger color
            else if (level === 'warning') color = '#f7b801'; // Warning color
            else if (level === 'success') color = '#34a853'; // Success color

            logEntry.style.color = color;
            logEntry.textContent = `[${timestamp}] ${level.toUpperCase()}: ${message}`;
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
        }
    }
    
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    function extractTitleAuthor(filename) {
        log(`Extracting title/author from filename: ${filename}`);
        
        let name = filename.replace(/\.txt$/i, '');
        
        const chineseTitleAuthorPattern = /《([^》]+)》[^作者]*作者[：:]\s*([^.]+)(?:\.txt)?$/;
        const chineseMatch = name.match(chineseTitleAuthorPattern);
        
        if (chineseMatch) {
            if (bookTitle) bookTitle.value = chineseMatch[1].trim();
            if (chineseMatch[2] && bookAuthor) {
                bookAuthor.value = chineseMatch[2].trim();
            }
            log(`Extracted title: "${bookTitle.value}" and author: "${bookAuthor ? bookAuthor.value : 'N/A'}"`);
            return;
        }
        
        const englishTitleAuthorPattern = /(.+?)(?:\s+-\s+|\s+by\s+)(.+)/i;
        const englishMatch = name.match(englishTitleAuthorPattern);
        
        if (englishMatch) {
            if (bookTitle) bookTitle.value = englishMatch[1].trim();
            if (bookAuthor) bookAuthor.value = englishMatch[2].trim();
            log(`Extracted title: "${bookTitle ? bookTitle.value : 'N/A'}" and author: "${bookAuthor ? bookAuthor.value : 'N/A'}"`);
            return;
        }
        
        if (bookTitle) bookTitle.value = name.trim();
        if (bookAuthor) bookAuthor.value = ''; // Clear author if no pattern matches
        log(`Using filename as title: "${bookTitle ? bookTitle.value : 'N/A'}", author cleared.`);
    }
    
    async function detectEncoding(file) {
        log('Starting encoding detection...');
        try {
            const arrayBuffer = await readFileAsArrayBuffer(file);
            fileArrayBuffer = arrayBuffer; 
            
            if (typeof jschardet === 'undefined') {
                log('jschardet library not found, using UTF-8 as default encoding', 'warning');
                return { encoding: 'UTF-8', confidence: 0.9 };
            }
            
            const sampleSize = Math.min(4096, arrayBuffer.byteLength);
            const sampleData = new Uint8Array(arrayBuffer, 0, sampleSize);
            
            const result = jschardet.detect(sampleData);
            
            let encoding = result.encoding || 'UTF-8';
            
            if (encoding === 'ascii' || encoding === 'windows-1252') {
                const possibleChinese = detectChineseEncoding(sampleData);
                if (possibleChinese) {
                    encoding = 'GB18030';
                    result.confidence = 0.85; 
                }
            }
            
            const mappedEncoding = mapEncodingName(encoding);
            log(`Encoding detection complete: ${mappedEncoding} (original: ${encoding})`);
            return {
                encoding: mappedEncoding,
                confidence: result.confidence || 0.5
            };
        } catch (error) {
            log(`Encoding detection failed: ${error.message}`, 'error');
            throw error;
        }
    }
    
    function detectChineseEncoding(data) {
        let gbkPatternCount = 0;
        for (let i = 0; i < data.length - 1; i++) {
            if (data[i] >= 0x81 && data[i] <= 0xFE) {
                if (data[i+1] >= 0x40 && data[i+1] <= 0xFE) {
                    gbkPatternCount++;
                }
            }
        }
        return gbkPatternCount > 20; // Heuristic: if more than 20 GBK-like pairs found
    }
    
    function mapEncodingName(encoding) {
        if (!encoding) return 'UTF-8';
        const lowerEncoding = encoding.toLowerCase();
        const encodingMap = {
            'gb2312': 'GB18030',
            'gbk': 'GB18030',
            'gb18030': 'GB18030',
            'windows-1252': 'windows-1252', // Keep as some files are genuinely this
            'ascii': 'UTF-8', // ASCII is a subset of UTF-8
            'utf-8': 'UTF-8',
            'utf8': 'UTF-8',
            'big5': 'Big5',
            // Add more mappings as needed
        };
        return encodingMap[lowerEncoding] || encoding; // Return original if no mapping
    }
    
    async function readFileAsArrayBuffer(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(new Error('Failed to read file as ArrayBuffer.'));
            reader.readAsArrayBuffer(file);
        });
    }
    
    async function decodeText(arrayBuffer, encodingName) {
        log(`Decoding text with encoding: ${encodingName}`);
        try {
            const decoder = new TextDecoder(encodingName, { fatal: true }); // fatal: true will throw error on invalid sequences
            return decoder.decode(arrayBuffer);
        } catch (error) {
            log(`TextDecoder failed for ${encodingName}: ${error.message}. Falling back to UTF-8.`, 'warning');
            // Fallback to UTF-8 if the specified encoding fails
            try {
                const fallbackDecoder = new TextDecoder('UTF-8', { fatal: false }); // non-fatal for fallback
                return fallbackDecoder.decode(arrayBuffer);
            } catch (fallbackError) {
                 log(`Fallback UTF-8 decoding also failed: ${fallbackError.message}`, 'error');
                 throw new Error(`Failed to decode text with ${encodingName} and fallback UTF-8.`);
            }
        }
    }
    
    async function startConversion() {
        if (!selectedFile) {
            alert('请选择一个 TXT 文件');
            return;
        }
        
        const title = (bookTitle && bookTitle.value) ? bookTitle.value : '未知标题';
        const author = (bookAuthor && bookAuthor.value) ? bookAuthor.value : '未知作者';
        const language = bookLanguage ? bookLanguage.value : 'en';
        
        const options = {
            title: title,
            author: author,
            language: language,
            chapterPattern: getChapterPatternRegex(),
            volumePattern: getVolumePatternRegex(),
            maxTitleLength: maxTitleLength ? parseInt(maxTitleLength.value) : 35,
            unknownTitleName: unknownTitleName ? unknownTitleName.value : '章节正文',
            indent: indent ? parseInt(indent.value) : 2,
            titleAlign: titleAlign ? titleAlign.value : 'center',
            fontFamily: fontFamily ? fontFamily.value : 'default',
            fontSize: fontSize ? fontSize.value : '100%',
            lineHeight: lineHeight ? lineHeight.value : '1.5',
            paragraphSpacing: paragraphSpacing ? paragraphSpacing.value : '1em'
        };
        
        log(`Starting conversion with options: ${JSON.stringify(options)}`, 'info');
        
        if (uploadCard) uploadCard.style.display = 'none';
        // const optionsElement = document.querySelector('.options'); // '.options' class doesn't exist
        // if (optionsElement) optionsElement.style.display = 'none';
        if (debugAreaDOM) debugAreaDOM.style.display = (debugMode && debugMode.value === 'on') ? 'block' : 'none'; // Show if debug is on
        if (progressCard) progressCard.style.display = 'block';
        if (convertBtn) convertBtn.disabled = true; // Disable convert button during processing
        
        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += Math.random() * 5 + 2; // Make progress a bit faster and less random
            if (progress > 95 && progress < 100) progress = 95; // Hold at 95% until done
            else if (progress >= 100) progress = 99; // Cap at 99 until actual completion
            
            if (progressBar) progressBar.style.width = `${progress}%`;
            
            if (progressStatus) {
                if (progress < 20) progressStatus.textContent = '读取和解码文本文件...';
                else if (progress < 40) progressStatus.textContent = '检测章节和卷...';
                else if (progress < 60) progressStatus.textContent = '格式化内容...';
                else if (progress < 80) progressStatus.textContent = '创建EPUB结构...';
                else progressStatus.textContent = '正在完成您的电子书...';
            }
        }, 150);
        
        try {
            let text;
            if (!fileArrayBuffer && selectedFile) { // Ensure fileArrayBuffer is populated
                 log('File ArrayBuffer not found, reading file again.', 'warning');
                 fileArrayBuffer = await readFileAsArrayBuffer(selectedFile);
            }
            if (!fileArrayBuffer) throw new Error("无法读取文件内容。");

            text = await decodeText(fileArrayBuffer, detectedEncoding || 'UTF-8');
            
            text = cleanText(text);
            log(`Text cleaned. Length: ${text.length} characters`);
            
            processedText = processText(text, options);
            log(`Text processed. Found ${countSections(processedText)} sections`);
            
            let finalCoverDataUrl = null; // Use this for EPUB generation
            if (coverUpload && coverUpload.checked && coverFile) {
                finalCoverDataUrl = await readFileAsDataURL(coverFile);
            } else if (coverSearch && coverSearch.checked && coverDataUrl && coverDataUrl.startsWith('http')) {
                // If coverDataUrl is an HTTP URL from search, fetch it as DataURL
                finalCoverDataUrl = await fetchImageAsDataURL(coverDataUrl);
            } else if (coverSearch && coverSearch.checked && coverDataUrl && coverDataUrl.startsWith('data:')) {
                // If coverDataUrl is already a DataURL from search (e.g., placeholder or successfully fetched)
                finalCoverDataUrl = coverDataUrl;
            }
            // If coverNone is checked, finalCoverDataUrl remains null

            if (typeof JSZip === 'undefined') {
                throw new Error('JSZip library not found. Please include it in your HTML.');
            }
            
            epubBlob = await generateEpub(processedText, finalCoverDataUrl, options);
            log(`EPUB created successfully. Size: ${formatFileSize(epubBlob.size)}`, 'success');
            
            clearInterval(progressInterval); // Stop the fake progress
            if (progressBar) progressBar.style.width = '100%';
            if (progressStatus) progressStatus.textContent = '转换完成！';
            
            setTimeout(() => {
                if (progressCard) progressCard.style.display = 'none';
                // if (uploadCard) uploadCard.style.display = 'none'; // Keep upload card hidden
                if (resultCard) resultCard.style.display = 'block';
                if (resultFileName) resultFileName.textContent = `${sanitizeFilename(title)}.epub`;
                if (resultFileSize) resultFileSize.textContent = formatFileSize(epubBlob.size);
                if (convertBtn) convertBtn.disabled = false; // Re-enable convert button
            }, 500);

        } catch (error) {
            clearInterval(progressInterval);
            log(`Conversion error: ${error.message}`, 'error');
            alert(`转换过程中发生错误: ${error.message}`);
            if (convertBtn) convertBtn.disabled = false; // Re-enable on error
            resetConverter(); // Reset to initial state on error
        }
    }
    
    function getChapterPatternRegex() {
        if (!chapterPattern) {
            return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i;
        }
        
        switch (chapterPattern.value) {
            case 'auto':
                return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i;
            case 'chinese':
                return /^第[0-9一二三四五六七八九十百千万亿零〇]+[章节回集幕部篇](\s|$)/;
            case 'english':
                return /^(Chapter|CHAPTER)\s+([0-9]+|[IVXLCDM]+)(\s|$)/i;
            // case 'japanese': // Not in select options
            //     return /^第[0-9一二三四五六七八九十百千万億零〇]+話/;
            case 'numbered':
                return /^\d+\.\s+/;
            case 'custom':
                try {
                    if (customChapterPattern && customChapterPattern.value) {
                        return new RegExp(customChapterPattern.value, 'i'); // Add 'i' flag for case-insensitivity if desired
                    } else {
                        log('Empty custom chapter pattern, using auto-detect instead', 'warning');
                        return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i;
                    }
                } catch (e) {
                    log(`Invalid chapter regex pattern: ${e.message}`, 'error');
                    alert('无效的自定义章节模式。将使用自动检测。');
                    return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i;
                }
            default:
                return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i;
        }
    }
    
    function getVolumePatternRegex() {
        if (!volumePattern || volumePattern.value === 'disabled') {
            return null;
        }
        
        switch (volumePattern.value) {
            case 'auto':
                return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i;
            case 'chinese':
                return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)/;
            case 'english':
                return /^(Volume|Book)\s+([0-9]+|[IVXLCDM]+)(\s|$)/i;
            case 'custom':
                try {
                    if (customVolumePattern && customVolumePattern.value) {
                        return new RegExp(customVolumePattern.value, 'i'); // Add 'i' flag
                    } else {
                        log('Empty custom volume pattern, using auto-detect instead', 'warning');
                        return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i;
                    }
                } catch (e) {
                    log(`Invalid volume regex pattern: ${e.message}`, 'error');
                    alert('无效的自定义卷/部模式。将使用自动检测。');
                    return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i;
                }
            default:
                 return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i;
        }
    }
    
    function resetConverter() {
        if (uploadCard) uploadCard.style.display = 'block';
        if (dropArea) dropArea.style.display = 'block'; // Show drop area again
        if (fileInfo) fileInfo.style.display = 'none'; // Hide file info
        // const optionsElement = document.querySelector('.options'); // No .options element
        // if (optionsElement) optionsElement.style.display = 'block';
        if (progressCard) progressCard.style.display = 'none';
        if (resultCard) resultCard.style.display = 'none';
        
        if (progressBar) progressBar.style.width = '0%';
        if (progressStatus) progressStatus.textContent = '';
        
        updateDebugArea(); // Show/hide debug area based on setting
        
        removeFile(); // This will clear file, cover, title, author and update summary

        // Reset options to default if needed (example for custom patterns)
        if (chapterPattern && customChapterPattern) {
            chapterPattern.value = 'auto'; // Reset select to auto
            customChapterPattern.value = ''; // Clear custom input
            if (customChapterArea) customChapterArea.style.display = 'none';
        }
        if (volumePattern && customVolumePattern) {
            volumePattern.value = 'auto';
            customVolumePattern.value = '';
            if (customVolumeArea) customVolumeArea.style.display = 'none';
        }
        
        // Reset cover radio to "Search Online"
        if (coverSearch) coverSearch.checked = true;
        toggleCoverOptions(); // Update visibility of cover sections
        
        epubBlob = null;
        if (convertBtn) convertBtn.disabled = false; // Ensure convert button is enabled
        
        log('Converter reset to initial state', 'info');
    }
    
    function downloadEpub() {
        if (!epubBlob) {
            log('Download error: No EPUB file generated', 'error');
            alert('错误：没有生成 EPUB 文件');
            return;
        }
        
        const title = (bookTitle && bookTitle.value) ? bookTitle.value : 'Untitled_Book';
        const filename = `${sanitizeFilename(title)}.epub`;
        
        if (typeof saveAs === 'undefined') {
            log('FileSaver.js not found, using fallback download method', 'warning');
            const url = URL.createObjectURL(epubBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        } else {
            saveAs(epubBlob, filename);
        }
        
        log(`EPUB downloaded as: ${filename}`, 'success');
    }
    
    function sanitizeFilename(name) {
        if (!name) return 'Untitled';
        return name
            .replace(/[\/\\:*?"<>|]/g, '_') 
            .replace(/\s+/g, '_')          
            .replace(/__+/g, '_')           
            .replace(/^_+|_+$/g, '');       
    }
    
    function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = (error) => reject(new Error(`Failed to read file as DataURL: ${error}`));
            reader.readAsDataURL(file);
        });
    }

    async function fetchImageAsDataURL(imageUrl) {
        try {
            // Create a new image element
            const img = new Image();
            
            // Set up a promise to handle the image loading
            const imageLoaded = new Promise((resolve, reject) => {
                img.crossOrigin = 'Anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image from URL: ' + imageUrl));
                
                // Set a timeout in case the image takes too long to load
                const timeoutId = setTimeout(() => {
                    reject(new Error('Timeout loading image from URL: ' + imageUrl));
                }, 10000); // 10 second timeout
                
                // Clear timeout if image loads or errors
                img.onload = () => {
                    clearTimeout(timeoutId);
                    resolve(img);
                };
                img.onerror = () => {
                    clearTimeout(timeoutId);
                    reject(new Error('Failed to load image from URL: ' + imageUrl));
                };
            });
            
            // Set the source to start loading the image
            img.src = imageUrl;
            
            // Wait for the image to load
            const loadedImg = await imageLoaded;
            
            // Create a canvas to convert the image to a data URL
            const canvas = document.createElement('canvas');
            canvas.width = loadedImg.width;
            canvas.height = loadedImg.height;
            const ctx = canvas.getContext('2d');
            
            // Draw the image to the canvas
            ctx.drawImage(loadedImg, 0, 0);
            
            // Try to get the data URL
            try {
                return canvas.toDataURL('image/jpeg');
            } catch (error) {
                throw new Error(`Failed to convert image to data URL: ${error.message}`);
            }
        } catch (error) {
            log(`Error fetching image: ${error.message}`, 'error');
            throw error;
        }
    }
    
    function cleanText(text) {
        log('Cleaning text...');
        text = text.replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\x7F\uFFFE\uFFFF]/g, ''); // Remove most control characters
        text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n'); // Normalize line endings
        text = text.replace(/\uFFFD/g, '');  // CORRECTED: Remove Unicode replacement character
        
        // Common ad/junk lines (case-insensitive, multiline)
        const junkPatterns = [
            /^\s*(最新章节请到)\s*.*?\.com\s*$/gim,
            /^\s*(请收藏本站)\s*.*?\.com\s*$/gim,
            /^\s*(看最新章节)\s*.*?\.com\s*$/gim,
            /^\s*(手机用户请到)\s*.*?\.com\s*阅读\s*$/gim,
            /^\s*www\..*?\.(com|net|org)\s*$/gim,
            /^\s*小说来源[:：].*$/gim,
            /^\s*下载地址[:：].*$/gim,
            /^\s*本书首发来自.*$/gim,
            /^\s*更多精校小说尽在.*$/gim,
            /^\s*【本作品来自互联网.*$/gim,
            /^\s*------------.*$/gim,
            /^\s*========.*$/gim,
            /^\s*ps[:：].*$/gim, // Often contains author notes not part of story
        ];
        junkPatterns.forEach(pattern => {
            text = text.replace(pattern, '');
        });

        text = text.replace(/^\s*本文来自.*$/gm, ''); // Remove lines starting with "本文来自"
        text = text.replace(/^\s*正文\s*$/gm, '');   // Remove lines that only say "正文"
        text = text.replace(/^\s*序章\s*$/gm, '');   // Remove lines that only say "序章" if they are not actual titles

        // Reduce multiple blank lines to a single blank line
        text = text.replace(/\n\s*\n/g, '\n\n');
        return text.trim(); // Trim leading/trailing whitespace from the whole text
    }
    
    function processText(text, options) {
        log('Processing text to detect chapters and volumes...');
        const lines = text.split('\n');
        const sections = [];
        let currentVolume = null;
        let currentChapter = {
            title: options.unknownTitleName,
            type: 'text', // Default type
            content: []
        };
        let hasContentSinceLastTitle = false;
        
        const chapterRegex = options.chapterPattern;
        const volumeRegex = options.volumePattern;
        const maxLen = options.maxTitleLength;

        for (let i = 0; i < lines.length; i++) {
            let line = lines[i].trim();
            
            if (!line) continue; // Skip empty lines

            // Check if line is a potential title (not too long, matches regex or is short)
            let isPotentialTitle = line.length <= maxLen;
            let isVolumeTitle = volumeRegex && volumeRegex.test(line) && isPotentialTitle;
            let isChapterTitle = chapterRegex && chapterRegex.test(line) && isPotentialTitle;
            
            if (isVolumeTitle) {
                if (hasContentSinceLastTitle && currentChapter.content.length > 0) {
                    if (currentVolume) currentVolume.chapters.push(currentChapter);
                    else sections.push(currentChapter);
                }
                if (currentVolume) sections.push(currentVolume); // Push previous volume

                currentVolume = { title: line, type: 'volume', chapters: [] };
                currentChapter = { title: options.unknownTitleName, type: 'text', content: [] }; // Reset chapter for new volume
                hasContentSinceLastTitle = false;
                log(`New Volume: ${line}`);
            } else if (isChapterTitle) {
                if (hasContentSinceLastTitle && currentChapter.content.length > 0) {
                    if (currentVolume) currentVolume.chapters.push(currentChapter);
                    else sections.push(currentChapter);
                }
                currentChapter = { title: line, type: 'chapter', content: [] };
                hasContentSinceLastTitle = false;
                log(`New Chapter: ${line}`);
            } else {
                // This is a content line
                if (line.toLowerCase().includes("本章未完") || line.toLowerCase().includes("点击下一页")) continue;
                if (line.startsWith("（本章完）")) continue;

                currentChapter.content.push(line);
                hasContentSinceLastTitle = true;
            }
        }
        
        // Add the last processed chapter/volume
        if (hasContentSinceLastTitle && currentChapter.content.length > 0) {
            if (currentVolume) currentVolume.chapters.push(currentChapter);
            else sections.push(currentChapter);
        }
        if (currentVolume) sections.push(currentVolume); // Push the last volume if it exists

        // Post-process to ensure all chapters have titles and paragraphs
        const finalSections = [];
        sections.forEach(section => {
            if (section.type === 'volume') {
                if (section.chapters.length > 0) {
                    section.chapters.forEach(chap => {
                        if (!chap.title || chap.title === options.unknownTitleName) {
                            chap.title = `${options.unknownTitleName}`;
                        }
                        chap.paragraphs = processParagraphs(chap.content);
                    });
                    finalSections.push(section);
                } else {
                    log(`Skipping empty volume: ${section.title}`, 'warning');
                }
            } else { // Chapter outside a volume
                if (!section.title || section.title === options.unknownTitleName) {
                    section.title = `${options.unknownTitleName}`;
                }
                section.paragraphs = processParagraphs(section.content);
                if (section.paragraphs.length > 0) {
                     finalSections.push(section);
                } else {
                    log(`Skipping empty chapter: ${section.title}`, 'warning');
                }
            }
        });
        
        log(`Found ${countSections(finalSections)} total sections (including volumes and chapters) after processing.`);
        return finalSections;
    }
    
    function countSections(sections) {
        let count = 0;
        for (let i = 0; i < sections.length; i++) {
            if (sections[i].type === 'volume') {
                count += 1 + sections[i].chapters.length; // Count volume + its chapters
            } else {
                count++; // Count standalone chapter
            }
        }
        return count;
    }
    
    function processParagraphs(lines) {
        const paragraphs = [];
        if (!lines) return paragraphs;
        // Each line is a paragraph for now, can be enhanced later
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].trim()) { // Ensure paragraph is not just whitespace
                paragraphs.push(lines[i].trim());
            }
        }
        return paragraphs;
    }
    
    async function generateEpub(sections, coverImageDataUrl, options) {
        log('Generating EPUB file...');
        try {
            if (typeof JSZip === 'undefined') throw new Error('JSZip library not found');
            
            const zip = new JSZip();
            zip.file('mimetype', 'application/epub+zip', {compression: "STORE"});
            
            const metaInf = zip.folder('META-INF');
            metaInf.file('container.xml', 
                '<?xml version="1.0" encoding="UTF-8"?>' +
                '<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">' +
                '<rootfiles><rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/></rootfiles>' +
                '</container>'
            );
            
            const oebps = zip.folder('OEBPS');
            const imagesFolder = oebps.folder('images'); 
            
            const fontFamilyCSS = getFontFamilyCSS(options.fontFamily);
            const titleAlignCSS = `text-align: ${options.titleAlign};`;
            const indentVal = `${options.indent}em`;
            
            const styleContent = 
                `body { ${fontFamilyCSS} margin: 20px; line-height: ${options.lineHeight}; font-size: ${options.fontSize}; }
                h1, h2, h3 { margin-top: 1.5em; margin-bottom: 0.8em; font-weight: bold; ${titleAlignCSS} }
                h1 { font-size: 2em; } /* Book Title on title page, Volume Title */
                h2 { font-size: 1.6em; } /* Chapter Title */
                h3 { font-size: 1.3em; } /* Sub-headings if any, or special sections */
                p { text-indent: ${indentVal}; margin: 0 0 ${options.paragraphSpacing} 0; hyphens: auto; text-align: justify; }
                p.no-indent { text-indent: 0; } /* For specific paragraphs like first in chapter */
                .title-page .book-title { font-size: 2.5em; margin-bottom: 0.5em; ${titleAlignCSS} }
                .title-page .author { font-size: 1.5em; margin-bottom: 3em; ${titleAlignCSS} font-style: italic; }
                .cover-page img { max-width: 100%; height: auto; display: block; margin: 0 auto; max-height: 95vh; }
                .volume-title { page-break-before: always; margin-top: 3em; }
                .chapter-title { page-break-before: always; margin-top: 2em; }
                .special-title { font-style: italic; }
                nav ol { list-style-type: none; padding-left: 0; }
                nav ol ol { padding-left: 1.5em; }
                nav a { text-decoration: none; color: var(--primary-color, #4361ee); }
                nav a:hover { text-decoration: underline; }
                /* Kindle specific considerations */
                @media amzn-kf8 { 
                    body { font-family: "Amazon Ember", "Bookerly", serif; }
                    p { text-align: justify; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; }
                }
                @media amzn-mobi { 
                    body { font-family: serif; } 
                    p { text-align: left; } /* Justify might not work well on older mobi */
                }`;
            oebps.file('stylesheet.css', styleContent);
            
            const uuid = 'urn:uuid:' + generateUUID();
            let coverImagePath = null;
            let coverImageType = 'image/jpeg'; // Default
            
            if (coverImageDataUrl && coverImageDataUrl.startsWith('data:')) {
                // CORRECTED Regex for cover image data URL
                const match = coverImageDataUrl.match(/^data:(image\/(?:png|jpeg|gif|webp|svg\+xml));base64,(.+)$/);
                if (match && match[1] && match[2]) {
                    coverImageType = match[1];
                    const base64Data = match[2];
                    const ext = coverImageType.split('/')[1].replace('svg+xml', 'svg') || 'jpg'; // Handle svg+xml
                    coverImagePath = `images/cover.${ext}`;
                    imagesFolder.file(`cover.${ext}`, base64Data, {base64: true});
                    log(`Cover image added: ${coverImagePath} (Type: ${coverImageType})`);
                } else {
                     log(`Invalid cover image data URL format: ${coverImageDataUrl.substring(0,100)}... Skipping cover.`, 'warning');
                }
            } else if (coverImageDataUrl) { // If it's not a data URL but exists (e.g. http link that wasn't converted)
                log(`Cover image data is not a Data URL. Attempting to use as is, but might fail: ${coverImageDataUrl.substring(0,100)}`, 'warning');
                 // This case should ideally be handled by fetchImageAsDataURL converting it first.
                 // If it reaches here as an HTTP URL, it's likely an issue.
            }


            // Create title page
            oebps.file('title.xhtml',
                `<?xml version="1.0" encoding="UTF-8"?>
                <!DOCTYPE html>
                <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}">
                <head>
                    <meta charset="UTF-8" />
                    <title>${escapeXML(options.title)}</title>
                    <link rel="stylesheet" type="text/css" href="stylesheet.css" />
                </head>
                <body class="title-page">
                    <div id="title_page_main" class="book-title">${escapeXML(options.title)}</div>
                    <div class="author">${escapeXML(options.author)}</div>
                </body>
                </html>`
            );
            
            if (coverImagePath) {
                oebps.file('cover.xhtml',
                    `<?xml version="1.0" encoding="UTF-8"?>
                    <!DOCTYPE html>
                    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}">
                    <head>
                        <meta charset="UTF-8" />
                        <title>Cover</title>
                        <link rel="stylesheet" type="text/css" href="stylesheet.css" />
                    </head>
                    <body class="cover-page">
                        <div id="cover_image_container"><img src="${coverImagePath}" alt="Cover Image" /></div>
                    </body>
                    </html>`
                );
            }
            
            let manifestItems = '';
            let spineItems = '';
            const navDocLinks = []; 
            let ncxNavPoints = ''; 
            let playOrder = 1;

            // Cover Page
            if (coverImagePath) {
                manifestItems += `<item id="cover-img" href="${coverImagePath}" media-type="${coverImageType}" properties="cover-image"/>\n`;
                manifestItems += `<item id="cover-page" href="cover.xhtml" media-type="application/xhtml+xml"/>\n`;
                spineItems += `<itemref idref="cover-page" linear="yes"/>\n`; 
                // No TOC entry for cover page itself, but landmark will point to it.
            }
            
            // Title Page
            const titlePageNavId = "titlepage";
            manifestItems += `<item id="title-page" href="title.xhtml" media-type="application/xhtml+xml"/>\n`;
            spineItems += `<itemref idref="title-page"/>\n`;
            navDocLinks.push({ title: '书名页', href: `title.xhtml#title_page_main`, level: 1 }); // Link to an ID within title page
            ncxNavPoints += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>书名页</text></navLabel><content src="title.xhtml#title_page_main"/></navPoint>\n`;


            manifestItems += `<item id="css" href="stylesheet.css" media-type="text/css"/>\n`;
            
            sections.forEach((section, sectionIndex) => {
                const sectionBaseId = `s_${sectionIndex + 1}`; // Unique base ID for the section

                if (section.type === 'volume') {
                    const volumeAnchorId = `${sectionBaseId}_vol_title`;
                    const volumeFilename = `${sectionBaseId}_vol.xhtml`;
                    
                    let volumePageContent = `<?xml version="1.0" encoding="UTF-8"?>
                        <!DOCTYPE html>
                        <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}">
                        <head>
                            <meta charset="UTF-8" />
                            <title>${escapeXML(section.title)}</title>
                            <link rel="stylesheet" type="text/css" href="stylesheet.css" />
                        </head>
                        <body>
                            <h1 id="${volumeAnchorId}" class="volume-title" epub:type="volume z3998:roman">${escapeXML(section.title)}</h1>
                        </body></html>`;
                    oebps.file(volumeFilename, volumePageContent);

                    manifestItems += `<item id="${sectionBaseId}-vol" href="${volumeFilename}" media-type="application/xhtml+xml"/>\n`;
                    spineItems += `<itemref idref="${sectionBaseId}-vol"/>\n`;
                    
                    const volumeNavEntry = { title: escapeXML(section.title), href: `${volumeFilename}#${volumeAnchorId}`, level: 1, children: [] };
                    navDocLinks.push(volumeNavEntry);
                    ncxNavPoints += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(section.title)}</text></navLabel><content src="${volumeFilename}#${volumeAnchorId}"/>\n`;
                    
                    let volumeNcxChildren = '';
                    section.chapters.forEach((chapter, chapterIndex) => {
                        const chapterAnchorId = `${sectionBaseId}_ch${chapterIndex + 1}_title`;
                        const chapterFilename = `${sectionBaseId}_ch${chapterIndex + 1}.xhtml`;
                        
                        let chapterHtml = `<?xml version="1.0" encoding="UTF-8"?>
                            <!DOCTYPE html>
                            <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}">
                            <head>
                                <meta charset="UTF-8" />
                                <title>${escapeXML(chapter.title)}</title>
                                <link rel="stylesheet" type="text/css" href="stylesheet.css" />
                            </head>
                            <body>
                                <h2 id="${chapterAnchorId}" class="chapter-title ${chapter.type === 'special' ? 'special-title' : ''}" epub:type="chapter ${chapter.type === 'special' ? 'z3998:credits' : ''}">${escapeXML(chapter.title)}</h2>`;
                        chapter.paragraphs.forEach(p => { chapterHtml += `<p>${escapeXML(p)}</p>\n`; });
                        chapterHtml += `</body></html>`;
                        oebps.file(chapterFilename, chapterHtml);
                        
                        manifestItems += `<item id="${sectionBaseId}-ch${chapterIndex + 1}" href="${chapterFilename}" media-type="application/xhtml+xml"/>\n`;
                        spineItems += `<itemref idref="${sectionBaseId}-ch${chapterIndex + 1}"/>\n`;
                        
                        volumeNavEntry.children.push({ title: escapeXML(chapter.title), href: `${chapterFilename}#${chapterAnchorId}`, level: 2 });
                        volumeNcxChildren += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(chapter.title)}</text></navLabel><content src="${chapterFilename}#${chapterAnchorId}"/></navPoint>\n`;
                    });
                    ncxNavPoints += volumeNcxChildren + `</navPoint>\n`; // Close volume navPoint
                } else { // Standalone chapter
                    const chapterAnchorId = `${sectionBaseId}_title`;
                    const chapterFilename = `${sectionBaseId}.xhtml`;
                    let chapterHtml = `<?xml version="1.0" encoding="UTF-8"?>
                        <!DOCTYPE html>
                        <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}">
                        <head>
                            <meta charset="UTF-8" />
                            <title>${escapeXML(section.title)}</title>
                            <link rel="stylesheet" type="text/css" href="stylesheet.css" />
                        </head>
                        <body>
                            <h2 id="${chapterAnchorId}" class="chapter-title ${section.type === 'special' ? 'special-title' : ''}" epub:type="chapter ${section.type === 'special' ? 'z3998:credits' : ''}">${escapeXML(section.title)}</h2>`;
                    section.paragraphs.forEach(p => { chapterHtml += `<p>${escapeXML(p)}</p>\n`; });
                    chapterHtml += `</body></html>`;
                    oebps.file(chapterFilename, chapterHtml);

                    manifestItems += `<item id="${sectionBaseId}" href="${chapterFilename}" media-type="application/xhtml+xml"/>\n`;
                    spineItems += `<itemref idref="${sectionBaseId}"/>\n`;
                    navDocLinks.push({ title: escapeXML(section.title), href: `${chapterFilename}#${chapterAnchorId}`, level: 1 });
                    ncxNavPoints += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(section.title)}</text></navLabel><content src="${chapterFilename}#${chapterAnchorId}"/></navPoint>\n`;
                }
            });

            // EPUB 3 Navigation Document (nav.xhtml)
            let navDocHtml = `<?xml version="1.0" encoding="UTF-8"?>
                <!DOCTYPE html>
                <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}">
                <head>
                    <title>Table of Contents</title>
                    <meta charset="utf-8"/>
                    <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
                </head>
                <body>
                    <nav epub:type="toc" id="toc">
                        <h1>目录</h1>
                        <ol>`;
            navDocLinks.forEach(item => {
                navDocHtml += `<li><a href="${item.href}">${item.title}</a>`;
                if (item.children && item.children.length > 0) {
                    navDocHtml += `<ol>`;
                    item.children.forEach(child => {
                        navDocHtml += `<li><a href="${child.href}">${child.title}</a></li>\n`;
                    });
                    navDocHtml += `</ol>`;
                }
                navDocHtml += `</li>\n`;
            });
            navDocHtml += `</ol></nav>
                    <nav epub:type="landmarks" hidden="hidden">
                        <h2>Landmarks</h2>
                        <ol>`;
            if (coverImagePath) navDocHtml += `<li><a epub:type="cover" href="cover.xhtml#cover_image_container">封面</a></li>\n`;
            
            // Find first actual chapter/volume content for bodymatter
            const firstContentItem = navDocLinks.find(item => item.href && (item.href.includes("_vol.xhtml#") || item.href.includes("_ch1.xhtml#") || item.href.includes("s_1.xhtml#")));
            const bodyMatterHref = firstContentItem ? firstContentItem.href : (navDocLinks.length > 0 ? navDocLinks[0].href : "title.xhtml#title_page_main");
            navDocHtml += `<li><a epub:type="bodymatter" href="${bodyMatterHref}">开始阅读</a></li>\n`;
            navDocHtml += `<li><a epub:type="toc" href="nav.xhtml#toc">目录</a></li>\n`;
            navDocHtml += `</ol></nav></body></html>`;
            oebps.file('nav.xhtml', navDocHtml);
            manifestItems += `<item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>\n`;

            // EPUB 2 NCX (toc.ncx)
            const ncxContent = `<?xml version="1.0" encoding="UTF-8"?>
                <ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
                <head>
                    <meta name="dtb:uid" content="${uuid}"/>
                    <meta name="dtb:depth" content="2"/> 
                    <meta name="dtb:totalPageCount" content="0"/>
                    <meta name="dtb:maxPageNumber" content="0"/>
                </head>
                <docTitle><text>${escapeXML(options.title)}</text></docTitle>
                <navMap>${ncxNavPoints}</navMap>
                </ncx>`;
            oebps.file('toc.ncx', ncxContent);
            manifestItems += `<item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>\n`;
            
            // content.opf
            const contentOpf = `<?xml version="1.0" encoding="UTF-8"?>
                <package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="BookId">
                <metadata xmlns:dc="http://purl.org/dc/elements/1.1/">
                    <dc:title>${escapeXML(options.title)}</dc:title>
                    <dc:creator id="creator">${escapeXML(options.author)}</dc:creator>
                    <dc:language>${options.language}</dc:language>
                    <dc:identifier id="BookId">${uuid}</dc:identifier>
                    <meta property="dcterms:modified">${new Date().toISOString().split('.')[0]+"Z"}</meta>
                    ${coverImagePath ? '<meta name="cover" content="cover-img"/>' : ''}
                </metadata>
                <manifest>
                    ${manifestItems}
                </manifest>
                <spine toc="ncx">
                    ${spineItems}
                </spine>
                </package>`;
            oebps.file('content.opf', contentOpf);
            
            const epubData = await zip.generateAsync({
                type: 'blob',
                mimeType: 'application/epub+zip',
                compression: 'DEFLATE',
                compressionOptions: { level: 9 }
            });
            log('EPUB blob generated.', 'success');
            return epubData;

        } catch (error) {
            log(`Error generating EPUB: ${error.message}`, 'error');
            console.error("EPUB Generation Error Details:", error);
            throw error; // Re-throw to be caught by startConversion
        }
    }
    
    function getFontFamilyCSS(fontType) {
        switch (fontType) {
            case 'serif': return 'font-family: "Georgia", "Times New Roman", "Noto Serif SC", serif;'; // Added Noto Serif SC
            case 'sans': return 'font-family: "Helvetica", "Arial", "Noto Sans SC", sans-serif;'; // Added Noto Sans SC
            case 'mono': return 'font-family: "Courier New", "Menlo", "Noto Sans Mono SC", monospace;'; // Added Noto Sans Mono SC
            default: return 'font-family: "Noto Serif SC", "Songti SC", "SimSun", serif;'; // Default to a common Chinese serif
        }
    }
    
    function escapeXML(text) {
        if (typeof text !== 'string') return '';
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    }
    
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
});
 </script>
</body>
</html>
