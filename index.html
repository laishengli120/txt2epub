<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TXT to EPUB Converter - Memphis Style</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jschardet/3.0.0/jschardet.min.js"></script>
    <style>
        /* --- Memphis Design Style --- */

        :root {
            /* Memphis Color Palette */
            --memphis-bg: #f8f4f0; /* Light background */
            --memphis-primary: #ff6b6b; /* Bright Red/Pink */
            --memphis-secondary: #feca57; /* Yellow */
            --memphis-accent1: #48dbfb; /* Light Blue */
            --memphis-accent2: #1dd1a1; /* Mint Green */
            --memphis-dark: #1e1e1e; /* Black/Dark Gray */
            --memphis-white: #ffffff;
            
            /* Other Variables */
            --sidebar-width: 280px;
            --icons-width: 55px;
            --header-height: 65px;
            --border-radius: 6px; /* Slightly less rounded for Memphis */
            --bold-border: 3px solid var(--memphis-dark);
            --graphic-shadow: 5px 5px 0px var(--memphis-dark); /* Hard shadow */
            --transition: all 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Bouncy transition */

            /* Font */
            --font-family: 'Poppins', sans-serif;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: var(--font-family);
        }
        
        body {
            background-color: var(--memphis-bg);
            color: var(--memphis-dark);
            line-height: 1.6;
            overflow-x: hidden;
             /* Optional: Add a subtle Memphis background pattern */
            /* background-image: url('data:image/svg+xml,...'); */
        }
        
        .app-container {
            display: flex;
            min-height: 100vh;
            position: relative;
        }

        /* --- Header --- */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background-color: var(--memphis-secondary); /* Yellow background */
            border-bottom: var(--bold-border);
            display: flex;
            align-items: center;
            padding: 0 25px;
            z-index: 100;
            box-shadow: var(--graphic-shadow);
        }
        
        .header h1 {
            color: var(--memphis-dark);
            font-size: 1.4rem; /* Slightly larger */
            font-weight: 700; /* Bolder */
            margin: 0;
            flex: 1;
            text-transform: uppercase; /* Uppercase title */
            letter-spacing: 1px;
        }
        
        .header-actions button {
            margin-left: 10px;
            display: none; /* Keep hidden unless in mobile */
             /* Style button later */
        }

        /* --- Sidebar --- */
        .sidebar {
            position: fixed; /* Changed to fixed for consistency */
            display: flex;
            height: calc(100vh - var(--header-height));
            top: var(--header-height);
            left: 0;
            z-index: 90;
            transition: transform 0.3s ease-out; /* Slide transition */
            transform: translateX(0); /* Default state */
        }

        /* Icons Column */
        .sidebar-icons {
            width: var(--icons-width);
            height: 100%;
            background-color: var(--memphis-primary); /* Red/Pink background */
            border-right: var(--bold-border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            z-index: 91;
        }

        .sidebar-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%; /* Circular icons */
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            color: var(--memphis-dark);
            background-color: var(--memphis-white);
            border: 2px solid var(--memphis-dark);
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 3px 3px 0px rgba(0,0,0,0.2);
        }

        .sidebar-icon:hover {
            background-color: var(--memphis-secondary); /* Yellow hover */
            transform: translateY(-2px) rotate(5deg);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.3);
        }

        .sidebar-icon.active {
            background-color: var(--memphis-accent2); /* Mint green active */
            color: var(--memphis-white);
            transform: scale(1.1);
            box-shadow: none;
        }
        .sidebar-icon i {
            font-size: 18px; /* Adjust icon size */
        }

        /* Content Panel */
        .sidebar-content {
            width: calc(var(--sidebar-width) - var(--icons-width));
            height: 100%;
            background-color: var(--memphis-white);
            border-right: var(--bold-border);
            overflow-y: auto; /* Changed from hidden */
            transition: width 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
            box-shadow: inset -3px 0px 0px rgba(0,0,0,0.1); /* Inner shadow */
        }

        /* Collapsed state for sidebar content */
        .sidebar-content:not(.expanded) {
             width: 0;
             opacity: 0;
             overflow: hidden; /* Hide content when collapsed */
             border-right: none; /* Hide border when collapsed */
        }
        
        .sidebar-content.expanded {
            width: calc(var(--sidebar-width) - var(--icons-width));
            opacity: 1;
        }

        /* Settings Sections */
        .settings-section {
            display: none;
            padding: 25px;
            height: 100%;
        }

        .settings-section.active {
            display: block;
        }

        .settings-header {
            margin-bottom: 25px;
            border-bottom: 2px dashed var(--memphis-dark); /* Dashed border */
            padding-bottom: 15px;
            position: relative;
        }
        .settings-body {
            padding-bottom: 60px; /* Space for the decorative element */
        }
        /* Add a decorative element */
        .settings-header::after {
            content: '';
            position: absolute;
            bottom: -10px; /* Position below the border */
            left: 0;
            width: 20px;
            height: 20px;
            background-color: var(--memphis-primary);
            border: var(--bold-border);
            border-radius: 50%;
        }


        .settings-header h3 {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--memphis-primary); /* Red/Pink title */
            margin: 0;
            display: flex;
            align-items: center;
        }

        .settings-header h3 i {
            margin-right: 10px;
            color: var(--memphis-dark);
        }

        /* --- Main Content --- */
        .main-content {
            flex: 1;
            margin-top: var(--header-height);
            padding: 30px;
            transition: margin-left 0.3s ease-out; /* Adjust margin on sidebar toggle */
            /* Default margin-left is now managed by JS and media queries */
        }


        /* --- Content Cards --- */
        .content-card {
            background-color: var(--memphis-white);
            border-radius: var(--border-radius);
            border: var(--bold-border);
            box-shadow: var(--graphic-shadow);
            padding: 25px;
            margin-bottom: 30px; /* Add space between cards */
            position: relative; /* For potential decorative elements */
        }
        /* Add a decorative shape to cards */
         .content-card::before {
            content: '';
            position: absolute;
            top: -10px;
            right: -10px;
            width: 30px;
            height: 30px;
            background-color: var(--memphis-accent1); /* Light blue shape */
            border: var(--bold-border);
            transform: rotate(45deg);
            z-index: -1; /* Behind the card */
        }


        /* --- Form Elements --- */
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--memphis-dark);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-control {
            width: 100%;
            padding: 10px 15px;
            border: var(--bold-border);
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: var(--transition);
            background-color: var(--memphis-bg); /* Light background inside */
        }
        
        .form-control:focus {
            border-color: var(--memphis-primary); /* Red/Pink focus border */
            outline: none;
            box-shadow: 0 0 0 3px var(--memphis-accent1); /* Light blue focus ring */
            background-color: var(--memphis-white);
        }
        
        select.form-control {
             appearance: none; /* Remove default arrow */
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%231e1e1e'%3E%3Cpath fill-rule='evenodd' d='M8 11.5a.5.5 0 0 1-.354-.146l-4-4a.5.5 0 0 1 .708-.708L8 10.293l3.646-3.647a.5.5 0 0 1 .708.708l-4 4A.5.5 0 0 1 8 11.5z'/%3E%3C/svg%3E"); /* Custom arrow */
             background-repeat: no-repeat;
             background-position: right 15px center;
             background-size: 16px 16px;
             padding-right: 40px; /* Space for arrow */
        }

        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px; /* Space between options */
            margin-bottom: 8px;
        }
        
        .radio-option {
            margin-right: 0; /* Use gap instead */
            margin-bottom: 0;
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .radio-option input[type="radio"] {
            appearance: none; /* Hide default radio */
            width: 20px;
            height: 20px;
            border: var(--bold-border);
            border-radius: 50%;
            margin-right: 8px;
            position: relative;
            top: -1px;
            transition: background-color 0.2s ease;
        }
        .radio-option input[type="radio"]:checked {
            background-color: var(--memphis-dark); /* Fill when checked */
        }
         .radio-option input[type="radio"]:checked::after { /* Inner dot */
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            width: 6px;
            height: 6px;
            background-color: var(--memphis-white);
            border-radius: 50%;
        }

        .radio-option label {
            font-weight: 400; /* Normal weight for radio labels */
            text-transform: none;
            letter-spacing: 0;
            margin-bottom: 0; /* Remove bottom margin */
        }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            padding: 12px 25px;
            background-color: var(--memphis-primary); /* Red/Pink */
            color: var(--memphis-white);
            border: var(--bold-border);
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 700; /* Bold */
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            text-align: center;
            box-shadow: var(--graphic-shadow);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn:hover {
            background-color: var(--memphis-accent2); /* Mint green hover */
            color: var(--memphis-dark);
            transform: translateY(-3px) translateX(-3px);
            box-shadow: 8px 8px 0px var(--memphis-dark); /* Increase shadow on hover */
        }
        
        .btn:active {
            transform: translateY(0) translateX(0);
            box-shadow: var(--graphic-shadow); /* Reset shadow on active */
        }
        
        .btn-secondary { background-color: var(--memphis-secondary); color: var(--memphis-dark); }
        .btn-secondary:hover { background-color: var(--memphis-accent1); }
        
        .btn-success { background-color: var(--memphis-accent2); color: var(--memphis-dark); }
        .btn-success:hover { background-color: var(--memphis-primary); color: var(--memphis-white); }
        
        .btn-outline {
            background-color: transparent;
            border: var(--bold-border);
            color: var(--memphis-dark);
            box-shadow: none; /* No shadow for outline */
        }
        
        .btn-outline:hover {
            background-color: var(--memphis-dark);
            color: var(--memphis-white);
            transform: none; /* No move on hover */
            box-shadow: none;
        }
        
        .btn-sm { padding: 8px 15px; font-size: 0.9rem; }
        .btn-block { display: block; width: 100%; }
        
        .btn-disabled, /* General disabled */
        .convert-btn:disabled { /* Specific for convert button */
            background: var(--mid-gray) !important; 
            color: var(--light-text) !important;
            border-color: var(--dark-gray) !important;
            cursor: not-allowed !important;
            opacity: 0.8 !important;
            box-shadow: none !important;
            transform: none !important;
        }
        
        .btn-disabled:hover,
        .convert-btn:disabled:hover { 
             background: var(--mid-gray) !important; 
             box-shadow: none !important;
             transform: none !important;
        }

        /* --- Drop Area --- */
        .drop-area {
            border: 3px dashed var(--memphis-dark); /* Thicker dashed border */
            border-radius: var(--border-radius);
            padding: 60px 30px; /* More padding */
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
            position: relative;
            background-color: var(--memphis-accent1); /* Light blue background */
            color: var(--memphis-dark);
            overflow: hidden; /* For patterns */
        }
         /* Add a pattern to drop area */
        .drop-area::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                radial-gradient(var(--memphis-secondary) 2px, transparent 2px), /* Yellow dots */
                radial-gradient(var(--memphis-secondary) 2px, transparent 2px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            opacity: 0.3;
            z-index: 0;
        }


        .drop-area:hover {
            border-color: var(--memphis-primary);
            background-color: var(--memphis-accent2); /* Mint green hover */
            transform: scale(1.02); /* Slight scale on hover */
        }
        
        .drop-area.active {
            border-color: var(--memphis-primary);
            border-style: solid; /* Solid border when active */
            background-color: var(--memphis-accent2);
        }
        
        .drop-area h3, .drop-area p, .drop-area .btn {
            position: relative; /* Ensure text/button is above pattern */
            z-index: 1;
        }

        .drop-area h3 {
            margin-bottom: 15px;
            font-weight: 700;
            font-size: 1.3rem;
        }
        
        .drop-area p {
            color: var(--memphis-dark);
            margin-bottom: 25px;
            font-size: 1rem;
        }
        
        .drop-area input { /* Keep hidden input */
            position: absolute; width: 100%; height: 100%; top: 0; left: 0; opacity: 0; cursor: pointer; z-index: 10;
        }
        .file-format-badge { /* Style the badge */
             background-color: var(--memphis-secondary);
             color: var(--memphis-dark);
             padding: 3px 12px;
             border-radius: 4px;
             font-weight: 600;
             margin: 0 5px;
             border: 2px solid var(--memphis-dark);
        }

        /* --- File Info & Convert Button Area --- */
         #fileInfo {
            margin-top: 25px;
         }
        .filbt {
            margin: 25px 0 18px;
            display: flex;
            background-color: var(--memphis-accent2); /* Mint green background */
            border: var(--bold-border);
            border-radius: var(--border-radius);
            box-shadow: var(--graphic-shadow);
            overflow: hidden; /* Ensure children fit */
        }
        .file-preview {
            display: none; /* Keep initial state */
            align-items: center;
            padding: 15px;
            background-color: transparent; /* Use parent background */
            flex: 1;
            border-radius: 0; /* Remove individual radius */
        }
        
        .file-preview i {
            font-size: 28px;
            margin-right: 15px;
            color: var(--memphis-dark);
        }
        
        .file-details { flex: 1; }
        .file-details h4 { font-weight: 600; font-size: 1rem; color: var(--memphis-dark); }
        
        #removeTxtBtn { /* Style remove button */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px; height: 30px; /* Make it square */
            cursor: pointer;
            border-radius: 50%; /* Circle */
            border: 2px solid var(--memphis-dark);
            margin-right: 0; /* Remove margin */
            margin-left: 15px; /* Add left margin */
            background-color: var(--memphis-primary); /* Red/Pink */
            color: var(--memphis-white);
            transition: var(--transition);
        }
        #removeTxtBtn:hover {
            background-color: var(--memphis-dark);
            transform: rotate(90deg);
        }
        #removeTxtBtn i { font-size: 16px; margin: 0; }

        /* Convert Button Specific Style */
        .convert-btn {
            padding: 15px 35px; /* More padding */
            background: var(--memphis-primary); /* Red/Pink */
            color: var(--memphis-white);
            border: none; /* Remove default border */
            border-left: var(--bold-border); /* Add left border */
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: none; /* Remove individual shadow */
            min-width: auto; /* Remove min-width */
            margin: 0; /* Remove margin */
            border-radius: 0; /* Remove individual radius */
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .convert-btn:hover {
             background: var(--memphis-secondary); /* Yellow hover */
             color: var(--memphis-dark);
             transform: skewX(-10deg); /* Skew effect */
        }
         .convert-btn:active {
             transform: skewX(0deg);
         }

        /* --- Configuration Summary --- */
        .config-summary {
            border: var(--bold-border);
            border-left: 8px solid var(--memphis-primary); /* Thicker left border */
            padding: 20px;
            margin: 25px 0;
            font-size: 0.9rem;
            background-color: var(--memphis-bg); /* Light background */
            border-radius: var(--border-radius);
        }
        .summary-container { display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        .summary-text { flex: 1; }
        .config-summary h4 {
            margin-bottom: 15px;
            color: var(--memphis-primary); /* Red/Pink */
            font-weight: 700;
            text-transform: uppercase;
        }
        .config-summary p { margin: 6px 0; color: var(--memphis-dark); }
        .config-summary p strong { font-weight: 600; }
        
        .summary-cover { /* Cover preview in summary */
            width: 100px; /* Smaller */
            height: 150px;
            border: var(--bold-border);
            display: flex; justify-content: center; align-items: center;
            background-color: var(--memphis-accent1); /* Light blue background */
            border-radius: 4px;
            overflow: hidden;
            box-shadow: var(--graphic-shadow);
            position: relative; /* For the change cover button */
        }
        .summary-cover:hover .change-cover-btn {
            opacity: 1;
        }
        .change-cover-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0,0,0,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
            line-height: 30px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }
         .change-cover-btn:hover {
            background-color: rgba(0,0,0,0.8);
         }

        .summary-cover img { max-width: 100%; max-height: 100%; object-fit: cover; display: none; } /* Hide initially */
        #summaryCoverPlaceholder { color: var(--memphis-dark); font-size: 0.8rem; text-align: center; padding: 10px; font-weight: 600; }
        .summary-cover img[src]:not([src=""]):not([src*="placehold.co"]) { display: block; } /* Show if src is valid */
        .summary-cover img[src]:not([src=""]):not([src*="placehold.co"]) + #summaryCoverPlaceholder { display: none; } /* Hide placeholder if image shown */
        .summary-cover img[src*="placehold.co"] + #summaryCoverPlaceholder { display: block; } /* Show placeholder if placeholder image */


        /* --- Progress & Result Areas --- */
        .progress-area, .result-area {
            /* Use .content-card styling */
            text-align: center;
        }
        .loading-spinner { /* Style spinner */
            width: 50px; height: 50px;
            border: 5px dotted var(--memphis-dark); /* Dotted border */
            border-radius: 50%;
            border-top-color: transparent; /* Make one part transparent */
            animation: spin 1.5s linear infinite;
            margin-bottom: 20px;
        }
        .progress-area h3, .result-area h3 {
            font-size: 1.4rem; font-weight: 700; margin-bottom: 10px; color: var(--memphis-primary);
        }
        .progress-area p, .result-area p {
            font-size: 1rem; margin-bottom: 20px; color: var(--memphis-dark);
        }
        .progress-bar-container {
            height: 15px; /* Thicker bar */
            background-color: var(--memphis-accent1); /* Light blue background */
            border-radius: var(--border-radius);
            border: 2px solid var(--memphis-dark);
            margin: 25px 0;
            overflow: hidden;
            padding: 2px; /* Padding inside border */
        }
        .progress-bar {
            height: 100%;
            background-color: var(--memphis-primary); /* Red/Pink progress */
            width: 0%;
            transition: width 0.4s ease-out;
            border-radius: 3px; /* Slightly rounded inner bar */
        }
        
        .result-icon { color: var(--memphis-accent2); font-size: 60px; margin-bottom: 20px; }
        .result-card { /* Inner card for result details */
            background-color: var(--memphis-secondary); /* Yellow background */
            border-radius: var(--border-radius);
            border: var(--bold-border);
            padding: 20px;
            margin-top: 25px;
        }
         .result-card h4 { font-size: 1.1rem; font-weight: 600; margin-bottom: 5px; color: var(--memphis-dark); }
         .result-card p { font-size: 0.9rem; margin-bottom: 20px; color: var(--memphis-dark); }
        
        .result-actions { margin-top: 20px; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
        .result-actions .btn { min-width: 160px; }
        .result-actions .btn i { margin-right: 10px; }
        
        /* --- Debug Area --- */
        .debug-area {
             margin-top: 30px; padding: 20px; background-color: var(--memphis-dark); border-radius: var(--border-radius); display: none; border: 3px dashed var(--memphis-secondary); /* Yellow dashed border */
        }
        .debug-area h3 { margin-bottom: 15px; color: var(--memphis-secondary); font-size: 1rem; font-weight: 600; text-transform: uppercase; }
        .debug-log { height: 250px; overflow-y: auto; background-color: #2a2a2a; color: #f0f0f0; padding: 15px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.85rem; line-height: 1.5; border: 2px solid var(--memphis-secondary); }
        .debug-log div { margin-bottom: 5px; border-bottom: 1px dotted #555; padding-bottom: 5px; word-break: break-all; }
        .debug-log div:last-child { border-bottom: none; }

        /* Cover Preview in Sidebar */
        .cover-preview-container {
            text-align: center;
            margin-top: 15px;
            position: relative; /* For navigation buttons */
        }
        .cover-preview {
            max-width: 100%;
            max-height: 200px;
            display: none;
            margin: 0 auto;
            border: var(--bold-border);
            border-radius: var(--border-radius);
            box-shadow: var(--graphic-shadow);
        }
        .cover-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        .cover-nav-btn {
            background-color: var(--memphis-secondary);
            color: var(--memphis-dark);
            border: var(--bold-border);
            border-radius: var(--border-radius);
            padding: 5px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--memphis-dark);
            transition: var(--transition);
        }
        .cover-nav-btn:hover {
            background-color: var(--memphis-accent1);
            transform: translateY(-1px) translateX(-1px);
            box-shadow: 3px 3px 0px var(--memphis-dark);
        }
        .cover-nav-btn:disabled {
            background-color: #ccc;
            color: #777;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #aaa;
        }
        #coverIndicator {
            font-size: 0.9rem;
            color: var(--memphis-dark);
            font-weight: 600;
        }

        /* --- Custom Alert Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(30, 30, 30, 0.7); /* 暗色半透明背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* 确保在最上层 */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55), visibility 0s linear 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        .modal-content.memphis-modal {
            background-color: var(--memphis-white);
            padding: 30px; /* 增加内边距 */
            border-radius: var(--border-radius);
            border: var(--bold-border);
            box-shadow: var(--graphic-shadow);
            width: 90%;
            max-width: 480px; /* 合适的最大宽度 */
            text-align: left;
            transform: translateY(-30px) scale(0.95); /* 出现时有点动态效果 */
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        .modal-overlay.visible .modal-content.memphis-modal {
            transform: translateY(0) scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 15px;
            margin-bottom: 20px;
            border-bottom: 3px dotted var(--memphis-dark); /* 孟菲斯风格虚线 */
            position: relative;
        }
        /* 标题装饰元素 */
        .modal-header::before {
            content: '';
            position: absolute;
            left: -15px; /* 根据内边距调整 */
            top: 50%;
            transform: translateY(-50%);
            width: 15px;
            height: 15px;
            background-color: var(--memphis-secondary); /* 黄色装饰 */
            border: var(--bold-border);
            border-radius: 0; /* 方形 */
        }


        .modal-title-text {
            font-size: 1.3rem; /* 稍大标题 */
            font-weight: 700;
            color: var(--memphis-dark); /* 默认深色标题 */
            margin: 0;
            text-transform: uppercase; /* 大写标题 */
        }

        .modal-close-btn {
            background: transparent;
            border: var(--bold-border);
            color: var(--memphis-dark);
            font-size: 1.5rem; /* 更清晰的关闭按钮 */
            font-weight: 700;
            cursor: pointer;
            line-height: 1;
            padding: 2px 8px;
            border-radius: var(--border-radius);
            transition: var(--transition);
            box-shadow: 3px 3px 0px var(--memphis-dark);
        }
        .modal-close-btn:hover {
            background-color: var(--memphis-primary);
            color: var(--memphis-white);
            transform: translateY(-2px) translateX(-2px);
            box-shadow: 5px 5px 0px var(--memphis-dark);
        }
        .modal-close-btn:active {
            transform: translateY(0) translateX(0);
            box-shadow: 3px 3px 0px var(--memphis-dark);
        }

        .modal-body {
            margin-bottom: 25px;
            font-size: 1rem;
            color: var(--memphis-dark);
            line-height: 1.7; /* 增加行高可读性 */
        }
        .modal-body p {
            text-indent: 0; /* 模态框内段落通常不缩进 */
            margin: 0;
        }

        .modal-footer {
            text-align: right;
        }
        .modal-footer .btn { /* 确保按钮样式应用 */
            min-width: 100px;
        }


        /* 不同类型的模态框 (通过JS添加class来改变颜色) */
        .memphis-modal.modal-error .modal-header::before { background-color: var(--memphis-primary); }
        .memphis-modal.modal-error .modal-title-text { color: var(--memphis-primary); }
        /* .memphis-modal.modal-error { border-color: var(--memphis-primary); } */ /* 可选：改变整个边框颜色 */

        .memphis-modal.modal-warning .modal-header::before { background-color: var(--memphis-secondary); }
        .memphis-modal.modal-warning .modal-title-text { color: var(--memphis-secondary); }
        /* .memphis-modal.modal-warning { border-color: var(--memphis-secondary); } */

        .memphis-modal.modal-info .modal-header::before { background-color: var(--memphis-accent1); }
        .memphis-modal.modal-info .modal-title-text { color: var(--memphis-accent1); }
        /* .memphis-modal.modal-info { border-color: var(--memphis-accent1); } */

        .memphis-modal.modal-success .modal-header::before { background-color: var(--memphis-accent2); }
        .memphis-modal.modal-success .modal-title-text { color: var(--memphis-accent2); }
        /* .memphis-modal.modal-success { border-color: var(--memphis-accent2); } */


        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) {
             /* Mobile view - sidebar slides out */
            .sidebar {
                 transform: translateX(calc(-1 * var(--sidebar-width))); /* Hide initially */
            }
            .sidebar.sidebar-visible {
                 transform: translateX(0); /* Show */
                 box-shadow: 5px 0 15px rgba(0,0,0,0.2); /* Add shadow when overlaying */
            }
            /* MODIFIED: Main content margin for mobile */
            .main-content {
                 margin-left: 0; /* Default for mobile, JS will adjust if sidebar is visible */
            }
             /* This class is not strictly needed for margin adjustment on mobile with the new JS logic */
             /* .main-content.sidebar-expanded {  
                 margin-left: var(--icons-width); 
             } */

            .header-actions button {
                 display: inline-block; /* Show toggle button */
                 padding: 8px 12px;
                 font-size: 0.9rem;
                 background-color: var(--memphis-primary);
                 color: var(--memphis-white);
                 border: 2px solid var(--memphis-dark);
                 box-shadow: 3px 3px 0 var(--memphis-dark);
            }
             .header-actions button:hover {
                 background-color: var(--memphis-accent2);
                 color: var(--memphis-dark);
             }
        }
        
        @media (max-width: 768px) {
             /* Adjust padding/margins for smaller screens */
             .header { padding: 0 15px; }
             .main-content { padding: 20px; } /* Padding within main-content remains */
             .content-card { padding: 20px; }
             .content-card::before { display: none; } /* Hide decorative shape on small screens */
             .drop-area { padding: 40px 20px; }
             .filbt { flex-direction: column; background: none; border: none; box-shadow: none; } /* Stack file preview and button */
             .file-preview { border-radius: var(--border-radius); border: var(--bold-border); background-color: var(--memphis-accent2); box-shadow: var(--graphic-shadow); margin-bottom: 15px; }
             .convert-btn { width: 100%; border-radius: var(--border-radius); border: var(--bold-border); box-shadow: var(--graphic-shadow); border-left: var(--bold-border); /* Keep border consistent */ }
             .convert-btn:hover { transform: translateY(-3px) translateX(-3px) skewX(0); box-shadow: 8px 8px 0px var(--memphis-dark);  } /* Use standard hover */
             .summary-container { flex-direction: row; align-items: center;} /* Changed to column for better spacing */
             .summary-text { width: 100%; margin-bottom: 15px; }
             .summary-cover { margin-top: 0; }
        }
        
        @media (max-width: 576px) {
            :root {
                --sidebar-width: 250px; /* Slightly smaller sidebar */
                --icons-width: 50px;
                --header-height: 60px;
            }
            .header h1 { font-size: 1.1rem; }
            .main-content { padding: 15px; } /* Padding within main-content remains */
            .btn { padding: 10px 20px; font-size: 0.9rem; }
            .result-actions { gap: 10px; }
            .result-actions .btn { width: 100%; min-width: auto; }
        }

        /* Animation for spinner */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>TXT to EPUB Factory</h1>
            <div class="header-actions">
                <button id="toggleSidebarBtn" class="btn btn-sm">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-icons" id="sidebarIcons">
                <div class="sidebar-icon active" data-section="bookInfoSection"> <i class="fas fa-book"></i>
                </div>
                <div class="sidebar-icon" data-section="chapterSection">
                    <i class="fas fa-wrench"></i>
                </div>
                <div class="sidebar-icon" data-section="debugSection">
                    <i class="fas fa-bug"></i>
                </div>
            </div>
            
            <div class="sidebar-content expanded" id="sidebarContent">
                <div class="settings-section active" id="bookInfoSection">
                    <div class="settings-header">
                        <h3><i class="fas fa-info-circle"></i>书籍信息</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="bookTitle">书名</label>
                            <input type="text" id="bookTitle" class="form-control" placeholder="例如：仙逆">
                        </div>
                        <div class="form-group">
                            <label for="bookAuthor">作者</label>
                            <input type="text" id="bookAuthor" class="form-control" placeholder="例如：耳根">
                        </div>
                        <div class="form-group">
                            <label for="bookLanguage">语言</label>
                            <select id="bookLanguage" class="form-control">
                                <option value="zh-CN">中文（简体）</option>
                                <option value="zh-TW">中文（繁体）</option>
                                <option value="en">English</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>封面来源</label>
                            <div class="radio-group">
                                <div class="radio-option">
                                    <input type="radio" id="coverSearch" name="coverOption" value="search" checked>
                                    <label for="coverSearch">在线搜索</label> </div>
                                <div class="radio-option">
                                    <input type="radio" id="coverUpload" name="coverOption" value="upload">
                                    <label for="coverUpload">本地上传</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" id="coverNone" name="coverOption" value="none">
                                    <label for="coverNone">无封面</label>
                                </div>
                            </div>
                        </div>
                        
                        <div id="onlineSourceSelectionArea" class="form-group" style="display: none; margin-left: 20px;">
                            <label for="onlineSourceSelect">选择在线来源:</label>
                            <select id="onlineSourceSelect" class="form-control">
                                <option value="qidian" selected>起点小说 (小说类推荐)</option>
                                <option value="openlibrary">Open Library (综合/外文)</option>
                                <option value="googlebooks">Google Books (综合/需API Key)</option>
                                </select>
                        </div>
                        
                        <div id="coverUploadArea" style="display: none;">
                            <div class="form-group">
                                <button class="btn btn-secondary btn-sm btn-block" id="selectCoverBtn"> <i class="fas fa-upload"></i> 选择封面图片
                                </button>
                                <input type="file" id="coverInput" accept="image/*" hidden>
                                <p id="coverFileName" style="margin-top: 10px; display: none; font-size: 0.9rem; text-align: center;"></p>
                            </div>
                        </div>
                        
                        <div class="cover-preview-container" id="coverPreviewArea">
                            <img id="coverPreview" class="cover-preview" src="" alt="封面预览">
                            <div class="cover-navigation" id="coverNavigationControls" style="display: none;">
                                <button id="prevCoverBtn" class="cover-nav-btn"><i class="fas fa-chevron-left"></i></button>
                                <span id="coverIndicator">1 / 1</span>
                                <button id="nextCoverBtn" class="cover-nav-btn"><i class="fas fa-chevron-right"></i></button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="chapterSection">
                    <div class="settings-header">
                        <h3><i class="fas fa-cut"></i>内容与样式</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="chapterPattern">章节模式</label>
                            <select id="chapterPattern" class="form-control">
                                <option value="auto">自动识别</option>
                                <option value="chinese">中文 (第X章)</option>
                                <option value="english">英文 (Chapter X)</option>
                                <option value="numbered">数字 (1., 2.)</option>
                                <option value="custom">自定义正则</option>
                            </select>
                        </div>
                        <div id="customChapterArea" style="display: none;">
                            <div class="form-group">
                                <label for="customChapterPattern">自定义章节正则</label>
                                <input type="text" id="customChapterPattern" class="form-control" placeholder="^第[0-9一二三四五六七八九十零〇百千两 ]+[章]">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="volumePattern">卷/部模式</label>
                            <select id="volumePattern" class="form-control">
                                <option value="auto">自动识别</option>
                                <option value="chinese">中文 (第X卷/部)</option>
                                <option value="english">英文 (Volume/Book X)</option>
                                <option value="disabled">不识别</option>
                                <option value="custom">自定义正则</option>
                            </select>
                        </div>
                        <div id="customVolumeArea" style="display: none;">
                            <div class="form-group">
                                <label for="customVolumePattern">自定义卷/部正则</label>
                                <input type="text" id="customVolumePattern" class="form-control" placeholder="^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部]">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="indent">段落首行缩进 (em)</label>
                            <input type="number" id="indent" class="form-control" min="0" max="8" step="0.1" value="2">
                        </div>
                        <div class="form-group">
                            <label for="titleAlign">标题对齐</label>
                            <select id="titleAlign" class="form-control">
                                <option value="center">居中</option>
                                <option value="left">左对齐</option>
                                <option value="right">右对齐</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="paragraphSpacing">段间距</label>
                            <select id="paragraphSpacing" class="form-control">
                                <option value="1em">默认 (1em)</option>
                                <option value="0.5em">紧凑 (0.5em)</option>
                                <option value="1.5em">宽松 (1.5em)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="debugSection">
                    <div class="settings-header">
                        <h3><i class="fas fa-cog"></i>调试选项</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="debugMode">开启调试日志</label>
                            <select id="debugMode" class="form-control">
                                <option value="off">关闭</option>
                                <option value="on">开启</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="googleBooksApiKeyInput">Google Books API Key (可选)</label>
                            <input type="text" id="googleBooksApiKeyInput" class="form-control" placeholder="输入您的Google Books API Key">
                            <p style="font-size: 0.8rem; color: var(--memphis-dark); margin-top: 8px; line-height: 1.4;">
                                此API Key用于从 Google Books 获取封面。您可以在
                                <a href="https://console.cloud.google.com/apis/dashboard" target="_blank" rel="noopener noreferrer" style="color: var(--memphis-primary); text-decoration: underline;">Google Cloud Console</a>
                                创建和管理您的API Key。如果留空，Google Books封面搜索将不可用。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content" id="mainContent">
            <div class="content-card upload-area" id="uploadCard">
                <div class="drop-area" id="dropArea">
                    <h3>拖放或选择 <span class="file-format-badge">TXT</span> 文件</h3>
                    <p>将你的小说文本文件扔到这里来！</p>
                    <button class="btn btn-secondary" id="selectFileBtn"><i class="fas fa-folder-open"></i> 选择文件</button>
                    <input type="file" id="fileInput" accept=".txt" hidden>
                </div>

                <div id="fileInfo" style="display: none;">
                     <div class="config-summary" id="configSummary">
                        <div class="summary-container">
                            <div class="summary-text">
                                <h4>转换预览</h4>
                                <div id="configDetails">
                                    <p><strong>标题:</strong> <span id="summaryTitle">未设置</span></p>
                                    <p><strong>作者:</strong> <span id="summaryAuthor">未设置</span></p>
                                    <p><strong>封面:</strong> <span id="summaryCoverSourceText">起点网</span></p>
                                    <p><strong>大小:</strong> <span id="txtFileSize">N/A</span></p>
                                    <p><strong>编码:</strong> <span id="txtEncoding">检测中...</span></p>
                                </div>
                            </div>
                            <div class="summary-cover" id="summaryCoverContainer">
                                <img id="summaryCoverPreview" src="" alt="封面预览">
                                <div id="summaryCoverPlaceholder">等待封面...</div>
                                <button class="change-cover-btn" id="changeCoverInSummaryBtn" title="更换封面">
                                    <i class="fas fa-pen"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="filbt">
                        <div class="file-preview" id="txtPreview">
                            <i class="fas fa-file-alt"></i>
                            <div class="file-details">
                                <h4 id="txtFileName">filename.txt</h4>
                            </div>
                            <span id="removeTxtBtn" title="移除文件"><i class="fas fa-times"></i></span>
                        </div>
                        <button class="convert-btn" id="convertBtn">
                            <span class="convert-btn-text">开始转换!</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="content-card progress-area" id="progressCard" style="display: none;">
                <div class="loading-spinner"></div>
                <h3 id="progressTitle">正在施展魔法...</h3>
                <p id="progressStatus">请稍候，EPUB正在生成中！</p>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>

            <div class="content-card result-area" id="resultCard" style="display: none;">
                <i class="fas fa-check-circle result-icon"></i>
                <h3>转换成功!</h3>
                <p>你的EPUB文件已准备就绪！</p>
                
                <div class="result-card">
                    <h4 id="resultFileName"></h4>
                    <p id="resultFileSize"></p>
                    
                    <div class="result-actions">
                        <button class="btn btn-success" id="downloadBtn">
                            <i class="fas fa-download"></i> 下载EPUB
                        </button>
                        <button class="btn btn-outline" id="convertNewBtn">
                            <i class="fas fa-redo"></i> 再转一个
                        </button>
                    </div>
                </div>
            </div>

            <div class="debug-area" id="debugAreaDOM">
                <h3>调试日志</h3>
                <div class="debug-log" id="debugLog"></div>
            </div>
        </div>
    </div>
    <div id="customAlertModal" class="modal-overlay">
        <div class="modal-content memphis-modal">
            <div class="modal-header">
                <h4 id="customAlertTitle" class="modal-title-text">提示</h4>
                <button id="customAlertCloseBtn" class="modal-close-btn" title="关闭">&times;</button>
            </div>
            <div class="modal-body">
                <p id="customAlertMessage"></p>
            </div>
            <div class="modal-footer">
                <button id="customAlertOkBtn" class="btn btn-primary">确定</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const sidebar = document.getElementById('sidebar');
            const sidebarContent = document.getElementById('sidebarContent');
            const mainContent = document.getElementById('mainContent');
            const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
            const settingsSections = document.querySelectorAll('.settings-section');
            const sidebarIcons = document.querySelectorAll('.sidebar-icon');
            const dropArea = document.getElementById('dropArea');
            const fileInput = document.getElementById('fileInput');
            const selectFileBtn = document.getElementById('selectFileBtn');
            const fileInfo = document.getElementById('fileInfo');
            const txtPreview = document.getElementById('txtPreview');
            const txtFileName = document.getElementById('txtFileName');
            const txtFileSize = document.getElementById('txtFileSize');
            const txtEncoding = document.getElementById('txtEncoding');
            const removeTxtBtn = document.getElementById('removeTxtBtn');
            const bookTitle = document.getElementById('bookTitle');
            const bookAuthor = document.getElementById('bookAuthor');
            const bookLanguage = document.getElementById('bookLanguage');
            const chapterPattern = document.getElementById('chapterPattern');
            const volumePattern = document.getElementById('volumePattern');
            const customChapterArea = document.getElementById('customChapterArea');
            const customVolumeArea = document.getElementById('customVolumeArea');
            const customChapterPattern = document.getElementById('customChapterPattern');
            const customVolumePattern = document.getElementById('customVolumePattern');
            const coverUpload = document.getElementById('coverUpload');
            const coverSearch = document.getElementById('coverSearch');
            const coverNone = document.getElementById('coverNone');
            const onlineSourceSelectionArea = document.getElementById('onlineSourceSelectionArea');
            const onlineSourceSelect = document.getElementById('onlineSourceSelect');
            const coverUploadArea = document.getElementById('coverUploadArea');
            const coverPreviewArea = document.getElementById('coverPreviewArea');
            const coverPreview = document.getElementById('coverPreview');
            const selectCoverBtn = document.getElementById('selectCoverBtn');
            const coverInput = document.getElementById('coverInput');
            const coverFileName = document.getElementById('coverFileName');
            const summaryTitle = document.getElementById('summaryTitle');
            const summaryAuthor = document.getElementById('summaryAuthor');
            const summaryCoverSourceText = document.getElementById('summaryCoverSourceText');
            const summaryCoverPreview = document.getElementById('summaryCoverPreview');
            const summaryCoverPlaceholder = document.getElementById('summaryCoverPlaceholder');
            const changeCoverInSummaryBtn = document.getElementById('changeCoverInSummaryBtn');
            const coverNavigationControls = document.getElementById('coverNavigationControls');
            const prevCoverBtn = document.getElementById('prevCoverBtn');
            const nextCoverBtn = document.getElementById('nextCoverBtn');
            const coverIndicator = document.getElementById('coverIndicator');
            const indent = document.getElementById('indent');
            const titleAlign = document.getElementById('titleAlign');
            const paragraphSpacing = document.getElementById('paragraphSpacing');
            const debugAreaDOM = document.getElementById('debugAreaDOM');
            const debugLog = document.getElementById('debugLog');
            const debugMode = document.getElementById('debugMode');
            const uploadCard = document.getElementById('uploadCard');
            const progressCard = document.getElementById('progressCard');
            const resultCard = document.getElementById('resultCard');
            const convertBtn = document.getElementById('convertBtn');
            const progressTitle = document.getElementById('progressTitle');
            const progressStatus = document.getElementById('progressStatus');
            const progressBar = document.getElementById('progressBar');
            const resultFileName = document.getElementById('resultFileName');
            const resultFileSize = document.getElementById('resultFileSize');
            const downloadBtn = document.getElementById('downloadBtn');
            const convertNewBtn = document.getElementById('convertNewBtn');

            // 在获取其他 DOM 元素的地方添加：
            const googleBooksApiKeyInput = document.getElementById('googleBooksApiKeyInput');

            // State Variables
            let selectedFile = null;
            let coverFile = null;
            let coverDataUrl = null; 
            let epubBlob = null;
            let detectedEncoding = null;
            let fileArrayBuffer = null;
            let processedText = null;
            let isSearchingCover = false;
            let onlineCoverResults = [];
            let currentOnlineCoverIndex = 0;
            // 在脚本的全局作用域或主函数作用域顶部定义
            const USER_SETTINGS_KEY = 'epubConverterUserSettings_v1'; // v1用于未来可能的结构升级

            // 确保在能访问到所有相关DOM元素引用的作用域内定义此函数
            function saveUserSettings() {
                if (typeof(Storage) === "undefined") {
                    log("浏览器不支持 localStorage，无法保存用户设置。", "warning");
                    showCustomAlert("浏览器不支持 localStorage，无法保存用户设置。但不会影响使用！");
                    return;
                }

                const settings = {
                    chapterPattern: chapterPattern?.value,
                    customChapterPattern: customChapterPattern?.value, // 始终保存，加载时根据chapterPattern决定是否应用
                    volumePattern: volumePattern?.value,
                    customVolumePattern: customVolumePattern?.value,   // 始终保存

                    coverOption: document.querySelector('input[name="coverOption"]:checked')?.value,
                    onlineSource: typeof onlineSourceSelect !== 'undefined' ? onlineSourceSelect?.value : 'qidian', // 默认qidian

                    indent: indent?.value,
                    titleAlign: titleAlign?.value,
                    paragraphSpacing: paragraphSpacing?.value,

                    debugMode: debugMode?.value,
                    googleBooksApiKey: googleBooksApiKeyInput?.value // 仅在输入框存在时保存
                };

                try {
                    localStorage.setItem(USER_SETTINGS_KEY, JSON.stringify(settings));
                    log('用户偏好设置已保存。', 'info');
                } catch (e) {
                    log(`保存用户设置到 localStorage 失败: ${e.message}`, 'error');
                    // 可以考虑如果存储已满，提示用户
                }
            }

            function loadUserSettings() {
                if (typeof(Storage) === "undefined") {
                    log("浏览器不支持 localStorage，无法加载用户设置。", "warning");
                    return;
                }

                try {
                    const savedSettingsString = localStorage.getItem(USER_SETTINGS_KEY);
                    if (!savedSettingsString) {
                        log('未找到已保存的用户设置。', 'info');
                        // 可在此处设置应用的默认值，如果它们与HTML中的默认值不同
                        // 例如: chapterPattern.value = 'auto'; toggleCoverOptions(); ...
                        return;
                    }

                    const settings = JSON.parse(savedSettingsString);
                    if (!settings) {
                        log('解析已保存的用户设置失败。', 'warning');
                        return;
                    }

                    log('正在加载用户偏好设置...', 'info');

                    // 应用章节设置
                    if (settings.chapterPattern && chapterPattern) chapterPattern.value = settings.chapterPattern;
                    if (settings.customChapterPattern && customChapterPattern) customChapterPattern.value = settings.customChapterPattern;
                    if (settings.volumePattern && volumePattern) volumePattern.value = settings.volumePattern;
                    if (settings.customVolumePattern && customVolumePattern) customVolumePattern.value = settings.customVolumePattern;

                    // 应用封面设置
                    if (settings.coverOption) {
                        const coverRadioToSelect = document.querySelector(`input[name="coverOption"][value="${settings.coverOption}"]`);
                        if (coverRadioToSelect) coverRadioToSelect.checked = true;
                    }
                    if (settings.onlineSource && typeof onlineSourceSelect !== 'undefined' && onlineSourceSelect) {
                        onlineSourceSelect.value = settings.onlineSource;
                    }

                    // 应用外观设置
                    if (settings.indent && indent) indent.value = settings.indent;
                    if (settings.titleAlign && titleAlign) titleAlign.value = settings.titleAlign;
                    if (settings.paragraphSpacing && paragraphSpacing) paragraphSpacing.value = settings.paragraphSpacing;

                    // 应用调试设置
                    if (settings.debugMode && debugMode) debugMode.value = settings.debugMode;
                    if (settings.googleBooksApiKey && googleBooksApiKeyInput) googleBooksApiKeyInput.value = settings.googleBooksApiKey;

                    // !!! 重要：应用设置后，需要手动触发一次依赖这些设置的UI更新函数 !!!
                    // 因为直接修改 .value 不会触发 'change' 事件

                    // 更新自定义正则区域的显示状态
                    if (chapterPattern && customChapterArea) {
                        customChapterArea.style.display = chapterPattern.value === 'custom' ? 'block' : 'none';
                    }
                    if (volumePattern && customVolumeArea) {
                        customVolumeArea.style.display = volumePattern.value === 'custom' ? 'block' : 'none';
                    }

                    toggleCoverOptions(); // 更新封面选项相关的UI（包括在线来源选择区的显示）
                    updateDebugArea();    // 根据加载的debugMode更新调试区域显示
                    // updateSummary(); // 概要信息主要依赖书名/作者/文件，这些不保存，所以此处可能不需要，除非概要中有其他受这些设置影响的项

                    log('用户偏好设置已加载并应用。', 'info');

                } catch (e) {
                    log(`从 localStorage 加载用户设置失败: ${e.message}`, 'error');
                    // 可选：如果解析失败或数据损坏，清除损坏的设置
                    // localStorage.removeItem(USER_SETTINGS_KEY);
                }
            }

            // --- Custom Alert Modal Logic ---
            const customAlertModal = document.getElementById('customAlertModal');
            const customAlertTitle = document.getElementById('customAlertTitle');
            const customAlertMessage = document.getElementById('customAlertMessage');
            const customAlertCloseBtn = document.getElementById('customAlertCloseBtn');
            const customAlertOkBtn = document.getElementById('customAlertOkBtn');
            const modalContentElement = customAlertModal ? customAlertModal.querySelector('.modal-content') : null;

            let onCustomAlertCloseCallback = null; // 用于处理关闭后的回调

            /**
             * 显示自定义模态框提示
             * @param {string} message - 要显示的消息内容
             * @param {string} [title="提示"] - 模态框标题
             * @param {string} [type="info"] - 模态框类型 ('info', 'error', 'warning', 'success')
             * @param {function} [onClose] - 模态框关闭时的回调函数
             */
            function showCustomAlert(message, title = "提示", type = "info", onClose = null) {
                if (!customAlertModal || !modalContentElement) {
                    // 如果模态框DOM不存在，则回退到原生alert
                    console.warn("Custom alert modal DOM not found. Falling back to native alert.");
                    alert(`${title}: ${message}`);
                    if (typeof onClose === 'function') {
                        onClose();
                    }
                    return;
                }

                customAlertTitle.textContent = title;
                customAlertMessage.innerHTML = message; // 使用 innerHTML 以支持简单的HTML标签如 <br>

                // 重置类型相关的class
                modalContentElement.classList.remove('modal-error', 'modal-warning', 'modal-info', 'modal-success');

                // 根据类型应用样式和默认标题
                switch (type.toLowerCase()) {
                    case 'error':
                        modalContentElement.classList.add('modal-error');
                        customAlertTitle.textContent = title === "提示" ? "发生错误" : title;
                        break;
                    case 'warning':
                        modalContentElement.classList.add('modal-warning');
                        customAlertTitle.textContent = title === "提示" ? "警告" : title;
                        break;
                    case 'success':
                        modalContentElement.classList.add('modal-success');
                        customAlertTitle.textContent = title === "提示" ? "操作成功" : title;
                        break;
                    case 'info':
                    default:
                        modalContentElement.classList.add('modal-info');
                        // 保持传入的title或默认的“提示”
                        break;
                }

                onCustomAlertCloseCallback = onClose; // 保存回调

                customAlertModal.classList.add('visible');
                customAlertOkBtn.focus(); // 方便键盘操作
            }

            function hideCustomAlert() {
                if (!customAlertModal) return;
                customAlertModal.classList.remove('visible');
                if (typeof onCustomAlertCloseCallback === 'function') {
                    onCustomAlertCloseCallback(); // 执行回调
                    onCustomAlertCloseCallback = null; // 清理回调，防止重复执行
                }
            }

            // 为模态框的关闭按钮和确定按钮添加事件监听
            if (customAlertCloseBtn) {
                customAlertCloseBtn.addEventListener('click', hideCustomAlert);
            }
            if (customAlertOkBtn) {
                customAlertOkBtn.addEventListener('click', hideCustomAlert);
            }

            // 点击模态框外部（遮罩层）关闭模态框
            if (customAlertModal) {
                customAlertModal.addEventListener('click', (event) => {
                    if (event.target === customAlertModal) { // 确保是点击遮罩本身，而非内容区域
                        hideCustomAlert();
                    }
                });
            }

            // (可选) 按下 Escape 键关闭模态框
            document.addEventListener('keydown', (event) => {
                if (event.key === "Escape" && customAlertModal && customAlertModal.classList.contains('visible')) {
                    hideCustomAlert();
                }
            });


            // Initialize
            initializeApp();

            function initializeApp() {
                setupUIEventListeners();
                setupFileEventListeners();
                setupSettingsEventListeners();
                setupConversionEventListeners();
                updateDebugArea();
                toggleCoverOptions();
                activateSection('bookInfoSection', document.querySelector('.sidebar-icon[data-section="bookInfoSection"]'));
                updateMainContentMargin(); 
            }

            // --- UI Event Listeners ---
            function setupUIEventListeners() {
                sidebarIcons.forEach(icon => {
                    icon.addEventListener('click', function() {
                        const sectionId = this.getAttribute('data-section');
                        const isCurrentlyActive = this.classList.contains('active');
                        const isSidebarContentCurrentlyExpanded = sidebarContent.classList.contains('expanded');

                        if (isCurrentlyActive && isSidebarContentCurrentlyExpanded) {
                            sidebarContent.classList.remove('expanded');
                            if(sidebarIcons) sidebarIcons.forEach(icon => icon.classList.remove('active'));
                        } else if (!isSidebarContentCurrentlyExpanded) {
                            sidebarContent.classList.add('expanded');
                            activateSection(sectionId, this);
                        } else if (!isCurrentlyActive && isSidebarContentCurrentlyExpanded){
                            activateSection(sectionId, this);
                        }
                        updateMainContentMargin();
                    });
                });

                if (toggleSidebarBtn) {
                    toggleSidebarBtn.addEventListener('click', function() {
                        if (sidebar) sidebar.classList.toggle('sidebar-visible');
                        if(sidebar && sidebar.classList.contains('sidebar-visible') && sidebarContent) {
                            sidebarContent.classList.add('expanded');
                             // If opening sidebar on mobile, ensure the first tab is active if none are
                            if (!document.querySelector('.sidebar-icon.active')) {
                                activateSection('bookInfoSection', document.querySelector('.sidebar-icon[data-section="bookInfoSection"]'));
                            }
                        }
                        updateMainContentMargin();
                    });
                }
                
                document.addEventListener('click', function(event) {
                    if (window.innerWidth <= 992) { 
                        if (sidebar && sidebar.classList.contains('sidebar-visible') && 
                            !sidebar.contains(event.target) && 
                            toggleSidebarBtn && !toggleSidebarBtn.contains(event.target)) {
                            sidebar.classList.remove('sidebar-visible');
                            updateMainContentMargin(); 
                        }
                    }
                    // This logic for closing sidebar on desktop was a bit aggressive.
                    // Commenting out for now, as it might interfere with interactions within the main content.
                    // else if (window.innerWidth > 992 && sidebarContent && sidebarContent.classList.contains('expanded')) {
                    //     if (!uploadCard.contains(event.target) && sidebarContent.classList.contains('expanded') && !sidebar.contains(event.target) && !mainContent.contains(event.target)) {
                    //         sidebarContent.classList.remove('expanded');
                    //         if(sidebarIcons) sidebarIcons.forEach(icon => icon.classList.remove('active'));
                    //         updateMainContentMargin(); 
                    //     }
                    // }
                });

                window.addEventListener('resize', handleResize);
                handleResize(); 

                if (changeCoverInSummaryBtn) {
                    changeCoverInSummaryBtn.addEventListener('click', (event) => { // 传入 event 对象
                        event.stopPropagation(); // 阻止事件冒泡
                        activateSection('bookInfoSection', document.querySelector('.sidebar-icon[data-section="bookInfoSection"]'));
                        if (window.innerWidth <= 992 && sidebar && !sidebar.classList.contains('sidebar-visible')) {
                            sidebar.classList.add('sidebar-visible');
                        }
                        if (sidebarContent && !sidebarContent.classList.contains('expanded')) {
                            sidebarContent.classList.add('expanded');
                        }
                        updateMainContentMargin();
                    });
                }
            }

            function toggleCoverOptions() {
                const coverSearchChecked = coverSearch && coverSearch.checked;
                const coverUploadChecked = coverUpload && coverUpload.checked;

                if (coverUploadArea) coverUploadArea.style.display = coverUploadChecked ? 'block' : 'none';
                if (coverPreviewArea) coverPreviewArea.style.display = (coverSearchChecked || coverUploadChecked) ? 'block' : 'none';

                // 新增逻辑: 控制在线来源选择区域的显示
                if (onlineSourceSelectionArea) {
                    onlineSourceSelectionArea.style.display = coverSearchChecked ? 'block' : 'none';
                }

                if (coverNone && coverNone.checked) {
                    if (coverPreview) { coverPreview.src = ''; coverPreview.style.display = 'none'; }
                    coverDataUrl = null;
                    onlineCoverResults = []; // (假设 qidianCoverResults 已重命名为 onlineCoverResults)
                    currentOnlineCoverIndex = 0; // (假设 currentOnlineCoverIndex 已重命名)
                }
                if (!coverUploadChecked) {
                    if(coverFileName) { coverFileName.textContent = ''; coverFileName.style.display = 'none'; }
                }
                updateCoverNavigation();
                updateSummary();
            }

            function activateSection(sectionId, iconElement) {
                const sectionElement = document.getElementById(sectionId);
                if (!sectionElement) {
                    log(`Section with ID ${sectionId} not found`, 'error');
                    return;
                }
                if(settingsSections) settingsSections.forEach(section => section.classList.remove('active'));
                if(sidebarIcons) sidebarIcons.forEach(icon => icon.classList.remove('active'));
                
                sectionElement.classList.add('active');
                if (iconElement) iconElement.classList.add('active');
                
                if (sidebarContent && !sidebarContent.classList.contains('expanded')) {
                    sidebarContent.classList.add('expanded');
                }
                 updateMainContentMargin(); // Call this after ensuring content is expanded
            }

            function handleResize() {
                if (window.innerWidth > 992) {
                    if (sidebar) sidebar.classList.remove('sidebar-visible');
                }
                updateMainContentMargin(); 
            }

            function updateMainContentMargin() {
                if (!mainContent || !sidebar || !sidebarContent) return;

                if (window.innerWidth > 992) { 
                    // Desktop: Margin depends on whether the detailed content panel is open
                    if (sidebarContent.classList.contains('expanded')) {
                        mainContent.style.marginLeft = `var(--sidebar-width)`;
                    } else {
                        mainContent.style.marginLeft = `var(--icons-width)`;
                    }
                } else { 
                    // Mobile: Margin depends on whether the icon bar itself is visible (sliding out)
                    // No margin needed if sidebar is hidden, icons-width if it's visible.
                    // The sidebarContent panel is always full width on mobile when expanded.
                     mainContent.style.marginLeft = '0px'; // Default for mobile when sidebar is hidden
                }
            }


            // --- File Handling ---
            function setupFileEventListeners() {
                if (!dropArea || !fileInput || !selectFileBtn || !removeTxtBtn) return;
                dropArea.addEventListener('click', (e) => { if (e.target !== selectFileBtn && !selectFileBtn.contains(e.target)) fileInput.click(); });
                selectFileBtn.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });
                fileInput.addEventListener('change', handleFileSelect);
                removeTxtBtn.addEventListener('click', (e) => { e.stopPropagation(); removeFile(); });
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => dropArea.addEventListener(ev, preventDefaults, false));
                ['dragenter', 'dragover'].forEach(ev => dropArea.addEventListener(ev, highlight, false));
                ['dragleave', 'drop'].forEach(ev => dropArea.addEventListener(ev, unhighlight, false));
                dropArea.addEventListener('drop', handleDrop, false);
            }
            function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
            function highlight() { if (dropArea) dropArea.classList.add('active'); }
            function unhighlight() { if (dropArea) dropArea.classList.remove('active'); }
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    let txtFileFound = false;
                    for (let i = 0; i < files.length; i++) {
                        if (files[i].name.toLowerCase().endsWith('.txt')) {
                            const dataTransfer = new DataTransfer(); dataTransfer.items.add(files[i]); fileInput.files = dataTransfer.files;
                            handleFileSelect(); txtFileFound = true; break;
                        }
                    }
                    if (coverUpload && coverUpload.checked) {
                        for (let i = 0; i < files.length; i++) {
                            if (files[i].type.startsWith('image/')) {
                                const dataTransfer = new DataTransfer(); dataTransfer.items.add(files[i]); coverInput.files = dataTransfer.files;
                                handleCoverSelect(); break;
                            }
                        }
                    }
                    if (!txtFileFound) log('No .txt file found in dropped files.', 'warning');
                }
            }
            function handleFileSelect() {
                if (fileInput.files.length > 0) {
                    selectedFile = fileInput.files[0];
                    if (!selectedFile.name.toLowerCase().endsWith('.txt')) {
                        log('Error: Not a .txt file', 'error'); showCustomAlert('请选择一个有效的 .txt 文件。', '文件类型错误', 'error'); removeFile(); return;
                    }
                    if (txtFileName) txtFileName.textContent = selectedFile.name;
                    if (txtFileSize) txtFileSize.textContent = formatFileSize(selectedFile.size);
                    if (txtPreview) txtPreview.style.display = 'flex';
                    if (fileInfo) fileInfo.style.display = 'block';
                    if (dropArea) dropArea.style.display = 'none';
                    if (txtEncoding) txtEncoding.textContent = '检测中...';

                    detectEncoding(selectedFile).then(encodingInfo => {
                        detectedEncoding = encodingInfo.encoding;
                        if (txtEncoding) txtEncoding.textContent = `${encodingInfo.encoding} (${Math.round(encodingInfo.confidence * 100)}%)`;
                        log(`Detected encoding: ${encodingInfo.encoding} with confidence ${Math.round(encodingInfo.confidence * 100)}%`);
                        extractTitleAuthor(selectedFile.name);
                        updateSummary();
                        if (coverSearch && coverSearch.checked) searchOnlineCover();
                    }).catch(error => {
                        log(`Error detecting encoding: ${error.message}`, 'error');
                        if (txtEncoding) txtEncoding.textContent = '错误';
                        extractTitleAuthor(selectedFile.name);
                        updateSummary();
                        if (coverSearch && coverSearch.checked) searchOnlineCover();
                    });
                }
            }
            function handleCoverSelect() {
                if (coverInput.files.length > 0) {
                    coverFile = coverInput.files[0];
                    if (!coverFile.type.startsWith('image/')) {
                        log('Error: Not an image file', 'error'); showCustomAlert('请选择一个有效的图片文件。', '文件类型错误', 'error');
                        coverFile = null; coverInput.value = ''; if(coverFileName) coverFileName.textContent = ''; if(coverFileName) coverFileName.style.display = 'none'; if(coverPreview) coverPreview.src = ''; if(coverPreview) coverPreview.style.display = 'none'; 
                        onlineCoverResults = []; currentOnlineCoverIndex = 0; updateCoverNavigation();
                        updateSummary(); return;
                    }
                    if(coverFileName) coverFileName.textContent = `已选择: ${coverFile.name}`; if(coverFileName) coverFileName.style.display = 'block';
                    const reader = new FileReader();
                    reader.onload = (e) => { 
                        coverDataUrl = e.target.result; 
                        onlineCoverResults = []; currentOnlineCoverIndex = 0; // Reset Qidian search if local is chosen
                        updateCoverNavigation(); // Hide Qidian nav
                        if(coverPreview) { coverPreview.src = coverDataUrl; coverPreview.style.display = 'block';} 
                        updateSummary(); 
                        log('Local cover image loaded.'); 
                    };
                    reader.onerror = (error) => { log(`Error reading cover file: ${error}`, 'error'); coverDataUrl = null; updateSummary(); };
                    reader.readAsDataURL(coverFile);
                }
            }
            function removeFile() {
                selectedFile = null; fileArrayBuffer = null; processedText = null; epubBlob = null; detectedEncoding = null;
                if (fileInput) fileInput.value = ''; if (txtPreview) txtPreview.style.display = 'none'; if (fileInfo) fileInfo.style.display = 'none'; if (dropArea) dropArea.style.display = 'block'; if (txtFileName) txtFileName.textContent = ''; if (txtFileSize) txtFileSize.textContent = ''; if (txtEncoding) txtEncoding.textContent = '';
                coverFile = null; coverDataUrl = null; if (coverInput) coverInput.value = ''; if (coverFileName) { coverFileName.textContent = ''; coverFileName.style.display = 'none'; } if (coverPreview) { coverPreview.src = ''; coverPreview.style.display = 'none'; }
                onlineCoverResults = []; currentOnlineCoverIndex = 0; updateCoverNavigation();
                if (bookTitle) bookTitle.value = ''; if (bookAuthor) bookAuthor.value = '';
                updateSummary(); log('File and associated data cleared.');
            }

            // --- Settings Logic ---
            function setupSettingsEventListeners() {
                const coverOptionRadios = document.querySelectorAll('input[name="coverOption"]');
                coverOptionRadios.forEach(radio => radio.addEventListener('change', () => { 
                    toggleCoverOptions(); 
                    if (selectedFile && coverSearch && coverSearch.checked) {
                        searchOnlineCover(); 
                    } else if (coverSearch && !coverSearch.checked) {
                        onlineCoverResults = []; // Clear Qidian results if not active
                        currentOnlineCoverIndex = 0;
                        if (!coverUpload.checked || !coverFile) { // If not uploading or no file, clear preview
                             coverDataUrl = null;
                        }
                        updateCoverNavigation();
                    }
                    updateSummary();
                    saveUserSettings(); // Save the selected cover option 
                }));
                if (selectCoverBtn && coverInput) { selectCoverBtn.addEventListener('click', () => coverInput.click()); coverInput.addEventListener('change', handleCoverSelect); }
                if (bookTitle) bookTitle.addEventListener('input', updateSummary);
                if (bookAuthor) bookAuthor.addEventListener('input', updateSummary);
                // 更简洁的方式：将需要监听的元素放入数组统一处理
                const settingsToTrack = [
                    // Selects
                    chapterPattern, volumePattern, titleAlign, paragraphSpacing, debugMode,
                    (typeof onlineSourceSelect !== 'undefined' ? onlineSourceSelect : null), // 条件性添加
                    // Inputs (text/number)
                    customChapterPattern, customVolumePattern, indent
                ].filter(el => el != null); // 过滤掉可能未定义的元素

                settingsToTrack.forEach(element => {
                    const eventType = (element.tagName === 'INPUT' && (element.type === 'text' || element.type === 'number')) || element.tagName === 'TEXTAREA'
                                    ? 'input'
                                    : 'change';
                    element.addEventListener(eventType, () => {
                        // 特定于元素更改的UI更新逻辑 (如果未在其他地方处理)
                        if (element === chapterPattern && customChapterArea) {
                            customChapterArea.style.display = element.value === 'custom' ? 'block' : 'none';
                        }
                        if (element === volumePattern && customVolumeArea) {
                            customVolumeArea.style.display = element.value === 'custom' ? 'block' : 'none';
                        }
                        if (element === debugMode) {
                            updateDebugArea();
                        }
                        updateSummary(); // 根据需要决定是否在此处统一调用，或在各元素自己的逻辑中调用
                        saveUserSettings();
                    });
                });

                if (prevCoverBtn) prevCoverBtn.addEventListener('click', () => navigateQidianCovers(-1));
                if (nextCoverBtn) nextCoverBtn.addEventListener('click', () => navigateQidianCovers(1));
                // 在 setupSettingsEventListeners 函数内
                if (onlineSourceSelect) {
                    onlineSourceSelect.addEventListener('change', () => {
                        // 如果当前封面选项是在线搜索，且有书名，则重新搜索
                        if (coverSearch.checked && selectedFile && bookTitle.value) {
                            searchOnlineCover(); // 这是重构后的主要搜索函数
                        }
                        updateSummary(); // 更新概要中显示的封面来源文字
                        saveUserSettings(); // 保存用户设置
                    });
                }
                if (googleBooksApiKeyInput) {
                    googleBooksApiKeyInput.addEventListener('input', () => {
                        saveUserSettings();
                        updateGoogleBooksOptionStatus(); // 当API Key更改时，也更新选项状态
                    });
                }
            }

            // 原 searchQidianCover 函数需要重构/替换为此函数
            async function searchOnlineCover() {
                if (isSearchingCover) { log('Cover search already in progress.', 'info'); return; }
                const bookname = bookTitle.value;
                if (!bookname) {
                    log('Cannot search for cover: No book title provided.', 'warning');
                    if (coverPreview) { coverPreview.src = ''; coverPreview.style.display = 'none'; }
                    coverDataUrl = null;
                    onlineCoverResults = [];
                    currentOnlineCoverIndex = 0;
                    updateCoverNavigation();
                    updateSummary();
                    return;
                }

                isSearchingCover = true;
                if (convertBtn) convertBtn.disabled = true; // 保持原有逻辑
                const searchingPlaceholder = 'https://placehold.co/150x225/e9ecef/6c757d?text=Searching...';
                if (coverPreview) { coverPreview.src = searchingPlaceholder; coverPreview.style.display = 'block'; }

                onlineCoverResults = []; // 清空之前的任何来源的结果
                currentOnlineCoverIndex = 0;
                updateCoverNavigation(); // 先隐藏导航，除非有结果
                updateSummary(); // 更新概要，可能显示“搜索中”

                const currentSource = onlineSourceSelect.value; // 获取用户选择的来源
                log(`Searching for cover with query: "${bookname}" using source: ${currentSource}`);

                try {
                    switch (currentSource) {
                        case 'qidian':
                            await fetchQidianCoversInternal(bookname); // 提取出的起点特定逻辑
                            break;
                        case 'openlibrary':
                            await fetchOpenLibraryCoversInternal(bookname); // 新的Open Library逻辑
                            break;
                        case 'googlebooks':
                            await fetchGoogleBooksCoversInternal(bookname); // 新的Google Books逻辑
                            break;
                        default:
                            log(`Unknown online source selected: ${currentSource}`, 'warning');
                            throw new Error(`未知的在线封面来源: ${currentSource}`);
                    }

                    if (onlineCoverResults.length > 0) {
                        displayCurrentOnlineCover(); // 重命名的显示函数
                    } else {
                        log('No cover images found from selected source.', 'info');
                        const noResultsPlaceholder = `https://placehold.co/150x225/e9ecef/6c757d?text=No+Results+from+${currentSource.charAt(0).toUpperCase() + currentSource.slice(1)}`;
                        if (coverPreview) { coverPreview.src = noResultsPlaceholder; coverPreview.style.display = 'block'; }
                        coverDataUrl = null; // 确保没有旧的 coverDataUrl 残留
                    }

                } catch (error) {
                    log(`Online cover search error (${currentSource}): ${error.message}`, 'error');
                    coverDataUrl = null;
                    const errorPlaceholder = `https://placehold.co/150x225/ef476f/ffffff?text=Error+(${currentSource.charAt(0).toUpperCase() + currentSource.slice(1)})`;
                    if (coverPreview) { coverPreview.src = errorPlaceholder; coverPreview.style.display = 'block'; }
                } finally {
                    isSearchingCover = false;
                    if (convertBtn) convertBtn.disabled = !selectedFile; // 保持原有逻辑
                    updateCoverNavigation(); // 根据是否有结果更新导航按钮
                    updateSummary();
                }
            }

            async function fetchQidianCoversInternal(bookname) {
                // const corsProxy = 'https://corsproxy.io/?'; 
                // const targetUrl = encodeURIComponent(`https://m.qidian.com/soushu/${encodeURIComponent(bookname)}.html`); 
                // const proxyUrl = corsProxy + targetUrl;
                // log(`Connecting to Qidian search URL: ${proxyUrl}`); // Log proxied URL
                // const netlifyCorsProxy = 'https://cors-anywhere.herokuapp.com/'; // 备用代理
                // const proxyUrlFallback = netlifyCorsProxy + targetUrl; // 备用代理URL
                const netlifyFunctionUrl = `/.netlify/functions/fetch-qidian?bookname=${encodeURIComponent(bookname)}`;
                log(`正在调用Netlify函数获取起点数据: ${netlifyFunctionUrl}`);
                

                const response = await fetch(netlifyFunctionUrl); 
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: "无法解析错误响应" }));
                    throw new Error(`Netlify函数调用失败 (状态 ${response.status}): ${errorData.error || response.statusText}`);
                }
                const htmlContent = await response.text(); 
                log('Received Qidian search page.');

                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                const imageElements = doc.querySelectorAll('.y-list__item img[data-src]'); // More specific selectors
                
                onlineCoverResults = [];
                imageElements.forEach(img => {
                    let rawUrl = img.dataset.src || img.getAttribute('data-src');
                    if (rawUrl) {
                        if (rawUrl.startsWith('//')) {
                            rawUrl = 'https:' + rawUrl;
                        }
                        // Attempt to get a larger image if a pattern like /150 or /180 is at the end
                        let largeUrl = rawUrl.replace(/\/(150|180|90|100|120)$/, '/600');
                        if (!onlineCoverResults.includes(largeUrl)) { // Avoid duplicates if regex isn't perfect
                            onlineCoverResults.push(largeUrl);
                        }
                    }
                });
            }

            async function fetchOpenLibraryCoversInternal(bookname) {
                const searchUrl = `https://openlibrary.org/search.json?q=${encodeURIComponent(bookname)}&fields=key,title,author_name,cover_i,isbn&limit=10`; // 限制结果数量
                log(`Workspaceing from Open Library: ${searchUrl}`);
                const response = await fetch(searchUrl);
                if (!response.ok) throw new Error(`Open Library search failed: ${response.statusText}`);
                const data = await response.json();
                if (data.docs && data.docs.length > 0) {
                    for (const doc of data.docs) {
                        if (doc.cover_i) {
                            onlineCoverResults.push(`https://covers.openlibrary.org/b/id/${doc.cover_i}-L.jpg`);
                        } else if (doc.isbn && doc.isbn.length > 0) {
                            // Try with first ISBN that might have a cover
                            onlineCoverResults.push(`https://covers.openlibrary.org/b/isbn/${doc.isbn[0]}-L.jpg`);
                        }
                    }
                }
                // 过滤掉可能无效的URL或添加错误处理以验证图片是否存在
                // (可选: 使用 checkImageExists 或类似的逻辑来验证图片URL是否真的有效)
                log(`Open Library: Found ${onlineCoverResults.length} potential cover(s).`);
            }

            async function fetchGoogleBooksCoversInternal(bookname) {
                const userApiKey = googleBooksApiKeyInput ? googleBooksApiKeyInput.value.trim() : "";

                if (!userApiKey) {
                    log("Google Books API Key 未在设置中配置。将跳过 Google Books 搜索。", "warning");
                    // 通知用户API Key缺失，所以Google Books源不可用
                    showCustomAlert("Google Books 封面搜索需要您在“调试选项”中配置有效的API Key。", "API Key缺失", "warning");
                    // 清空可能存在的旧结果，并直接返回
                    onlineCoverResults = []; // 确保结果数组被清空
                    // 注意：这里不抛出错误，而是静默失败，searchOnlineCover 会处理无结果的情况
                    return;
                }

                const searchUrl = `https://www.googleapis.com/books/v1/volumes?q=intitle:${encodeURIComponent(bookname)}&key=${userApiKey}&maxResults=10`;
                log(`Workspaceing from Google Books with user API Key: ${searchUrl}`);

                try {
                    const response = await fetch(searchUrl);
                    if (!response.ok) {
                        // 如果API Key无效或服务有问题，Google API会返回错误
                        const errorData = await response.json().catch(() => null); // 尝试解析错误详情
                        let errorMessage = `Google Books API请求失败: ${response.status} ${response.statusText}`;
                        if (errorData && errorData.error && errorData.error.message) {
                            errorMessage += `\n详情: ${errorData.error.message}`;
                            if (errorData.error.errors && errorData.error.errors[0] && errorData.error.errors[0].reason === 'keyInvalid') {
                                showCustomAlert("您提供的 Google Books API Key 无效或权限不足。请检查您的API Key设置。", "API Key无效", "error");
                            }
                        }
                        throw new Error(errorMessage);
                    }
                    const data = await response.json();
                    if (data.items && data.items.length > 0) {
                        for (const item of data.items) {
                            if (item.volumeInfo && item.volumeInfo.imageLinks) {
                                const links = item.volumeInfo.imageLinks;
                                const coverUrl = links.large || links.medium || links.thumbnail || links.smallThumbnail || links.small || links.extraLarge;
                                if (coverUrl) {
                                    onlineCoverResults.push(coverUrl.replace(/^http:/, 'https:'));
                                }
                            }
                        }
                    }
                    log(`Google Books: Found ${onlineCoverResults.length} potential cover(s).`);
                } catch (error) {
                    log(`Error fetching from Google Books: ${error.message}`, 'error');
                    // 可以在此处决定是否向用户显示一个更通用的错误，因为具体的API Key无效错误已在上面处理
                    // showCustomAlert(`从Google Books获取封面失败：<br>${error.message}`, "Google Books错误", "error");
                    onlineCoverResults = []; // 确保出错时清空结果
                    // 不再向上抛出错误，让 searchOnlineCover 处理空结果的情况
                }
            }

            function updateGoogleBooksOptionStatus() {
                if (!onlineSourceSelect || !googleBooksApiKeyInput) return;

                const googleBooksOption = onlineSourceSelect.querySelector('option[value="googlebooks"]');
                if (!googleBooksOption) return; // 如果HTML中没有这个选项，则跳过

                const apiKey = googleBooksApiKeyInput.value.trim();

                if (!apiKey) {
                    googleBooksOption.textContent = "Google Books (需API Key)";
                    // 可选：如果当前选中的就是Google Books且没有API Key，可以提示用户或切换到默认源
                    if (onlineSourceSelect.value === 'googlebooks' && coverSearch.checked) {
                        // 避免在仅仅加载设置时就弹出alert，这个逻辑可能需要更细致地放在用户尝试搜索时
                        // log("Google Books selected but no API key.", "warning");
                    }
                } else {
                    googleBooksOption.textContent = "Google Books (已配置Key)"; // 或者只显示 "Google Books"
                }
            }

            // 在 initializeApp 末尾，以及 loadUserSettings 末尾调用一次 updateGoogleBooksOptionStatus()
            // 也在 googleBooksApiKeyInput 的 'input' 事件监听器中调用它。

            function displayCurrentOnlineCover() {
                if (onlineCoverResults.length > 0 && coverSearch.checked) {
                    coverDataUrl = onlineCoverResults[currentOnlineCoverIndex];
                    if (coverPreview) {
                        coverPreview.src = ''; // Clear src first to ensure onload fires for same URL if re-selected
                        coverPreview.src = coverDataUrl;
                        coverPreview.style.display = 'block';

                        // Add error handling for individual image load
                        coverPreview.onerror = () => {
                            log(`Failed to load image: ${coverDataUrl}`, 'error');
                            coverPreview.src = 'https://placehold.co/150x225/f0f0f0/cc0000?text=Load+Error'; // Show load error
                            // Optionally, try to remove this image from results and move to next
                            // onlineCoverResults.splice(currentOnlineCoverIndex, 1);
                            // if (currentOnlineCoverIndex >= onlineCoverResults.length) currentOnlineCoverIndex = 0;
                            // if (onlineCoverResults.length > 0) displayCurrentOnlineCover(); else updateCoverNavigation();
                        };
                    }
                    log(`Displaying ${onlineSourceSelect.options[onlineSourceSelect.selectedIndex].text.split(' (')[0]} cover ${currentOnlineCoverIndex + 1} of ${onlineCoverResults.length}: ${coverDataUrl}`);
                } else if (!coverUpload.checked || !coverFile) { // If not Qidian and no local upload
                    coverDataUrl = null;
                    if (coverPreview) {
                        coverPreview.src = '';
                        coverPreview.style.display = 'none';
                    }
                }
                // If coverUpload is checked and coverFile exists, coverDataUrl is already set by handleCoverSelect
                updateCoverNavigation();
                updateSummary();
            }

            function navigateQidianCovers(direction) {
                if (!coverSearch.checked || onlineCoverResults.length === 0) return;

                currentOnlineCoverIndex += direction;

                if (currentOnlineCoverIndex < 0) {
                    currentOnlineCoverIndex = onlineCoverResults.length - 1;
                } else if (currentOnlineCoverIndex >= onlineCoverResults.length) {
                    currentOnlineCoverIndex = 0;
                }
                displayCurrentOnlineCover();
            }

            function updateCoverNavigation() {
                if (coverSearch.checked && onlineCoverResults.length > 0) {
                    if (coverNavigationControls) coverNavigationControls.style.display = 'flex';
                    if (coverIndicator) coverIndicator.textContent = `${currentOnlineCoverIndex + 1} / ${onlineCoverResults.length}`;
                    if (prevCoverBtn) prevCoverBtn.disabled = onlineCoverResults.length <= 1;
                    if (nextCoverBtn) nextCoverBtn.disabled = onlineCoverResults.length <= 1;
                } else {
                    if (coverNavigationControls) coverNavigationControls.style.display = 'none';
                }
            }


            function checkImageExists(url) { 
                 return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Image not found or failed to load from URL: ' + url));
                    img.src = url;
                });
            }
            function updateSummary() {
                if (summaryTitle) summaryTitle.textContent = bookTitle?.value || '未设置';
                if (summaryAuthor) summaryAuthor.textContent = bookAuthor?.value || '未设置';
                
                let coverSourceTextVal = '无封面';
                if (coverUpload?.checked && coverFile) {
                    coverSourceTextVal = '本地上传';
                } else if (coverSearch?.checked) {
                    // 获取当前选中的在线来源的显示文本
                    const selectedOption = onlineSourceSelect.options[onlineSourceSelect.selectedIndex];
                    coverSourceTextVal = selectedOption ? selectedOption.text.split(' (')[0] : '在线搜索'; // 例如 "起点小说" 或 "Open Library"
                }
                if (summaryCoverSourceText) summaryCoverSourceText.textContent = coverSourceTextVal;
                if (summaryCoverPreview && summaryCoverPlaceholder) {
                    let currentDisplaySrc = null;

                    if (coverUpload?.checked && coverFile && coverDataUrl?.startsWith('data:')) {
                         currentDisplaySrc = coverDataUrl;
                    } else if (coverSearch?.checked && onlineCoverResults.length > 0) {
                         currentDisplaySrc = onlineCoverResults[currentOnlineCoverIndex];
                    } else if (coverSearch?.checked && coverDataUrl && !coverDataUrl.includes('placehold.co') && onlineCoverResults.length === 0) {
                        // This case handles if a single coverDataUrl was set before multiple results logic
                        currentDisplaySrc = coverDataUrl;
                    }


                    if (currentDisplaySrc && !currentDisplaySrc.includes('placehold.co')) {
                        summaryCoverPreview.src = currentDisplaySrc;
                        summaryCoverPreview.style.display = 'block';
                        summaryCoverPlaceholder.style.display = 'none';
                    } else if (isSearchingCover && coverSearch?.checked) {
                        summaryCoverPreview.src = 'https://placehold.co/150x225/e9ecef/6c757d?text=Searching...';
                        summaryCoverPreview.style.display = 'block'; // Show searching placeholder
                        summaryCoverPlaceholder.style.display = 'none';
                    }
                     else {
                        summaryCoverPreview.src = '';
                        summaryCoverPreview.style.display = 'none';
                        summaryCoverPlaceholder.textContent = (coverNone?.checked) ? '无封面' : '等待封面...';
                        summaryCoverPlaceholder.style.display = 'block';
                    }
                }
            }

            // --- Conversion Logic ---
            function setupConversionEventListeners() { 
                if (convertBtn) convertBtn.addEventListener('click', startConversion);
                if (downloadBtn) downloadBtn.addEventListener('click', downloadEpub);
                if (convertNewBtn) convertNewBtn.addEventListener('click', resetConverter);
            }
            async function startConversion() { 
                if (!selectedFile) { showCustomAlert('请先选择一个 TXT 文件，然后再开始转换。', '操作提示', 'warning'); return; }
                const title = bookTitle?.value || '未知标题'; const author = bookAuthor?.value || '未知作者'; const language = bookLanguage?.value || 'en';
                const options = {
                    title, author, language,
                    chapterPattern: getChapterPatternRegex(), volumePattern: getVolumePatternRegex(),
                    maxTitleLength: 35, unknownTitleName: '章节正文',
                    indent: parseFloat(indent?.value) || 2, titleAlign: titleAlign?.value || 'center', fontFamily: 'default',
                    fontSize: '1em', lineHeight: '1.6', paragraphSpacing: paragraphSpacing?.value || '1em'
                };
                log(`Starting conversion with options: ${JSON.stringify(options)}`, 'info');
                if (uploadCard) uploadCard.style.display = 'none'; if (debugAreaDOM) debugAreaDOM.style.display = (debugMode?.value === 'on') ? 'block' : 'none'; if (progressCard) progressCard.style.display = 'block'; if (convertBtn) convertBtn.disabled = true;
                let progress = 0; const progressInterval = setInterval(() => { 
                    progress += Math.random() * 5 + 2; if (progress > 95 && progress < 100) progress = 95; else if (progress >= 100) progress = 99; if (progressBar) progressBar.style.width = `${progress}%`; if (progressStatus) { if (progress < 20) progressStatus.textContent = '读取和解码文本文件...'; else if (progress < 40) progressStatus.textContent = '检测章节和卷...'; else if (progress < 60) progressStatus.textContent = '格式化内容...'; else if (progress < 80) progressStatus.textContent = '创建EPUB结构...'; else progressStatus.textContent = '正在完成您的电子书...'; }
                }, 150);
                try {
                    let text; if (!fileArrayBuffer && selectedFile) { log('File ArrayBuffer not found, reading file again.', 'warning'); fileArrayBuffer = await readFileAsArrayBuffer(selectedFile); } if (!fileArrayBuffer) throw new Error("无法读取文件内容。");
                    text = await decodeText(fileArrayBuffer, detectedEncoding || 'UTF-8'); text = cleanText(text); log(`Text cleaned. Length: ${text.length} characters`);
                    processedText = processText(text, options); log(`Text processed. Found ${countSections(processedText)} sections`);
                    
                    let finalCoverDataUrl = null;
                    if (coverUpload?.checked && coverFile) { 
                        finalCoverDataUrl = await readFileAsDataURL(coverFile); 
                    } else if (coverSearch?.checked && onlineCoverResults.length > 0) {
                        const selectedQidianUrl = onlineCoverResults[currentOnlineCoverIndex];
                        if (selectedQidianUrl) {
                            if (selectedQidianUrl.startsWith('http')) finalCoverDataUrl = await fetchImageAsDataURL(selectedQidianUrl);
                            else if (selectedQidianUrl.startsWith('data:')) finalCoverDataUrl = selectedQidianUrl; // Should not happen for Qidian
                        }
                    } else if (coverSearch?.checked && coverDataUrl && !coverDataUrl.includes('placehold.co')) {
                         // Fallback for single coverDataUrl if onlineCoverResults is empty but a valid URL exists
                         if (coverDataUrl.startsWith('http')) finalCoverDataUrl = await fetchImageAsDataURL(coverDataUrl);
                         else if (coverDataUrl.startsWith('data:')) finalCoverDataUrl = coverDataUrl;
                    }

                    if (typeof JSZip === 'undefined') throw new Error('JSZip library not found.');
                    epubBlob = await generateEpub(processedText, finalCoverDataUrl, options); log(`EPUB created successfully. Size: ${formatFileSize(epubBlob.size)}`, 'success');
                    clearInterval(progressInterval); if (progressBar) progressBar.style.width = '100%'; if (progressStatus) progressStatus.textContent = '转换完成！';
                    setTimeout(() => { if (progressCard) progressCard.style.display = 'none'; if (resultCard) resultCard.style.display = 'block'; if (resultFileName) resultFileName.textContent = `${sanitizeFilename(title)}.epub`; if (resultFileSize) resultFileSize.textContent = formatFileSize(epubBlob.size); if (convertBtn) convertBtn.disabled = false; }, 500);
                } catch (error) {
                    clearInterval(progressInterval); log(`Conversion error: ${error.message}`, 'error'); showCustomAlert(`转换过程中发生错误: <br>${error.message}`, '转换失败', 'error', () => {
                            // resetConverter(); // 如果 resetConverter 会清除其他状态，确保这是期望的行为
                            // 或者仅重置UI到可以重新尝试的状态
                            if (uploadCard) uploadCard.style.display = 'block';
                            if (progressCard) progressCard.style.display = 'none';
                            if (convertBtn) convertBtn.disabled = !selectedFile; // 只有当有文件时才解禁
                        }); 
                }
            }
            function resetConverter() { 
                 if (uploadCard) uploadCard.style.display = 'block'; if (dropArea) dropArea.style.display = 'block'; if (fileInfo) fileInfo.style.display = 'none'; if (progressCard) progressCard.style.display = 'none'; if (resultCard) resultCard.style.display = 'none'; if (progressBar) progressBar.style.width = '0%'; if (progressStatus) progressStatus.textContent = '';
                 updateDebugArea(); removeFile(); // This already clears coverFile, coverDataUrl, qidianResults
                 if (chapterPattern && customChapterPattern) { chapterPattern.value = 'auto'; customChapterPattern.value = ''; if (customChapterArea) customChapterArea.style.display = 'none'; } if (volumePattern && customVolumePattern) { volumePattern.value = 'auto'; customVolumePattern.value = ''; if (customVolumeArea) customVolumeArea.style.display = 'none'; }
                 if (coverSearch) coverSearch.checked = true; 
                 toggleCoverOptions(); // This will re-evaluate display of nav etc.
                 epubBlob = null; if (convertBtn) convertBtn.disabled = false; 
                 log('Converter reset to initial state', 'info');
            }
            function downloadEpub() { 
                 if (!epubBlob) { log('Download error: No EPUB file generated', 'error'); showCustomAlert('没有可供下载的 EPUB 文件。请先成功转换一个文件。', '下载错误', 'error'); return; } const title = bookTitle?.value || 'Untitled_Book'; const filename = `${sanitizeFilename(title)}.epub`; const isQuark = /Quark/i.test(navigator.userAgent); log(isQuark); log(navigator.userAgent); if (typeof saveAs === 'undefined' || isQuark) { log('FileSaver.js not found, using fallback download method', 'warning'); const url = URL.createObjectURL(epubBlob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100); } else { saveAs(epubBlob, filename); } log(`EPUB downloaded as: ${filename}`, 'success');
            }

            // --- Text Processing & EPUB Generation ---
            function getChapterPatternRegex() { 
                 if (!chapterPattern) return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; switch (chapterPattern.value) { case 'auto': return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; case 'chinese': return /^第[0-9一二三四五六七八九十百千万亿零〇]+[章节回集幕部篇](\s|$)/; case 'english': return /^(Chapter|CHAPTER)\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; case 'numbered': return /^\d+\.\s+/; case 'custom': try { if (customChapterPattern?.value) return new RegExp(customChapterPattern.value, 'i'); else { log('Empty custom chapter pattern, using auto-detect instead', 'warning'); return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; } } catch (e) { log(`Invalid chapter regex pattern: ${e.message}`, 'error'); showCustomAlert('您输入的自定义章节模式无效。<br>系统将自动切换回默认的章节检测模式。', '模式格式警告', 'warning'); return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; } default: return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; }
            }
            function getVolumePatternRegex() { 
                if (!volumePattern || volumePattern.value === 'disabled') return null; switch (volumePattern.value) { case 'auto': return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; case 'chinese': return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)/; case 'english': return /^(Volume|Book)\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; case 'custom': try { if (customVolumePattern?.value) return new RegExp(customVolumePattern.value, 'i'); else { log('Empty custom volume pattern, using auto-detect instead', 'warning'); return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; } } catch (e) { log(`Invalid volume regex pattern: ${e.message}`, 'error'); alert('无效的自定义卷/部模式。将使用自动检测。'); return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; } default: return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; }
            }
            function cleanText(text) { 
                log('Cleaning text...');
                text = text.replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\x7F\uFFFE\uFFFF]/g, ''); 
                text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n'); 
                text = text.replace(/\uFFFD/g, ''); 
                const junkPatterns = [ /^\s*(最新章节请到)\s*.*?\.com\s*$/gim, /^\s*(请收藏本站)\s*.*?\.com\s*$/gim, /^\s*(看最新章节)\s*.*?\.com\s*$/gim, /^\s*(手机用户请到)\s*.*?\.com\s*阅读\s*$/gim, /^\s*www\..*?\.(com|net|org)\s*$/gim, /^\s*小说来源[:：].*$/gim, /^\s*下载地址[:：].*$/gim, /^\s*本书首发来自.*$/gim, /^\s*更多精校小说尽在.*$/gim, /^\s*【本作品来自互联网.*$/gim, /^\s*------------.*$/gim, /^\s*========.*$/gim, /^\s*ps[:：].*$/gim ];
                junkPatterns.forEach(pattern => { text = text.replace(pattern, ''); });
                text = text.replace(/^\s*本文来自.*$/gm, ''); text = text.replace(/^\s*正文\s*$/gm, ''); text = text.replace(/^\s*序章\s*$/gm, ''); text = text.replace(/\n\s*\n/g, '\n\n'); return text.trim(); 
            }
            function processText(text, options) { 
                 log('Processing text to detect chapters and volumes...'); const lines = text.split('\n'); const sections = []; let currentVolume = null; let currentChapter = { title: options.unknownTitleName, type: 'text', content: [] }; let hasContentSinceLastTitle = false; const chapterRegex = options.chapterPattern; const volumeRegex = options.volumePattern; const maxLen = options.maxTitleLength; for (let i = 0; i < lines.length; i++) { let line = lines[i].trim(); if (!line) continue; let isPotentialTitle = line.length <= maxLen; let isVolumeTitle = volumeRegex && volumeRegex.test(line) && isPotentialTitle; let isChapterTitle = chapterRegex && chapterRegex.test(line) && isPotentialTitle; if (isVolumeTitle) { if (hasContentSinceLastTitle && currentChapter.content.length > 0) { if (currentVolume) currentVolume.chapters.push(currentChapter); else sections.push(currentChapter); } if (currentVolume) sections.push(currentVolume); currentVolume = { title: line, type: 'volume', chapters: [] }; currentChapter = { title: options.unknownTitleName, type: 'text', content: [] }; hasContentSinceLastTitle = false; log(`New Volume: ${line}`); } else if (isChapterTitle) { if (hasContentSinceLastTitle && currentChapter.content.length > 0) { if (currentVolume) currentVolume.chapters.push(currentChapter); else sections.push(currentChapter); } currentChapter = { title: line, type: 'chapter', content: [] }; hasContentSinceLastTitle = false; log(`New Chapter: ${line}`); } else { if (line.toLowerCase().includes("本章未完") || line.toLowerCase().includes("点击下一页")) continue; if (line.startsWith("（本章完）")) continue; currentChapter.content.push(line); hasContentSinceLastTitle = true; } } if (hasContentSinceLastTitle && currentChapter.content.length > 0) { if (currentVolume) currentVolume.chapters.push(currentChapter); else sections.push(currentChapter); } if (currentVolume) sections.push(currentVolume); const finalSections = []; let chapterCounter = 1; sections.forEach(section => { if (section.type === 'volume') { if (section.chapters.length > 0) { section.chapters.forEach(chap => { if (!chap.title || chap.title === options.unknownTitleName) chap.title = `${options.unknownTitleName} ${chapterCounter++}`; chap.paragraphs = processParagraphs(chap.content); }); finalSections.push(section); } else log(`Skipping empty volume: ${section.title}`, 'warning'); } else { if (!section.title || section.title === options.unknownTitleName) section.title = `${options.unknownTitleName} ${chapterCounter++}`; section.paragraphs = processParagraphs(section.content); if (section.paragraphs.length > 0) finalSections.push(section); else log(`Skipping empty chapter: ${section.title}`, 'warning'); } }); log(`Found ${countSections(finalSections)} total sections after processing.`); return finalSections;
            }
            function countSections(sections) { 
                let count = 0; for (let i = 0; i < sections.length; i++) { if (sections[i].type === 'volume') count += 1 + sections[i].chapters.length; else count++; } return count;
            }
            function processParagraphs(lines) { 
                const paragraphs = []; if (!lines) return paragraphs; for (let i = 0; i < lines.length; i++) { if (lines[i].trim()) paragraphs.push(lines[i].trim()); } return paragraphs;
            }
            async function generateEpub(sections, coverImageDataUrl, options) { 
                log('Generating EPUB file...'); 
                try { 
                    if (typeof JSZip === 'undefined') throw new Error('JSZip library not found'); 
                    const zip = new JSZip(); 
                    zip.file('mimetype', 'application/epub+zip', {compression: "STORE"}); 
                    const metaInf = zip.folder('META-INF'); 
                    metaInf.file('container.xml', '<?xml version="1.0" encoding="UTF-8"?><container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container"><rootfiles><rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/></rootfiles></container>'); 
                    const oebps = zip.folder('OEBPS'); 
                    const imagesFolder = oebps.folder('images'); 
                    const fontFamilyCSS = getFontFamilyCSS(options.fontFamily); 
                    const titleAlignCSS = `text-align: ${options.titleAlign};`; 
                    const indentVal = `${options.indent}em`; 
                    const styleContent = `body { ${fontFamilyCSS} margin: 20px; line-height: ${options.lineHeight}; font-size: ${options.fontSize};} h1, h2, h3 { margin-top: 1.5em; margin-bottom: 0.8em; font-weight: bold; ${titleAlignCSS} } h1 { font-size: 2em; } h2 { font-size: 1.6em; } h3 { font-size: 1.3em; } p { text-indent: ${indentVal}; margin: 0 0 ${options.paragraphSpacing} 0; hyphens: auto; text-align: justify; } p.no-indent { text-indent: 0; } .title-page .book-title { font-size: 2.5em; margin-bottom: 0.5em; ${titleAlignCSS} } .title-page .author { font-size: 1.5em; margin-bottom: 3em; ${titleAlignCSS} font-style: italic; } .cover-page img { max-width: 100%; height: auto; display: block; margin: 0 auto; max-height: 95vh; } .volume-title { page-break-before: always; margin-top: 3em; } .chapter-title { page-break-before: always; margin-top: 2em; } .special-title { font-style: italic; } nav ol { list-style-type: none; padding-left: 0; } nav ol ol { padding-left: 1.5em; } nav a { text-decoration: none; color: var(--primary-color, #4361ee); } nav a:hover { text-decoration: underline; } @media amzn-kf8 { body { font-family: "Amazon Ember", "Bookerly", serif; } p { text-align: justify; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; } } @media amzn-mobi { body { font-family: serif; } p { text-align: left; } }`; 
                    oebps.file('stylesheet.css', styleContent); 
                    const uuid = 'urn:uuid:' + generateUUID(); 
                    let coverImagePath = null; 
                    let coverImageType = 'image/jpeg'; 
                    if (coverImageDataUrl?.startsWith('data:')) { 
                        const match = coverImageDataUrl.match(/^data:(image\/(?:png|jpeg|gif|webp|svg\+xml));base64,(.+)$/); 
                        if (match?.[1] && match?.[2]) { 
                            coverImageType = match[1]; 
                            const base64Data = match[2]; 
                            const ext = coverImageType.split('/')[1].replace('svg+xml', 'svg') || 'jpg'; 
                            coverImagePath = `images/cover.${ext}`; 
                            imagesFolder.file(`cover.${ext}`, base64Data, {base64: true}); 
                            log(`Cover image added: ${coverImagePath} (Type: ${coverImageType})`); 
                        } else {
                            log(`Invalid cover image data URL format: ${coverImageDataUrl.substring(0,100)}... Skipping cover.`, 'warning');
                        }
                    } else if (coverImageDataUrl) {
                        log(`Cover image data is not a Data URL (possibly due to fetch error). Skipping cover. URL: ${coverImageDataUrl.substring(0,100)}`, 'warning');
                    }
                    oebps.file('title.xhtml', `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>${escapeXML(options.title)}</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body class="title-page"><div id="title_page_main" class="book-title">${escapeXML(options.title)}</div><div class="author">${escapeXML(options.author)}</div></body></html>`); 
                    if (coverImagePath) {
                        oebps.file('cover.xhtml', `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>Cover</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body class="cover-page"><div id="cover_image_container"><img src="${coverImagePath}" alt="Cover Image" /></div></body></html>`);
                    }
                    
                    let manifestItems = ''; 
                    let spineItems = ''; 
                    const navDocLinks = []; 
                    let ncxNavPoints = ''; 
                    let playOrder = 1; 

                    if (coverImagePath) { 
                        manifestItems += `<item id="cover-img" href="${coverImagePath}" media-type="${coverImageType}" properties="cover-image"/>\n`; 
                        manifestItems += `<item id="cover-page" href="cover.xhtml" media-type="application/xhtml+xml"/>\n`; 
                        spineItems += `<itemref idref="cover-page" linear="yes"/>\n`; 
                    } 
                    manifestItems += `<item id="title-page" href="title.xhtml" media-type="application/xhtml+xml"/>\n`; 
                    spineItems += `<itemref idref="title-page"/>\n`; 
                    navDocLinks.push({ title: '书名页', href: `title.xhtml#title_page_main`, level: 1 }); 
                    ncxNavPoints += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>书名页</text></navLabel><content src="title.xhtml#title_page_main"/></navPoint>\n`; 
                    manifestItems += `<item id="css" href="stylesheet.css" media-type="text/css"/>\n`; 
                    
                    sections.forEach((section, sectionIndex) => { 
                        const sectionBaseId = `s_${sectionIndex + 1}`; 
                        if (section.type === 'volume') { 
                            const volumeAnchorId = `${sectionBaseId}_vol_title`; 
                            const volumeFilename = `${sectionBaseId}_vol.xhtml`; 
                            let volumePageContent = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>${escapeXML(section.title)}</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body><h1 id="${volumeAnchorId}" class="volume-title" epub:type="volume z3998:roman">${escapeXML(section.title)}</h1></body></html>`; 
                            oebps.file(volumeFilename, volumePageContent); 
                            manifestItems += `<item id="${sectionBaseId}-vol" href="${volumeFilename}" media-type="application/xhtml+xml"/>\n`; 
                            spineItems += `<itemref idref="${sectionBaseId}-vol"/>\n`; 
                            const volumeNavEntry = { title: escapeXML(section.title), href: `${volumeFilename}#${volumeAnchorId}`, level: 1, children: [] }; 
                            navDocLinks.push(volumeNavEntry); 
                            let currentVolumeNcxNavPoint = `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(section.title)}</text></navLabel><content src="${volumeFilename}#${volumeAnchorId}"/>`;
                            let volumeNcxChildren = '';
                            section.chapters.forEach((chapter, chapterIndex) => { 
                                const chapterAnchorId = `${sectionBaseId}_ch${chapterIndex + 1}_title`; 
                                const chapterFilename = `${sectionBaseId}_ch${chapterIndex + 1}.xhtml`; 
                                let chapterHtml = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>${escapeXML(chapter.title)}</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body><h2 id="${chapterAnchorId}" class="chapter-title ${chapter.type === 'special' ? 'special-title' : ''}" epub:type="chapter ${chapter.type === 'special' ? 'z3998:credits' : ''}">${escapeXML(chapter.title)}</h2>`; 
                                chapter.paragraphs.forEach(p => { chapterHtml += `<p>${escapeXML(p)}</p>\n`; }); 
                                chapterHtml += `</body></html>`; 
                                oebps.file(chapterFilename, chapterHtml); 
                                manifestItems += `<item id="${sectionBaseId}-ch${chapterIndex + 1}" href="${chapterFilename}" media-type="application/xhtml+xml"/>\n`; 
                                spineItems += `<itemref idref="${sectionBaseId}-ch${chapterIndex + 1}"/>\n`; 
                                volumeNavEntry.children.push({ title: escapeXML(chapter.title), href: `${chapterFilename}#${chapterAnchorId}`, level: 2 }); 
                                volumeNcxChildren += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(chapter.title)}</text></navLabel><content src="${chapterFilename}#${chapterAnchorId}"/></navPoint>\n`; 
                            }); 
                            currentVolumeNcxNavPoint += volumeNcxChildren + `</navPoint>\n`;
                            ncxNavPoints += currentVolumeNcxNavPoint;
                        } else { 
                            const chapterAnchorId = `${sectionBaseId}_title`; 
                            const chapterFilename = `${sectionBaseId}.xhtml`; 
                            let chapterHtml = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>${escapeXML(section.title)}</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body><h2 id="${chapterAnchorId}" class="chapter-title ${section.type === 'special' ? 'special-title' : ''}" epub:type="chapter ${section.type === 'special' ? 'z3998:credits' : ''}">${escapeXML(section.title)}</h2>`; 
                            section.paragraphs.forEach(p => { chapterHtml += `<p>${escapeXML(p)}</p>\n`; }); 
                            chapterHtml += `</body></html>`; 
                            oebps.file(chapterFilename, chapterHtml); 
                            manifestItems += `<item id="${sectionBaseId}" href="${chapterFilename}" media-type="application/xhtml+xml"/>\n`; 
                            spineItems += `<itemref idref="${sectionBaseId}"/>\n`; 
                            navDocLinks.push({ title: escapeXML(section.title), href: `${chapterFilename}#${chapterAnchorId}`, level: 1 }); 
                            ncxNavPoints += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(section.title)}</text></navLabel><content src="${chapterFilename}#${chapterAnchorId}"/></navPoint>\n`; 
                        } 
                    }); 

                    // Calculate maxNavDepth for NCX
                    let maxNavDepth = 0;
                    navDocLinks.forEach(item => {
                        if (item.level > maxNavDepth) maxNavDepth = item.level;
                        if (item.children && item.children.length > 0) {
                            item.children.forEach(child => {
                                if (child.level > maxNavDepth) maxNavDepth = child.level;
                            });
                        }
                    });
                    if (maxNavDepth === 0 && navDocLinks.length > 0) maxNavDepth = 1; // Ensure depth is at least 1 if there are any links


                    let navDocHtml = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><title>Table of Contents</title><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="stylesheet.css"/></head><body><nav epub:type="toc" id="toc"><h1>目录</h1><ol>`; 
                    navDocLinks.forEach(item => { 
                        navDocHtml += `<li><a href="${item.href}">${item.title}</a>`; 
                        if (item.children?.length > 0) { 
                            navDocHtml += `<ol>`; 
                            item.children.forEach(child => { 
                                navDocHtml += `<li><a href="${child.href}">${child.title}</a></li>\n`; 
                            }); 
                            navDocHtml += `</ol>`; 
                        } 
                        navDocHtml += `</li>\n`; 
                    }); 
                    navDocHtml += `</ol></nav><nav epub:type="landmarks" hidden="hidden"><h2>Landmarks</h2><ol>`; 
                    if (coverImagePath) navDocHtml += `<li><a epub:type="cover" href="cover.xhtml#cover_image_container">封面</a></li>\n`; 
                    const firstContentItem = navDocLinks.find(item => item.href?.includes("_vol.xhtml#") || item.href?.includes("_ch") || item.href?.includes("s_") && !item.href.startsWith("title.xhtml")); 
                    const bodyMatterHref = firstContentItem ? firstContentItem.href : (navDocLinks.length > 1 && !navDocLinks[1].href.startsWith("title.xhtml") ? navDocLinks[1].href : (navDocLinks.length > 0 && !navDocLinks[0].href.startsWith("title.xhtml") ? navDocLinks[0].href : "title.xhtml#title_page_main" ) );
                    navDocHtml += `<li><a epub:type="bodymatter" href="${bodyMatterHref}">开始阅读</a></li>\n`; 
                    navDocHtml += `<li><a epub:type="toc" href="nav.xhtml#toc">目录</a></li>\n`; 
                    navDocHtml += `</ol></nav></body></html>`; 
                    oebps.file('nav.xhtml', navDocHtml); 
                    manifestItems += `<item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>\n`; 
                    
                    // Use dynamic maxNavDepth here
                    const ncxContent = `<?xml version="1.0" encoding="UTF-8"?><ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1"><head><meta name="dtb:uid" content="${uuid}"/><meta name="dtb:depth" content="${maxNavDepth}"/><meta name="dtb:totalPageCount" content="0"/><meta name="dtb:maxPageNumber" content="0"/></head><docTitle><text>${escapeXML(options.title)}</text></docTitle><navMap>${ncxNavPoints}</navMap></ncx>`; 
                    oebps.file('toc.ncx', ncxContent); 
                    manifestItems += `<item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>\n`; 
                    
                    const contentOpf = `<?xml version="1.0" encoding="UTF-8"?><package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="BookId"><metadata xmlns:dc="http://purl.org/dc/elements/1.1/"><dc:title>${escapeXML(options.title)}</dc:title><dc:creator id="creator">${escapeXML(options.author)}</dc:creator><dc:language>${options.language}</dc:language><dc:identifier id="BookId">${uuid}</dc:identifier><meta property="dcterms:modified">${new Date().toISOString().split('.')[0]+"Z"}</meta>${coverImagePath ? '<meta name="cover" content="cover-img"/>' : ''}</metadata><manifest>${manifestItems}</manifest><spine toc="ncx">${spineItems}</spine></package>`; 
                    oebps.file('content.opf', contentOpf); 
                    const epubData = await zip.generateAsync({ type: 'blob', mimeType: 'application/epub+zip', compression: 'DEFLATE', compressionOptions: { level: 9 } }); 
                    log('EPUB blob generated.', 'success'); 
                    return epubData; 
                } catch (error) { 
                    log(`Error generating EPUB: ${error.message}`, 'error'); 
                    console.error("EPUB Generation Error Details:", error); 
                    throw error; 
                }
            }
            
            // --- Utility Functions ---
            function getFontFamilyCSS(fontType) { 
                 switch (fontType) { case 'serif': return 'font-family: "Georgia", "Times New Roman", "Noto Serif SC", serif;'; case 'sans': return 'font-family: "Helvetica", "Arial", "Noto Sans SC", sans-serif;'; case 'mono': return 'font-family: "Courier New", "Menlo", "Noto Sans Mono SC", monospace;'; default: return 'font-family: "Noto Serif SC", "Songti SC", "SimSun", serif;'; }
            }
            function escapeXML(text) { 
                if (typeof text !== 'string') return ''; return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
            }
            function generateUUID() { 
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { const r = Math.random() * 16 | 0; const v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); });
            }
            function updateDebugArea() { 
                if (debugMode && debugAreaDOM) debugAreaDOM.style.display = debugMode.value === 'on' ? 'block' : 'none';
            }
            function log(message, level = 'info') { 
                 const timestamp = new Date().toLocaleTimeString(); if (level === 'error') console.error(message); else if (level === 'warning') console.warn(message); else console.log(message); if (debugLog && debugMode?.value === 'on') { const logEntry = document.createElement('div'); let color = '#e0e0e0'; if (level === 'error') color = '#ef476f'; else if (level === 'warning') color = '#f7b801'; else if (level === 'success') color = '#34a853'; logEntry.style.color = color; logEntry.textContent = `[${timestamp}] ${level.toUpperCase()}: ${message}`; debugLog.appendChild(logEntry); debugLog.scrollTop = debugLog.scrollHeight; }
            }
            function formatFileSize(bytes) { 
                if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            function extractTitleAuthor(filename) { 
                log(`Extracting title/author from filename: ${filename}`); let name = filename.replace(/\.txt$/i, ''); const chineseTitleAuthorPattern = /《([^》]+)》[^作者]*作者[：:]\s*([^.]+)(?:\.txt)?$/; const chineseMatch = name.match(chineseTitleAuthorPattern); if (chineseMatch) { if (bookTitle) bookTitle.value = chineseMatch[1].trim(); if (chineseMatch[2] && bookAuthor) bookAuthor.value = chineseMatch[2].trim(); log(`Extracted title: "${bookTitle.value}" and author: "${bookAuthor?.value || 'N/A'}"`); return; } const englishTitleAuthorPattern = /(.+?)(?:\s+-\s+|\s+by\s+)(.+)/i; const englishMatch = name.match(englishTitleAuthorPattern); if (englishMatch) { if (bookTitle) bookTitle.value = englishMatch[1].trim(); if (bookAuthor) bookAuthor.value = englishMatch[2].trim(); log(`Extracted title: "${bookTitle?.value || 'N/A'}" and author: "${bookAuthor?.value || 'N/A'}"`); return; } if (bookTitle) bookTitle.value = name.trim(); if (bookAuthor) bookAuthor.value = ''; log(`Using filename as title: "${bookTitle?.value || 'N/A'}", author cleared.`);
            }
            async function detectEncoding(file) { 
                log('Starting encoding detection...'); try { const arrayBuffer = await readFileAsArrayBuffer(file); fileArrayBuffer = arrayBuffer; if (typeof jschardet === 'undefined') { log('jschardet library not found, using UTF-8 as default encoding', 'warning'); return { encoding: 'UTF-8', confidence: 0.9 }; } const sampleSize = Math.min(4096, arrayBuffer.byteLength); const sampleData = new Uint8Array(arrayBuffer, 0, sampleSize); const result = jschardet.detect(sampleData); let encoding = result.encoding || 'UTF-8'; if (encoding === 'ascii' || encoding === 'windows-1252') { const possibleChinese = detectChineseEncoding(sampleData); if (possibleChinese) { encoding = 'GB18030'; result.confidence = 0.85; } } const mappedEncoding = mapEncodingName(encoding); log(`Encoding detection complete: ${mappedEncoding} (original: ${encoding})`); return { encoding: mappedEncoding, confidence: result.confidence || 0.5 }; } catch (error) { log(`Encoding detection failed: ${error.message}`, 'error'); throw error; }
            }
            function detectChineseEncoding(data) { 
                let gbkPatternCount = 0; for (let i = 0; i < data.length - 1; i++) { if (data[i] >= 0x81 && data[i] <= 0xFE) { if (data[i+1] >= 0x40 && data[i+1] <= 0xFE) gbkPatternCount++; } } return gbkPatternCount > 20;
            }
            function mapEncodingName(encoding) { 
                if (!encoding) return 'UTF-8'; const lowerEncoding = encoding.toLowerCase(); const encodingMap = { 'gb2312': 'GB18030', 'gbk': 'GB18030', 'gb18030': 'GB18030', 'windows-1252': 'windows-1252', 'ascii': 'UTF-8', 'utf-8': 'UTF-8', 'utf8': 'UTF-8', 'big5': 'Big5' }; return encodingMap[lowerEncoding] || encoding;
            }
            async function readFileAsArrayBuffer(file) { 
                 return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(new Error('Failed to read file as ArrayBuffer.')); reader.readAsArrayBuffer(file); });
            }
            async function decodeText(arrayBuffer, encodingName) { 
                log(`Decoding text with encoding: ${encodingName}`); try { const decoder = new TextDecoder(encodingName, { fatal: true }); return decoder.decode(arrayBuffer); } catch (error) { log(`TextDecoder failed for ${encodingName}: ${error.message}. Falling back to UTF-8.`, 'warning'); try { const fallbackDecoder = new TextDecoder('UTF-8', { fatal: false }); return fallbackDecoder.decode(arrayBuffer); } catch (fallbackError) { log(`Fallback UTF-8 decoding also failed: ${fallbackError.message}`, 'error'); throw new Error(`Failed to decode text with ${encodingName} and fallback UTF-8.`); } }
            }
            async function readFileAsDataURL(file) { 
                 return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = (error) => reject(new Error(`Failed to read file as DataURL: ${error}`)); reader.readAsDataURL(file); });
            }
            async function fetchImageAsDataURL(imageUrl) {
                log(`Fetching image as DataURL (direct/canvas method): ${imageUrl}`, 'info');
                try {
                    const img = new Image();
                    const imageLoaded = new Promise((resolve, reject) => {
                        img.crossOrigin = 'Anonymous'; 

                        const timeoutDuration = 10000; 
                        let timeoutId = setTimeout(() => {
                            reject(new Error(`Timeout loading image from URL (after ${timeoutDuration/1000}s): ${imageUrl}`));
                        }, timeoutDuration);

                        img.onload = () => {
                            clearTimeout(timeoutId);
                            resolve(img);
                        };
                        img.onerror = () => {
                            clearTimeout(timeoutId);
                            reject(new Error('Failed to load image from URL: ' + imageUrl));
                        };

                        img.src = imageUrl; 
                    });

                    const loadedImg = await imageLoaded;

                    const canvas = document.createElement('canvas');
                    canvas.width = loadedImg.width;
                    canvas.height = loadedImg.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(loadedImg, 0, 0);

                    try {
                        return canvas.toDataURL('image/jpeg'); 
                    } catch (e) {
                        throw new Error(`Canvas toDataURL failed (tainted canvas?): ${e.message} for ${imageUrl}`);
                    }
                } catch (error) {
                    log(`Error in fetchImageAsDataURL (direct/canvas): ${error.message}. The searched cover will not be used.`, 'error');
                    return null; 
                }
            }
            function sanitizeFilename(name) { 
                if (!name) return 'Untitled'; return name.replace(/[\/\\:*?"<>|]/g, '_').replace(/\s+/g, '_').replace(/__+/g, '_').replace(/^_+|_+$/g, '');
            }
            loadUserSettings();
            updateGoogleBooksOptionStatus();
        });
    </script>
</body>
</html>