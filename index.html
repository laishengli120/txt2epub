<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TXT to EPUB Converter - Memphis Style</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jschardet/3.0.0/jschardet.min.js"></script>
    <style>
        /* --- Memphis Design Style --- */

        :root {
            /* Memphis Color Palette */
            --memphis-bg: #f8f4f0; /* Light background */
            --memphis-primary: #ff6b6b; /* Bright Red/Pink */
            --memphis-secondary: #feca57; /* Yellow */
            --memphis-accent1: #48dbfb; /* Light Blue */
            --memphis-accent2: #1dd1a1; /* Mint Green */
            --memphis-dark: #1e1e1e; /* Black/Dark Gray */
            --memphis-white: #ffffff;
            
            /* Other Variables */
            --sidebar-width: 280px;
            --icons-width: 55px;
            --header-height: 65px;
            --border-radius: 6px; /* Slightly less rounded for Memphis */
            --bold-border: 3px solid var(--memphis-dark);
            --graphic-shadow: 5px 5px 0px var(--memphis-dark); /* Hard shadow */
            --transition: all 0.2s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Bouncy transition */

            /* Font */
            --font-family: 'Poppins', sans-serif;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: var(--font-family);
        }
        
        body {
            background-color: var(--memphis-bg);
            color: var(--memphis-dark);
            line-height: 1.6;
            overflow-x: hidden;
             /* Optional: Add a subtle Memphis background pattern */
            /* background-image: url('data:image/svg+xml,...'); */
        }
        
        .app-container {
            display: flex;
            min-height: 100vh;
            position: relative;
        }

        /* --- Header --- */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background-color: var(--memphis-secondary); /* Yellow background */
            border-bottom: var(--bold-border);
            display: flex;
            align-items: center;
            padding: 0 25px;
            z-index: 100;
            box-shadow: var(--graphic-shadow);
        }
        
        .header h1 {
            color: var(--memphis-dark);
            font-size: 1.4rem; /* Slightly larger */
            font-weight: 700; /* Bolder */
            margin: 0;
            flex: 1;
            text-transform: uppercase; /* Uppercase title */
            letter-spacing: 1px;
        }
        
        .header-actions button {
            margin-left: 10px;
            display: none; /* Keep hidden unless in mobile */
             /* Style button later */
        }

        /* --- Sidebar --- */
        .sidebar {
            position: fixed; /* Changed to fixed for consistency */
            display: flex;
            height: calc(100vh - var(--header-height));
            top: var(--header-height);
            left: 0;
            z-index: 90;
            transition: transform 0.3s ease-out; /* Slide transition */
            transform: translateX(0); /* Default state */
        }

        /* Icons Column */
        .sidebar-icons {
            width: var(--icons-width);
            height: 100%;
            background-color: var(--memphis-primary); /* Red/Pink background */
            border-right: var(--bold-border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            z-index: 91;
        }

        .sidebar-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%; /* Circular icons */
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
            color: var(--memphis-dark);
            background-color: var(--memphis-white);
            border: 2px solid var(--memphis-dark);
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 3px 3px 0px rgba(0,0,0,0.2);
        }

        .sidebar-icon:hover {
            background-color: var(--memphis-secondary); /* Yellow hover */
            transform: translateY(-2px) rotate(5deg);
            box-shadow: 4px 4px 0px rgba(0,0,0,0.3);
        }

        .sidebar-icon.active {
            background-color: var(--memphis-accent2); /* Mint green active */
            color: var(--memphis-white);
            transform: scale(1.1);
            box-shadow: none;
        }
        .sidebar-icon i {
            font-size: 18px; /* Adjust icon size */
        }

        /* Content Panel */
        .sidebar-content {
            width: calc(var(--sidebar-width) - var(--icons-width));
            height: 100%;
            background-color: var(--memphis-white);
            border-right: var(--bold-border);
            overflow-y: auto; /* Changed from hidden */
            transition: width 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
            box-shadow: inset -3px 0px 0px rgba(0,0,0,0.1); /* Inner shadow */
        }

        /* Collapsed state for sidebar content */
        .sidebar-content:not(.expanded) {
             width: 0;
             opacity: 0;
             overflow: hidden; /* Hide content when collapsed */
             border-right: none; /* Hide border when collapsed */
        }
        
        .sidebar-content.expanded {
            width: calc(var(--sidebar-width) - var(--icons-width));
            opacity: 1;
        }

        /* Settings Sections */
        .settings-section {
            display: none;
            padding: 25px;
            height: 100%;
        }

        .settings-section.active {
            display: block;
        }

        .settings-header {
            margin-bottom: 25px;
            border-bottom: 2px dashed var(--memphis-dark); /* Dashed border */
            padding-bottom: 15px;
            position: relative;
        }
        .settings-body {
            padding-bottom: 60px; /* Space for the decorative element */
        }
        /* Add a decorative element */
        .settings-header::after {
            content: '';
            position: absolute;
            bottom: -10px; /* Position below the border */
            left: 0;
            width: 20px;
            height: 20px;
            background-color: var(--memphis-primary);
            border: var(--bold-border);
            border-radius: 50%;
        }


        .settings-header h3 {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--memphis-primary); /* Red/Pink title */
            margin: 0;
            display: flex;
            align-items: center;
        }

        .settings-header h3 i {
            margin-right: 10px;
            color: var(--memphis-dark);
        }

        /* --- Main Content --- */
        .main-content {
            flex: 1;
            margin-top: var(--header-height);
            padding: 30px;
            transition: margin-left 0.3s ease-out; /* Adjust margin on sidebar toggle */
            /* Default margin-left is now managed by JS and media queries */
        }


        /* --- Content Cards --- */
        .content-card {
            background-color: var(--memphis-white);
            border-radius: var(--border-radius);
            border: var(--bold-border);
            box-shadow: var(--graphic-shadow);
            padding: 25px;
            margin-bottom: 30px; /* Add space between cards */
            position: relative; /* For potential decorative elements */
        }
        /* Add a decorative shape to cards */
         .content-card::before {
            content: '';
            position: absolute;
            top: -10px;
            right: -10px;
            width: 30px;
            height: 30px;
            background-color: var(--memphis-accent1); /* Light blue shape */
            border: var(--bold-border);
            transform: rotate(45deg);
            z-index: -1; /* Behind the card */
        }


        /* --- Form Elements --- */
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--memphis-dark);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-control {
            width: 100%;
            padding: 10px 15px;
            border: var(--bold-border);
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: var(--transition);
            background-color: var(--memphis-bg); /* Light background inside */
        }
        
        .form-control:focus {
            border-color: var(--memphis-primary); /* Red/Pink focus border */
            outline: none;
            box-shadow: 0 0 0 3px var(--memphis-accent1); /* Light blue focus ring */
            background-color: var(--memphis-white);
        }
        
        select.form-control {
             appearance: none; /* Remove default arrow */
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%231e1e1e'%3E%3Cpath fill-rule='evenodd' d='M8 11.5a.5.5 0 0 1-.354-.146l-4-4a.5.5 0 0 1 .708-.708L8 10.293l3.646-3.647a.5.5 0 0 1 .708.708l-4 4A.5.5 0 0 1 8 11.5z'/%3E%3C/svg%3E"); /* Custom arrow */
             background-repeat: no-repeat;
             background-position: right 15px center;
             background-size: 16px 16px;
             padding-right: 40px; /* Space for arrow */
        }

        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px; /* Space between options */
            margin-bottom: 8px;
        }
        
        .radio-option {
            margin-right: 0; /* Use gap instead */
            margin-bottom: 0;
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .radio-option input[type="radio"] {
            appearance: none; /* Hide default radio */
            width: 20px;
            height: 20px;
            border: var(--bold-border);
            border-radius: 50%;
            margin-right: 8px;
            position: relative;
            top: -1px;
            transition: background-color 0.2s ease;
        }
        .radio-option input[type="radio"]:checked {
            background-color: var(--memphis-dark); /* Fill when checked */
        }
         .radio-option input[type="radio"]:checked::after { /* Inner dot */
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            width: 6px;
            height: 6px;
            background-color: var(--memphis-white);
            border-radius: 50%;
        }

        .radio-option label {
            font-weight: 400; /* Normal weight for radio labels */
            text-transform: none;
            letter-spacing: 0;
            margin-bottom: 0; /* Remove bottom margin */
        }

        /* --- Buttons --- */
        .btn {
            display: inline-block;
            padding: 12px 25px;
            background-color: var(--memphis-primary); /* Red/Pink */
            color: var(--memphis-white);
            border: var(--bold-border);
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 700; /* Bold */
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            text-align: center;
            box-shadow: var(--graphic-shadow);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn:hover {
            background-color: var(--memphis-accent2); /* Mint green hover */
            color: var(--memphis-dark);
            transform: translateY(-3px) translateX(-3px);
            box-shadow: 8px 8px 0px var(--memphis-dark); /* Increase shadow on hover */
        }
        
        .btn:active {
            transform: translateY(0) translateX(0);
            box-shadow: var(--graphic-shadow); /* Reset shadow on active */
        }
        
        .btn-secondary { background-color: var(--memphis-secondary); color: var(--memphis-dark); }
        .btn-secondary:hover { background-color: var(--memphis-accent1); }
        
        .btn-success { background-color: var(--memphis-accent2); color: var(--memphis-dark); }
        .btn-success:hover { background-color: var(--memphis-primary); color: var(--memphis-white); }
        
        .btn-outline {
            background-color: transparent;
            border: var(--bold-border);
            color: var(--memphis-dark);
            box-shadow: none; /* No shadow for outline */
        }
        
        .btn-outline:hover {
            background-color: var(--memphis-dark);
            color: var(--memphis-white);
            transform: none; /* No move on hover */
            box-shadow: none;
        }
        
        .btn-sm { padding: 8px 15px; font-size: 0.9rem; }
        .btn-block { display: block; width: 100%; }
        
        .btn-disabled, /* General disabled */
        .convert-btn:disabled { /* Specific for convert button */
            background: var(--mid-gray) !important; 
            color: var(--light-text) !important;
            border-color: var(--dark-gray) !important;
            cursor: not-allowed !important;
            opacity: 0.8 !important;
            box-shadow: none !important;
            transform: none !important;
        }
        
        .btn-disabled:hover,
        .convert-btn:disabled:hover { 
             background: var(--mid-gray) !important; 
             box-shadow: none !important;
             transform: none !important;
        }

        /* --- Drop Area --- */
        .drop-area {
            border: 3px dashed var(--memphis-dark); /* Thicker dashed border */
            border-radius: var(--border-radius);
            padding: 60px 30px; /* More padding */
            text-align: center;
            transition: var(--transition);
            cursor: pointer;
            position: relative;
            background-color: var(--memphis-accent1); /* Light blue background */
            color: var(--memphis-dark);
            overflow: hidden; /* For patterns */
        }
         /* Add a pattern to drop area */
        .drop-area::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                radial-gradient(var(--memphis-secondary) 2px, transparent 2px), /* Yellow dots */
                radial-gradient(var(--memphis-secondary) 2px, transparent 2px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            opacity: 0.3;
            z-index: 0;
        }


        .drop-area:hover {
            border-color: var(--memphis-primary);
            background-color: var(--memphis-accent2); /* Mint green hover */
            transform: scale(1.02); /* Slight scale on hover */
        }
        
        .drop-area.active {
            border-color: var(--memphis-primary);
            border-style: solid; /* Solid border when active */
            background-color: var(--memphis-accent2);
        }
        
        .drop-area h3, .drop-area p, .drop-area .btn {
            position: relative; /* Ensure text/button is above pattern */
            z-index: 1;
        }

        .drop-area h3 {
            margin-bottom: 15px;
            font-weight: 700;
            font-size: 1.3rem;
        }
        
        .drop-area p {
            color: var(--memphis-dark);
            margin-bottom: 25px;
            font-size: 1rem;
        }
        
        .drop-area input { /* Keep hidden input */
            position: absolute; width: 100%; height: 100%; top: 0; left: 0; opacity: 0; cursor: pointer; z-index: 10;
        }
        .file-format-badge { /* Style the badge */
             background-color: var(--memphis-secondary);
             color: var(--memphis-dark);
             padding: 3px 12px;
             border-radius: 4px;
             font-weight: 600;
             margin: 0 5px;
             border: 2px solid var(--memphis-dark);
        }

        /* --- File Info & Convert Button Area --- */
         #fileInfo {
            margin-top: 25px;
         }
        .filbt {
            margin: 25px 0 18px;
            display: flex;
            background-color: var(--memphis-accent2); /* Mint green background */
            border: var(--bold-border);
            border-radius: var(--border-radius);
            box-shadow: var(--graphic-shadow);
            overflow: hidden; /* Ensure children fit */
        }
        .file-preview {
            display: flex; /* Keep initial state */
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background-color: transparent; /* Use parent background */
            flex: 1;
            border-radius: 0; /* Remove individual radius */
        }
        .file-preview .file-icon-and-details {
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
        }
        
        .file-preview .file-icon-and-details i.fa-file-alt {
            font-size: 26px;
            margin-right: 12px;
            color: var(--memphis-dark);
            flex-shrink: 0;
        }
        .file-preview .file-details {
            min-width: 0; /* Prevent overflow */
        }
        
        .file-details h4 { font-weight: 600; font-size: 1rem; color: var(--memphis-dark); 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; /* Ellipsis for long text */
        }
        .file-preview-actions {
            display: flex;
            align-items: center;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .file-preview-actions .icon-button { /* Style remove button */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 30px; height: 30px; /* Make it square */
            cursor: pointer;
            border-radius: 50%; /* Circle */
            border: 2px solid var(--memphis-dark);
            margin-left: 15px; /* Add left margin */
            transition: var(--transition);
        }
        .file-preview-actions .icon-button:first-child {
            margin-left: 0; /* Remove left margin for first child */
        }
        .file-preview-actions .icon-button i {
            font-size: 15px; /* Icon size */
        }
        .file-preview-actions .icon-button:hover {
            /* 通用悬停效果 */
            transform: translateY(-2px) translateX(-2px) rotate(8deg) scale(1.05);
            box-shadow: 5px 5px 0px var(--memphis-dark);
        }
        .file-preview-actions .icon-button:active {
            /* 通用点击效果 */
            transform: translateY(0) translateX(0) rotate(0) scale(0.95);
            box-shadow: 2px 2px 0px var(--memphis-dark);
        }
        #previewTxtBtn.icon-button {
            background-color: var(--memphis-secondary); /* Yellow */
            color: var(--memphis-dark);
        }
        #previewTxtBtn.icon-button:hover {
            background-color: var(--memphis-accent1); /* Light blue hover */
        }
        #removeTxtBtn.icon-button {
            background-color: var(--memphis-primary); /* Red/Pink */
            color: var(--memphis-white);
        }
        #removeTxtBtn.icon-button:hover {
            background-color: var(--memphis-accent2); /* Mint green hover */
        }
        /* Convert Button Specific Style */
        .convert-btn {
            padding: 15px 35px; /* More padding */
            background: var(--memphis-primary); /* Red/Pink */
            color: var(--memphis-white);
            border: none; /* Remove default border */
            border-left: var(--bold-border); /* Add left border */
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: none; /* Remove individual shadow */
            min-width: auto; /* Remove min-width */
            margin: 0; /* Remove margin */
            border-radius: 0; /* Remove individual radius */
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .convert-btn:hover {
             background: var(--memphis-secondary); /* Yellow hover */
             color: var(--memphis-dark);
             transform: skewX(-10deg); /* Skew effect */
        }
         .convert-btn:active {
             transform: skewX(0deg);
         }

        /* --- Configuration Summary --- */
        .config-summary {
            border: var(--bold-border);
            border-left: 8px solid var(--memphis-primary); /* Thicker left border */
            padding: 20px;
            margin: 25px 0;
            font-size: 0.9rem;
            background-color: var(--memphis-bg); /* Light background */
            border-radius: var(--border-radius);
        }
        .summary-container { display: flex; justify-content: space-between; align-items: flex-start; gap: 20px; }
        .summary-text { flex: 1; }
        .config-summary h4 {
            margin-bottom: 15px;
            color: var(--memphis-primary); /* Red/Pink */
            font-weight: 700;
            text-transform: uppercase;
        }
        .config-summary p { margin: 6px 0; color: var(--memphis-dark); }
        .config-summary p strong { font-weight: 600; }
        
        .summary-cover { /* Cover preview in summary */
            width: 100px; /* Smaller */
            height: 150px;
            border: var(--bold-border);
            display: flex; justify-content: center; align-items: center;
            background-color: var(--memphis-accent1); /* Light blue background */
            border-radius: 4px;
            overflow: hidden;
            box-shadow: var(--graphic-shadow);
            position: relative; /* For the change cover button */
        }
        .summary-cover:hover .change-cover-btn {
            opacity: 1;
        }
        .change-cover-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0,0,0,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
            line-height: 30px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }
         .change-cover-btn:hover {
            background-color: rgba(0,0,0,0.8);
         }

        .summary-cover img { max-width: 100%; max-height: 100%; object-fit: cover; display: none; } /* Hide initially */
        #summaryCoverPlaceholder { color: var(--memphis-dark); font-size: 0.8rem; text-align: center; padding: 10px; font-weight: 600; }
        .summary-cover img[src]:not([src=""]):not([src*="placehold.co"]) { display: block; } /* Show if src is valid */
        .summary-cover img[src]:not([src=""]):not([src*="placehold.co"]) + #summaryCoverPlaceholder { display: none; } /* Hide placeholder if image shown */
        .summary-cover img[src*="placehold.co"] + #summaryCoverPlaceholder { display: block; } /* Show placeholder if placeholder image */


        /* --- Progress & Result Areas --- */
        .progress-area, .result-area {
            /* Use .content-card styling */
            text-align: center;
        }
        .loading-spinner { /* Style spinner */
            width: 50px; height: 50px;
            border: 5px dotted var(--memphis-dark); /* Dotted border */
            border-radius: 50%;
            border-top-color: transparent; /* Make one part transparent */
            animation: spin 1.5s linear infinite;
            margin-bottom: 20px;
        }
        .progress-area h3, .result-area h3 {
            font-size: 1.4rem; font-weight: 700; margin-bottom: 10px; color: var(--memphis-primary);
        }
        .progress-area p, .result-area p {
            font-size: 1rem; margin-bottom: 20px; color: var(--memphis-dark);
        }
        .progress-bar-container {
            height: 15px; /* Thicker bar */
            background-color: var(--memphis-accent1); /* Light blue background */
            border-radius: var(--border-radius);
            border: 2px solid var(--memphis-dark);
            margin: 25px 0;
            overflow: hidden;
            padding: 2px; /* Padding inside border */
        }
        .progress-bar {
            height: 100%;
            background-color: var(--memphis-primary); /* Red/Pink progress */
            width: 0%;
            transition: width 0.4s ease-out;
            border-radius: 3px; /* Slightly rounded inner bar */
        }
        
        .result-icon { color: var(--memphis-accent2); font-size: 60px; margin-bottom: 20px; }
        .result-card { /* Inner card for result details */
            background-color: var(--memphis-secondary); /* Yellow background */
            border-radius: var(--border-radius);
            border: var(--bold-border);
            padding: 20px;
            margin-top: 25px;
        }
         .result-card h4 { font-size: 1.1rem; font-weight: 600; margin-bottom: 5px; color: var(--memphis-dark); }
         .result-card p { font-size: 0.9rem; margin-bottom: 20px; color: var(--memphis-dark); }
        
        .result-actions { margin-top: 20px; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
        .result-actions .btn { min-width: 160px; }
        .result-actions .btn i { margin-right: 10px; }
        
        /* --- Debug Area --- */
        .debug-area {
             margin-top: 30px; padding: 20px; background-color: var(--memphis-dark); border-radius: var(--border-radius); display: none; border: 3px dashed var(--memphis-secondary); /* Yellow dashed border */
        }
        .debug-area h3 { margin-bottom: 15px; color: var(--memphis-secondary); font-size: 1rem; font-weight: 600; text-transform: uppercase; }
        .debug-log { height: 250px; overflow-y: auto; background-color: #2a2a2a; color: #f0f0f0; padding: 15px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.85rem; line-height: 1.5; border: 2px solid var(--memphis-secondary); }
        .debug-log div { margin-bottom: 5px; border-bottom: 1px dotted #555; padding-bottom: 5px; word-break: break-all; }
        .debug-log div:last-child { border-bottom: none; }

        /* Cover Preview in Sidebar */
        .cover-preview-container {
            text-align: center;
            margin-top: 15px;
            position: relative; /* For navigation buttons */
        }
        .cover-preview {
            max-width: 100%;
            max-height: 200px;
            display: none;
            margin: 0 auto;
            border: var(--bold-border);
            border-radius: var(--border-radius);
            box-shadow: var(--graphic-shadow);
        }
        .cover-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        .cover-nav-btn {
            background-color: var(--memphis-secondary);
            color: var(--memphis-dark);
            border: var(--bold-border);
            border-radius: var(--border-radius);
            padding: 5px 10px;
            font-size: 0.9rem;
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--memphis-dark);
            transition: var(--transition);
        }
        .cover-nav-btn:hover {
            background-color: var(--memphis-accent1);
            transform: translateY(-1px) translateX(-1px);
            box-shadow: 3px 3px 0px var(--memphis-dark);
        }
        .cover-nav-btn:disabled {
            background-color: #ccc;
            color: #777;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #aaa;
        }
        #coverIndicator {
            font-size: 0.9rem;
            color: var(--memphis-dark);
            font-weight: 600;
        }

        /* --- Custom Alert Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(30, 30, 30, 0.7); /* 暗色半透明背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* 确保在最上层 */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55), visibility 0s linear 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        .modal-content.memphis-modal {
            background-color: var(--memphis-white);
            padding: 30px; /* 增加内边距 */
            border-radius: var(--border-radius);
            border: var(--bold-border);
            box-shadow: var(--graphic-shadow);
            width: 90%;
            max-width: 480px; /* 合适的最大宽度 */
            text-align: left;
            transform: translateY(-30px) scale(0.95); /* 出现时有点动态效果 */
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        .modal-overlay.visible .modal-content.memphis-modal {
            transform: translateY(0) scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 15px;
            margin-bottom: 20px;
            border-bottom: 3px dotted var(--memphis-dark); /* 孟菲斯风格虚线 */
            position: relative;
        }
        /* 标题装饰元素 */
        .modal-header::before {
            content: '';
            position: absolute;
            left: -15px; /* 根据内边距调整 */
            top: 50%;
            transform: translateY(-50%);
            width: 15px;
            height: 15px;
            background-color: var(--memphis-secondary); /* 黄色装饰 */
            border: var(--bold-border);
            border-radius: 0; /* 方形 */
        }


        .modal-title-text {
            font-size: 1.3rem; /* 稍大标题 */
            font-weight: 700;
            color: var(--memphis-dark); /* 默认深色标题 */
            margin: 0;
            text-transform: uppercase; /* 大写标题 */
        }

        .modal-close-btn {
            background: transparent;
            border: var(--bold-border);
            color: var(--memphis-dark);
            font-size: 1.5rem; /* 更清晰的关闭按钮 */
            font-weight: 700;
            cursor: pointer;
            line-height: 1;
            padding: 2px 8px;
            border-radius: var(--border-radius);
            transition: var(--transition);
            box-shadow: 3px 3px 0px var(--memphis-dark);
        }
        .modal-close-btn:hover {
            background-color: var(--memphis-primary);
            color: var(--memphis-white);
            transform: translateY(-2px) translateX(-2px);
            box-shadow: 5px 5px 0px var(--memphis-dark);
        }
        .modal-close-btn:active {
            transform: translateY(0) translateX(0);
            box-shadow: 3px 3px 0px var(--memphis-dark);
        }

        .modal-body {
            margin-bottom: 25px;
            font-size: 1rem;
            color: var(--memphis-dark);
            line-height: 1.7; /* 增加行高可读性 */
        }
        .modal-body p {
            text-indent: 0; /* 模态框内段落通常不缩进 */
            margin: 0;
        }

        .modal-footer {
            text-align: right;
        }
        .modal-footer .btn { /* 确保按钮样式应用 */
            min-width: 100px;
        }


        /* 不同类型的模态框 (通过JS添加class来改变颜色) */
        .memphis-modal.modal-error .modal-header::before { background-color: var(--memphis-primary); }
        .memphis-modal.modal-error .modal-title-text { color: var(--memphis-primary); }
        /* .memphis-modal.modal-error { border-color: var(--memphis-primary); } */ /* 可选：改变整个边框颜色 */

        .memphis-modal.modal-warning .modal-header::before { background-color: var(--memphis-secondary); }
        .memphis-modal.modal-warning .modal-title-text { color: var(--memphis-secondary); }
        /* .memphis-modal.modal-warning { border-color: var(--memphis-secondary); } */

        .memphis-modal.modal-info .modal-header::before { background-color: var(--memphis-accent1); }
        .memphis-modal.modal-info .modal-title-text { color: var(--memphis-accent1); }
        /* .memphis-modal.modal-info { border-color: var(--memphis-accent1); } */

        .memphis-modal.modal-success .modal-header::before { background-color: var(--memphis-accent2); }
        .memphis-modal.modal-success .modal-title-text { color: var(--memphis-accent2); }
        /* .memphis-modal.modal-success { border-color: var(--memphis-accent2); } */


        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) {
             /* Mobile view - sidebar slides out */
            .sidebar {
                 transform: translateX(calc(-1 * var(--sidebar-width))); /* Hide initially */
            }
            .sidebar.sidebar-visible {
                 transform: translateX(0); /* Show */
                 box-shadow: 5px 0 15px rgba(0,0,0,0.2); /* Add shadow when overlaying */
            }
            /* MODIFIED: Main content margin for mobile */
            .main-content {
                 margin-left: 0; /* Default for mobile, JS will adjust if sidebar is visible */
            }
             /* This class is not strictly needed for margin adjustment on mobile with the new JS logic */
             /* .main-content.sidebar-expanded {  
                 margin-left: var(--icons-width); 
             } */

            .header-actions button {
                 display: inline-block; /* Show toggle button */
                 padding: 8px 12px;
                 font-size: 0.9rem;
                 background-color: var(--memphis-primary);
                 color: var(--memphis-white);
                 border: 2px solid var(--memphis-dark);
                 box-shadow: 3px 3px 0 var(--memphis-dark);
            }
             .header-actions button:hover {
                 background-color: var(--memphis-accent2);
                 color: var(--memphis-dark);
             }
        }
        
        @media (max-width: 768px) {
             /* Adjust padding/margins for smaller screens */
             .header { padding: 0 15px; }
             .main-content { padding: 20px; } /* Padding within main-content remains */
             .content-card { padding: 20px; }
             .content-card::before { display: none; } /* Hide decorative shape on small screens */
             .drop-area { padding: 40px 20px; }
             .filbt { flex-direction: column; background: none; border: none; box-shadow: none; } /* Stack file preview and button */
             .file-preview { border-radius: var(--border-radius); border: var(--bold-border); background-color: var(--memphis-accent2); box-shadow: var(--graphic-shadow); margin-bottom: 15px; }
             .convert-btn { width: 100%; border-radius: var(--border-radius); border: var(--bold-border); box-shadow: var(--graphic-shadow); border-left: var(--bold-border); /* Keep border consistent */ }
             .convert-btn:hover { transform: translateY(-3px) translateX(-3px) skewX(0); box-shadow: 8px 8px 0px var(--memphis-dark);  } /* Use standard hover */
             .summary-container { flex-direction: row; align-items: center;} /* Changed to column for better spacing */
             .summary-text { width: 100%; margin-bottom: 15px; }
             .summary-cover { margin-top: 0; }
        }
        
        @media (max-width: 576px) {
            :root {
                --sidebar-width: 250px; /* Slightly smaller sidebar */
                --icons-width: 50px;
                --header-height: 60px;
            }
            .header h1 { font-size: 1.1rem; }
            .main-content { padding: 15px; } /* Padding within main-content remains */
            .btn { padding: 10px 20px; font-size: 0.9rem; }
            .result-actions { gap: 10px; }
            .result-actions .btn { width: 100%; min-width: auto; }
        }

        /* Animation for spinner */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>TXT to EPUB Factory</h1>
            <div class="header-actions">
                <button id="toggleSidebarBtn" class="btn btn-sm">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <div class="sidebar-icons" id="sidebarIcons">
                <div class="sidebar-icon active" data-section="bookInfoSection"> <i class="fas fa-book"></i>
                </div>
                <div class="sidebar-icon" data-section="chapterSection">
                    <i class="fas fa-wrench"></i>
                </div>
                <div class="sidebar-icon" data-section="debugSection">
                    <i class="fas fa-bug"></i>
                </div>
            </div>
            
            <div class="sidebar-content expanded" id="sidebarContent">
                <div class="settings-section active" id="bookInfoSection">
                    <div class="settings-header">
                        <h3><i class="fas fa-info-circle"></i>书籍信息</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="bookTitle">书名</label>
                            <input type="text" id="bookTitle" class="form-control" placeholder="例如：仙逆">
                        </div>
                        <div class="form-group">
                            <label for="bookAuthor">作者</label>
                            <input type="text" id="bookAuthor" class="form-control" placeholder="例如：耳根">
                        </div>
                        <div class="form-group">
                            <label>封面来源</label>
                            <div class="radio-group">
                                <div class="radio-option">
                                    <input type="radio" id="coverSearch" name="coverOption" value="search" checked>
                                    <label for="coverSearch">在线搜索</label> </div>
                                <div class="radio-option">
                                    <input type="radio" id="coverUpload" name="coverOption" value="upload">
                                    <label for="coverUpload">本地上传</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" id="coverNone" name="coverOption" value="none">
                                    <label for="coverNone">无封面</label>
                                </div>
                            </div>
                        </div>
                        
                        <div id="onlineSourceSelectionArea" class="form-group" style="display: none; margin-left: 20px;">
                            <label for="onlineSourceSelect">选择在线来源:</label>
                            <select id="onlineSourceSelect" class="form-control">
                                <option value="起点网" selected>起点小说 (小说类推荐)</option>
                                <option value="openlibrary">Open Library (综合/外文)</option>
                                <option value="googlebooks">Google Books (综合/需API Key)</option>
                                </select>
                        </div>
                        
                        <div id="coverUploadArea" style="display: none;">
                            <div class="form-group">
                                <button class="btn btn-secondary btn-sm btn-block" id="selectCoverBtn"> <i class="fas fa-upload"></i> 选择封面图片
                                </button>
                                <input type="file" id="coverInput" accept="image/*" hidden>
                                <p id="coverFileName" style="margin-top: 10px; display: none; font-size: 0.9rem; text-align: center;"></p>
                            </div>
                        </div>
                        
                        <div class="cover-preview-container" id="coverPreviewArea">
                            <img id="coverPreview" class="cover-preview" src="" alt="封面预览">
                            <div class="cover-navigation" id="coverNavigationControls" style="display: none;">
                                <button id="prevCoverBtn" class="cover-nav-btn"><i class="fas fa-chevron-left"></i></button>
                                <span id="coverIndicator">1 / 1</span>
                                <button id="nextCoverBtn" class="cover-nav-btn"><i class="fas fa-chevron-right"></i></button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="chapterSection">
                    <div class="settings-header">
                        <h3><i class="fas fa-cut"></i>内容与样式</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="chapterPattern">章节模式</label>
                            <select id="chapterPattern" class="form-control">
                                <option value="auto">自动识别</option>
                                <option value="chinese">中文 (第X章)</option>
                                <option value="english">英文 (Chapter X)</option>
                                <option value="numbered">数字 (1., 2.)</option>
                                <option value="custom">自定义正则</option>
                            </select>
                        </div>
                        <div id="customChapterArea" style="display: none;">
                            <div class="form-group">
                                <label for="customChapterPattern">自定义章节正则</label>
                                <input type="text" id="customChapterPattern" class="form-control" placeholder="^第[0-9一二三四五六七八九十零〇百千两 ]+[章]">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="volumePattern">卷/部模式</label>
                            <select id="volumePattern" class="form-control">
                                <option value="auto">自动识别</option>
                                <option value="chinese">中文 (第X卷/部)</option>
                                <option value="english">英文 (Volume/Book X)</option>
                                <option value="disabled">不识别</option>
                                <option value="custom">自定义正则</option>
                            </select>
                        </div>
                        <div id="customVolumeArea" style="display: none;">
                            <div class="form-group">
                                <label for="customVolumePattern">自定义卷/部正则</label>
                                <input type="text" id="customVolumePattern" class="form-control" placeholder="^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部]">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="indent">段落首行缩进 (em)</label>
                            <input type="number" id="indent" class="form-control" min="0" max="8" step="0.1" value="2">
                        </div>
                        <div class="form-group">
                            <label for="titleAlign">标题对齐</label>
                            <select id="titleAlign" class="form-control">
                                <option value="center">居中</option>
                                <option value="left">左对齐</option>
                                <option value="right">右对齐</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="paragraphSpacing">段间距</label>
                            <select id="paragraphSpacing" class="form-control">
                                <option value="1em">默认 (1em)</option>
                                <option value="0.5em">紧凑 (0.5em)</option>
                                <option value="1.5em">宽松 (1.5em)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="previewLineCountInput">TXT预览行数</label>
                            <input type="number" id="previewLineCountInput" class="form-control" min="50" max="2000" step="50" value="300">
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="debugSection">
                    <div class="settings-header">
                        <h3><i class="fas fa-cog"></i>调试选项</h3>
                    </div>
                    <div class="settings-body">
                        <div class="form-group">
                            <label for="debugMode">开启调试日志</label>
                            <select id="debugMode" class="form-control">
                                <option value="off">关闭</option>
                                <option value="on">开启</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="googleBooksApiKeyInput">Google Books API Key (可选)</label>
                            <input type="text" id="googleBooksApiKeyInput" class="form-control" placeholder="输入您的Google Books API Key">
                            <p style="font-size: 0.8rem; color: var(--memphis-dark); margin-top: 8px; line-height: 1.4;">
                                此API Key用于从 Google Books 获取封面。您可以在
                                <a href="https://console.cloud.google.com/apis/dashboard" target="_blank" rel="noopener noreferrer" style="color: var(--memphis-primary); text-decoration: underline;">Google Cloud Console</a>
                                创建和管理您的API Key。如果留空，Google Books封面搜索将不可用。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content" id="mainContent">
            <div class="content-card upload-area" id="uploadCard">
                <div class="drop-area" id="dropArea">
                    <h3>拖放或选择 <span class="file-format-badge">TXT</span> 文件</h3>
                    <p>将你的小说文本文件扔到这里来！</p>
                    <button class="btn btn-secondary" id="selectFileBtn"><i class="fas fa-folder-open"></i> 选择文件</button>
                    <input type="file" id="fileInput" accept=".txt" hidden>
                </div>

                <div id="fileInfo" style="display: none;">
                     <div class="config-summary" id="configSummary">
                        <div class="summary-container">
                            <div class="summary-text">
                                <h4>转换预览</h4>
                                <div id="configDetails">
                                    <p><strong>标题:</strong> <span id="summaryTitle">未设置</span></p>
                                    <p><strong>作者:</strong> <span id="summaryAuthor">未设置</span></p>
                                    <p><strong>封面:</strong> <span id="summaryCoverSourceText">起点网</span></p>
                                    <p><strong>大小:</strong> <span id="txtFileSize">N/A</span></p>
                                    <p><strong>编码:</strong> <span id="txtEncoding">检测中...</span></p>
                                </div>
                            </div>
                            <div class="summary-cover" id="summaryCoverContainer">
                                <img id="summaryCoverPreview" src="" alt="封面预览">
                                <div id="summaryCoverPlaceholder">等待封面...</div>
                                <button class="change-cover-btn" id="changeCoverInSummaryBtn" title="更换封面">
                                    <i class="fas fa-pen"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="filbt">
                        <div class="file-preview" id="txtPreview">
                            <div class="file-icon-and-details">
                                <i class="fas fa-file-alt"></i>
                                <div class="file-details">
                                    <h4 id="txtFileName">filename.txt</h4>
                                </div>
                            </div>
                            <div class="file-preview-actions">
                                <button type="button" class="icon-button" id="previewTxtBtn" title="预览文件内容">
                                    <i class="fas fa-eye"></i>
                                </button>
                                <button type="button" class="icon-button" id="removeTxtBtn" title="移除文件">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                        <button class="convert-btn" id="convertBtn">
                            <span class="convert-btn-text">开始转换!</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="content-card progress-area" id="progressCard" style="display: none;">
                <div class="loading-spinner"></div>
                <h3 id="progressTitle">正在施展魔法...</h3>
                <p id="progressStatus">请稍候，EPUB正在生成中！</p>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>

            <div class="content-card result-area" id="resultCard" style="display: none;">
                <i class="fas fa-check-circle result-icon"></i>
                <h3>转换成功!</h3>
                <p>你的EPUB文件已准备就绪！</p>
                
                <div class="result-card">
                    <h4 id="resultFileName"></h4>
                    <p id="resultFileSize"></p>
                    
                    <div class="result-actions">
                        <button class="btn btn-success" id="downloadBtn">
                            <i class="fas fa-download"></i> 下载EPUB
                        </button>
                        <button class="btn btn-outline" id="convertNewBtn">
                            <i class="fas fa-redo"></i> 再转一个
                        </button>
                    </div>
                </div>
            </div>

            <div class="debug-area" id="debugAreaDOM">
                <h3>调试日志</h3>
                <div class="debug-log" id="debugLog"></div>
            </div>
        </div>
    </div>
    <div id="customAlertModal" class="modal-overlay">
        <div class="modal-content memphis-modal">
            <div class="modal-header">
                <h4 id="customAlertTitle" class="modal-title-text">提示</h4>
                <button id="customAlertCloseBtn" class="modal-close-btn" title="关闭">&times;</button>
            </div>
            <div class="modal-body">
                <p id="customAlertMessage"></p>
            </div>
            <div class="modal-footer">
                <button id="customAlertOkBtn" class="btn btn-primary">确定</button>
            </div>
        </div>
    </div>
    <div id="txtPreviewModal" class="modal-overlay">
        <div class="modal-content memphis-modal" style="max-width: 80%; width: 750px; max-height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h4 id="txtPreviewModalTitle" class="modal-title-text">文件内容预览</h4>
                <button id="txtPreviewModalCloseBtn" class="modal-close-btn" title="关闭">&times;</button>
            </div>
            <div class="modal-body" style="flex-grow: 1; overflow-y: hidden; display: flex; flex-direction: column; padding-top:15px; padding-bottom:10px;">
                <pre id="txtPreviewContent" style="white-space: pre-wrap; word-wrap: break-word; flex-grow: 1; overflow-y: auto; background-color: var(--memphis-bg); padding: 15px; border: 2px solid var(--memphis-dark); border-radius: var(--border-radius); font-size: 0.9rem; line-height: 1.5;"></pre>
                <p id="txtPreviewInfo" style="font-size: 0.85rem; margin-top: 10px; text-align: center; color: var(--memphis-dark);"></p>
            </div>
            <div class="modal-footer" style="margin-top:15px;">
                <button id="txtPreviewModalOkBtn" class="btn btn-primary">关闭</button>
            </div>
        </div>
    </div>

    <!-- 由于夸克浏览器下载功能不支持，所以引导用户使用其他浏览器 -->
    <div id="browserCompatibilityMessage" style="display: none; position: fixed; top: 0; left: 0; width: 100%; background-color: var(--memphis-secondary); color: var(--memphis-dark); padding: 15px; text-align: center; z-index: 3000; border-bottom: var(--bold-border); box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        <p style="margin: 0 0 10px 0; font-size: 0.9rem;">
            检测到您可能正在使用夸克浏览器。为了获得最佳体验（特别是文件下载功能），建议您复制当前网址并在系统默认浏览器或其他主流浏览器（如Chrome、Edge、Firefox）中打开本站。
        </p>
        <button id="copyLinkBtn" class="btn btn-sm" style="background-color: var(--memphis-primary); color: var(--memphis-white); margin-right: 10px;">复制链接</button>
        <button id="continueInQuarkBtn" class="btn btn-sm btn-outline">继续在此浏览器使用</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const sidebar = document.getElementById('sidebar');
            const sidebarContent = document.getElementById('sidebarContent');
            const mainContent = document.getElementById('mainContent');
            const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
            const settingsSections = document.querySelectorAll('.settings-section');
            const sidebarIcons = document.querySelectorAll('.sidebar-icon');
            const dropArea = document.getElementById('dropArea');
            const fileInput = document.getElementById('fileInput');
            const selectFileBtn = document.getElementById('selectFileBtn');
            const fileInfo = document.getElementById('fileInfo');
            const txtPreview = document.getElementById('txtPreview');
            const txtFileName = document.getElementById('txtFileName');
            const txtFileSize = document.getElementById('txtFileSize');
            const txtEncoding = document.getElementById('txtEncoding');
            const removeTxtBtn = document.getElementById('removeTxtBtn');
            const previewTxtBtn = document.getElementById('previewTxtBtn');
            const bookTitle = document.getElementById('bookTitle');
            const bookAuthor = document.getElementById('bookAuthor');
            const chapterPattern = document.getElementById('chapterPattern');
            const volumePattern = document.getElementById('volumePattern');
            const customChapterArea = document.getElementById('customChapterArea');
            const customVolumeArea = document.getElementById('customVolumeArea');
            const customChapterPattern = document.getElementById('customChapterPattern');
            const customVolumePattern = document.getElementById('customVolumePattern');
            const coverUpload = document.getElementById('coverUpload');
            const coverSearch = document.getElementById('coverSearch');
            const coverNone = document.getElementById('coverNone');
            const onlineSourceSelectionArea = document.getElementById('onlineSourceSelectionArea');
            const onlineSourceSelect = document.getElementById('onlineSourceSelect');
            const coverUploadArea = document.getElementById('coverUploadArea');
            const coverPreviewArea = document.getElementById('coverPreviewArea');
            const coverPreview = document.getElementById('coverPreview');
            const selectCoverBtn = document.getElementById('selectCoverBtn');
            const coverInput = document.getElementById('coverInput');
            const coverFileName = document.getElementById('coverFileName');
            const summaryTitle = document.getElementById('summaryTitle');
            const summaryAuthor = document.getElementById('summaryAuthor');
            const summaryCoverSourceText = document.getElementById('summaryCoverSourceText');
            const summaryCoverPreview = document.getElementById('summaryCoverPreview');
            const summaryCoverPlaceholder = document.getElementById('summaryCoverPlaceholder');
            const changeCoverInSummaryBtn = document.getElementById('changeCoverInSummaryBtn');
            const coverNavigationControls = document.getElementById('coverNavigationControls');
            const prevCoverBtn = document.getElementById('prevCoverBtn');
            const nextCoverBtn = document.getElementById('nextCoverBtn');
            const coverIndicator = document.getElementById('coverIndicator');
            const indent = document.getElementById('indent');
            const titleAlign = document.getElementById('titleAlign');
            const paragraphSpacing = document.getElementById('paragraphSpacing');
            const debugAreaDOM = document.getElementById('debugAreaDOM');
            const debugLog = document.getElementById('debugLog');
            const debugMode = document.getElementById('debugMode');
            const uploadCard = document.getElementById('uploadCard');
            const progressCard = document.getElementById('progressCard');
            const resultCard = document.getElementById('resultCard');
            const convertBtn = document.getElementById('convertBtn');
            const progressTitle = document.getElementById('progressTitle');
            const progressStatus = document.getElementById('progressStatus');
            const progressBar = document.getElementById('progressBar');
            const resultFileName = document.getElementById('resultFileName');
            const resultFileSize = document.getElementById('resultFileSize');
            const downloadBtn = document.getElementById('downloadBtn');
            const convertNewBtn = document.getElementById('convertNewBtn');


            const txtPreviewModal = document.getElementById('txtPreviewModal');
            const txtPreviewModalTitle = document.getElementById('txtPreviewModalTitle');
            const txtPreviewContent = document.getElementById('txtPreviewContent');
            const txtPreviewInfo = document.getElementById('txtPreviewInfo');
            const txtPreviewModalCloseBtn = document.getElementById('txtPreviewModalCloseBtn');
            const txtPreviewModalOkBtn = document.getElementById('txtPreviewModalOkBtn');
            const previewLineCountInput = document.getElementById('previewLineCountInput')
            // ----------夸克浏览器--------
            const browserCompatibilityMessage = document.getElementById('browserCompatibilityMessage');
            const copyLinkBtn = document.getElementById('copyLinkBtn');
            const continueInQuarkBtn = document.getElementById('continueInQuarkBtn');

            function detectQuarkBrowserAndNotify() {
                const userAgent = navigator.userAgent || navigator.vendor || window.opera;
                // 夸克浏览器的User Agent通常包含 "Quark" 关键词
                // 需要更精确的检测可能比较复杂，但 "Quark" 是一个很好的初步指标
                if (/Quark/i.test(userAgent)) {
                    log('Quark browser detected. Displaying compatibility message.', 'info');
                    if (browserCompatibilityMessage) {
                        browserCompatibilityMessage.style.display = 'block';
                    }

                    if (copyLinkBtn) {
                        copyLinkBtn.addEventListener('click', () => {
                            const currentUrl = window.location.href;
                            navigator.clipboard.writeText(currentUrl)
                                .then(() => {
                                    showCustomAlert('链接已复制到剪贴板！请在其他浏览器中粘贴打开。', '复制成功', 'success');
                                    browserCompatibilityMessage.style.display = 'none'; // 可选：复制后隐藏提示
                                })
                                .catch(err => {
                                    log('Failed to copy link: ' + err, 'error');
                                    showCustomAlert('链接复制失败，请手动复制浏览器地址栏中的网址。', '复制失败', 'error');
                                });
                        });
                    }

                    if (continueInQuarkBtn) {
                        continueInQuarkBtn.addEventListener('click', () => {
                            if (browserCompatibilityMessage) {
                                browserCompatibilityMessage.style.display = 'none';
                            }
                            // 用户选择继续，可以记录一下或不再打扰
                            // 也可以在这里用localStorage记录用户已“忽略”此提示，本次会话不再显示
                            sessionStorage.setItem('ignoredQuarkWarning', 'true');
                        });
                    }

                    // 如果用户已经忽略过，本次会话不再显示
                    if (sessionStorage.getItem('ignoredQuarkWarning') === 'true') {
                        if (browserCompatibilityMessage) {
                            browserCompatibilityMessage.style.display = 'none';
                        }
                    }

                } else {
                    log('Not a Quark browser or UA string does not contain "Quark".', 'info');
                }
            }
            detectQuarkBrowserAndNotify();
        // ------- 夸克浏览器结束 --------


            // 在获取其他 DOM 元素的地方添加：
            const googleBooksApiKeyInput = document.getElementById('googleBooksApiKeyInput');

            // State Variables
            let selectedFile = null;
            let coverFile = null;
            let coverDataUrl = null; 
            let epubBlob = null;
            let detectedEncoding = null;
            let fileArrayBuffer = null;
            let processedText = null;
            let isSearchingCover = false;
            let onlineCoverResults = [];
            let currentOnlineCoverIndex = 0;
            // 在脚本的全局作用域或主函数作用域顶部定义
            const USER_SETTINGS_KEY = 'epubConverterUserSettings_v1'; // v1用于未来可能的结构升级

            // 确保在能访问到所有相关DOM元素引用的作用域内定义此函数
            function saveUserSettings() {
                if (typeof(Storage) === "undefined") {
                    log("浏览器不支持 localStorage，无法保存用户设置。", "warning");
                    showCustomAlert("浏览器不支持 localStorage，无法保存用户设置。但不会影响使用！");
                    return;
                }

                const settings = {
                    chapterPattern: chapterPattern?.value,
                    customChapterPattern: customChapterPattern?.value, // 始终保存，加载时根据chapterPattern决定是否应用
                    volumePattern: volumePattern?.value,
                    customVolumePattern: customVolumePattern?.value,   // 始终保存

                    coverOption: document.querySelector('input[name="coverOption"]:checked')?.value,
                    onlineSource: typeof onlineSourceSelect !== 'undefined' ? onlineSourceSelect?.value : '起点网', // 默认qidian

                    indent: indent?.value,
                    titleAlign: titleAlign?.value,
                    paragraphSpacing: paragraphSpacing?.value,

                    debugMode: debugMode?.value,
                    googleBooksApiKey: googleBooksApiKeyInput?.value // 仅在输入框存在时保存
                };

                try {
                    localStorage.setItem(USER_SETTINGS_KEY, JSON.stringify(settings));
                    log('用户偏好设置已保存。', 'info');
                } catch (e) {
                    log(`保存用户设置到 localStorage 失败: ${e.message}`, 'error');
                    // 可以考虑如果存储已满，提示用户
                }
            }

            /**
             * Shows the TXT preview modal.
             * @param {string} content - The text content to preview.
             * @param {string} fileName - The name of the file being previewed.
             * @param {number} totalLines - Total lines in the previewed content.
             * @param {number} previewLines - Number of lines requested for preview.
             */
            function showTxtPreviewModal(content, fileName, totalLines, previewLines) {
                if (!txtPreviewModal || !txtPreviewContent || !txtPreviewModalTitle || !txtPreviewInfo) {
                    console.warn("TXT Preview modal DOM elements not found.");
                    showCustomAlert("无法显示文件预览，预览组件丢失。", "预览错误", "error");
                    return;
                }

                txtPreviewModalTitle.textContent = `预览: ${fileName}`;
                txtPreviewContent.textContent = content;

                let infoText = `显示 ${Math.min(totalLines, previewLines)} 行`;
                if (totalLines > previewLines) {
                    infoText += ` (共 ${totalLines} 行)`;
                }
                txtPreviewInfo.textContent = infoText;

                txtPreviewModal.classList.add('visible');
                txtPreviewModalOkBtn.focus();
            }

            function hideTxtPreviewModal() {
                if (txtPreviewModal) {
                    const clearModalContent = () => {
                        if (txtPreviewContent) txtPreviewContent.textContent = '';
                        if (txtPreviewInfo) txtPreviewInfo.textContent = '';
                        log('TXT preview modal content cleared after transition.', 'debug');
                    };

                    const handleTransitionEnd = (event) => {
                        // Ensure the event is for the opacity transition on the modal itself
                        if (event.target === txtPreviewModal && event.propertyName === 'opacity') {
                            clearModalContent();
                        }
                    };

                    // Add the event listener with 'once: true' so it automatically removes itself after firing.
                    // This listens for the end of the CSS transition.
                    txtPreviewModal.addEventListener('transitionend', handleTransitionEnd, { once: true });

                    // Start the hiding transition by removing the 'visible' class.
                    // This should trigger the CSS opacity transition defined for .modal-overlay.
                    txtPreviewModal.classList.remove('visible');

                    // Fallback timeout in case transitionend doesn't fire for some reason
                    // (e.g., transitions disabled in browser, or element removed from DOM before transition ends).
                    // This timeout should be slightly longer than the CSS transition duration (e.g., 0.3s for opacity).
                    setTimeout(() => {
                        // Check if the content is still there; if so, transitionend likely didn't fire.
                        // The 'once: true' listener would have already run clearModalContent if it fired.
                        if (txtPreviewContent && txtPreviewContent.textContent !== '') {
                            log('Fallback: Clearing TXT preview modal content due to timeout.', 'debug');
                            clearModalContent();
                            // Manually remove the listener if the fallback is hit and 'once: true' didn't (highly unlikely but for safety).
                            txtPreviewModal.removeEventListener('transitionend', handleTransitionEnd);
                        }
                    }, 350); // CSS transition is 0.3s (300ms), so 350ms is a safe buffer.
                }
            }

            if (txtPreviewModalCloseBtn) {
                txtPreviewModalCloseBtn.addEventListener('click', hideTxtPreviewModal);
            }
            if (txtPreviewModalOkBtn) {
                txtPreviewModalOkBtn.addEventListener('click', hideTxtPreviewModal);
            }
            if (txtPreviewModal) {
                txtPreviewModal.addEventListener('click', (event) => {
                    if (event.target === txtPreviewModal) {
                        hideTxtPreviewModal();
                    }
                });
            }
            // Pressing Escape key to close the TXT preview modal
            document.addEventListener('keydown', (event) => {
                if (event.key === "Escape" && txtPreviewModal && txtPreviewModal.classList.contains('visible')) {
                    hideTxtPreviewModal();
                }
            });


            // Event listener for the TXT preview button
            if (previewTxtBtn) {
                previewTxtBtn.addEventListener('click', async () => {
                    if (!selectedFile) {
                        showCustomAlert('没有选择文件以供预览。', '预览提示', 'info');
                        return;
                    }
                    if (!fileArrayBuffer) {
                        showCustomAlert('文件内容尚未加载，请稍后再试。', '预览错误', 'error');
                        log('File ArrayBuffer is null, cannot preview.', 'error');
                        return;
                    }

                    try {
                        const lineCount = parseInt(previewLineCountInput.value, 10) || 300; // Default to 300 lines
                        log(`Attempting to preview ${lineCount} lines of ${selectedFile.name}`);

                        // Use the already detected encoding or default to UTF-8
                        const encodingToUse = detectedEncoding || 'UTF-8';
                        const decoder = new TextDecoder(encodingToUse, { fatal: false }); // fatal:false to avoid errors on partial multibyte chars at cut-off

                        // Decide how much of the buffer to decode for preview
                        // This is a rough estimation. For precise line counting, one would need to decode iteratively.
                        // Average bytes per line can vary greatly. Let's assume an average of 50-100 bytes per line for estimation.
                        // To be safe and performant, we might just decode a fixed large chunk initially.
                        const initialChunkSize = Math.min(fileArrayBuffer.byteLength, lineCount * 150); // Estimate 150 bytes per line
                        const textChunk = decoder.decode(fileArrayBuffer.slice(0, initialChunkSize));

                        const lines = textChunk.split('\n');
                        const previewContent = lines.slice(0, lineCount).join('\n');
                        const actualLinesInPreview = lines.slice(0, lineCount).length; // How many lines are actually in the preview string
                        const totalLinesInChunk = lines.length; // Total lines in the decoded chunk

                        // A more accurate total line count would require decoding the whole file,
                        // which might be slow for very large files. For preview, totalLinesInChunk is often sufficient.
                        // If initialChunkSize was less than fileArrayBuffer.byteLength, totalLinesInChunk is an underestimate of total file lines.

                        showTxtPreviewModal(previewContent, selectedFile.name, totalLinesInChunk, lineCount);

                    } catch (error) {
                        log(`Error during TXT preview: ${error.message}`, 'error');
                        showCustomAlert(`预览文件内容时发生错误: ${error.message}`, '预览失败', 'error');
                    }
                });
            }
            function loadUserSettings() {
                if (typeof(Storage) === "undefined") {
                    log("浏览器不支持 localStorage，无法加载用户设置。", "warning");
                    return;
                }

                try {
                    const savedSettingsString = localStorage.getItem(USER_SETTINGS_KEY);
                    if (!savedSettingsString) {
                        log('未找到已保存的用户设置。', 'info');
                        // 可在此处设置应用的默认值，如果它们与HTML中的默认值不同
                        // 例如: chapterPattern.value = 'auto'; toggleCoverOptions(); ...
                        return;
                    }

                    const settings = JSON.parse(savedSettingsString);
                    if (!settings) {
                        log('解析已保存的用户设置失败。', 'warning');
                        return;
                    }

                    log('正在加载用户偏好设置...', 'info');

                    // 应用章节设置
                    if (settings.chapterPattern && chapterPattern) chapterPattern.value = settings.chapterPattern;
                    if (settings.customChapterPattern && customChapterPattern) customChapterPattern.value = settings.customChapterPattern;
                    if (settings.volumePattern && volumePattern) volumePattern.value = settings.volumePattern;
                    if (settings.customVolumePattern && customVolumePattern) customVolumePattern.value = settings.customVolumePattern;

                    // 应用封面设置
                    if (settings.coverOption) {
                        const coverRadioToSelect = document.querySelector(`input[name="coverOption"][value="${settings.coverOption}"]`);
                        if (coverRadioToSelect) coverRadioToSelect.checked = true;
                    }
                    if (settings.onlineSource && typeof onlineSourceSelect !== 'undefined' && onlineSourceSelect) {
                        onlineSourceSelect.value = settings.onlineSource;
                    }

                    // 应用外观设置
                    if (settings.indent && indent) indent.value = settings.indent;
                    if (settings.titleAlign && titleAlign) titleAlign.value = settings.titleAlign;
                    if (settings.paragraphSpacing && paragraphSpacing) paragraphSpacing.value = settings.paragraphSpacing;

                    // 应用调试设置
                    if (settings.debugMode && debugMode) debugMode.value = settings.debugMode;
                    if (settings.googleBooksApiKey && googleBooksApiKeyInput) googleBooksApiKeyInput.value = settings.googleBooksApiKey;

                    // !!! 重要：应用设置后，需要手动触发一次依赖这些设置的UI更新函数 !!!
                    // 因为直接修改 .value 不会触发 'change' 事件

                    // 更新自定义正则区域的显示状态
                    if (chapterPattern && customChapterArea) {
                        customChapterArea.style.display = chapterPattern.value === 'custom' ? 'block' : 'none';
                    }
                    if (volumePattern && customVolumeArea) {
                        customVolumeArea.style.display = volumePattern.value === 'custom' ? 'block' : 'none';
                    }

                    toggleCoverOptions(); // 更新封面选项相关的UI（包括在线来源选择区的显示）
                    updateDebugArea();    // 根据加载的debugMode更新调试区域显示
                    // updateSummary(); // 概要信息主要依赖书名/作者/文件，这些不保存，所以此处可能不需要，除非概要中有其他受这些设置影响的项

                    log('用户偏好设置已加载并应用。', 'info');

                } catch (e) {
                    log(`从 localStorage 加载用户设置失败: ${e.message}`, 'error');
                    // 可选：如果解析失败或数据损坏，清除损坏的设置
                    // localStorage.removeItem(USER_SETTINGS_KEY);
                }
            }

            // --- Custom Alert Modal Logic ---
            const customAlertModal = document.getElementById('customAlertModal');
            const customAlertTitle = document.getElementById('customAlertTitle');
            const customAlertMessage = document.getElementById('customAlertMessage');
            const customAlertCloseBtn = document.getElementById('customAlertCloseBtn');
            const customAlertOkBtn = document.getElementById('customAlertOkBtn');
            const modalContentElement = customAlertModal ? customAlertModal.querySelector('.modal-content') : null;

            let onCustomAlertCloseCallback = null; // 用于处理关闭后的回调

            /**
             * 显示自定义模态框提示
             * @param {string} message - 要显示的消息内容
             * @param {string} [title="提示"] - 模态框标题
             * @param {string} [type="info"] - 模态框类型 ('info', 'error', 'warning', 'success')
             * @param {function} [onClose] - 模态框关闭时的回调函数
             */
            function showCustomAlert(message, title = "提示", type = "info", onClose = null) {
                if (!customAlertModal || !modalContentElement) {
                    // 如果模态框DOM不存在，则回退到原生alert
                    console.warn("Custom alert modal DOM not found. Falling back to native alert.");
                    alert(`${title}: ${message}`);
                    if (typeof onClose === 'function') {
                        onClose();
                    }
                    return;
                }

                customAlertTitle.textContent = title;
                customAlertMessage.innerHTML = message; // 使用 innerHTML 以支持简单的HTML标签如 <br>

                // 重置类型相关的class
                modalContentElement.classList.remove('modal-error', 'modal-warning', 'modal-info', 'modal-success');

                // 根据类型应用样式和默认标题
                switch (type.toLowerCase()) {
                    case 'error':
                        modalContentElement.classList.add('modal-error');
                        customAlertTitle.textContent = title === "提示" ? "发生错误" : title;
                        break;
                    case 'warning':
                        modalContentElement.classList.add('modal-warning');
                        customAlertTitle.textContent = title === "提示" ? "警告" : title;
                        break;
                    case 'success':
                        modalContentElement.classList.add('modal-success');
                        customAlertTitle.textContent = title === "提示" ? "操作成功" : title;
                        break;
                    case 'info':
                    default:
                        modalContentElement.classList.add('modal-info');
                        // 保持传入的title或默认的“提示”
                        break;
                }

                onCustomAlertCloseCallback = onClose; // 保存回调

                customAlertModal.classList.add('visible');
                customAlertOkBtn.focus(); // 方便键盘操作
            }

            function hideCustomAlert() {
                if (!customAlertModal) return;
                customAlertModal.classList.remove('visible');
                if (typeof onCustomAlertCloseCallback === 'function') {
                    onCustomAlertCloseCallback(); // 执行回调
                    onCustomAlertCloseCallback = null; // 清理回调，防止重复执行
                }
            }

            // 为模态框的关闭按钮和确定按钮添加事件监听
            if (customAlertCloseBtn) {
                customAlertCloseBtn.addEventListener('click', hideCustomAlert);
            }
            if (customAlertOkBtn) {
                customAlertOkBtn.addEventListener('click', hideCustomAlert);
            }

            // 点击模态框外部（遮罩层）关闭模态框
            if (customAlertModal) {
                customAlertModal.addEventListener('click', (event) => {
                    if (event.target === customAlertModal) { // 确保是点击遮罩本身，而非内容区域
                        hideCustomAlert();
                    }
                });
            }

            // (可选) 按下 Escape 键关闭模态框
            document.addEventListener('keydown', (event) => {
                if (event.key === "Escape" && customAlertModal && customAlertModal.classList.contains('visible')) {
                    hideCustomAlert();
                }
            });


            // Initialize
            initializeApp();

            function initializeApp() {
                setupUIEventListeners();
                setupFileEventListeners();
                setupSettingsEventListeners();
                setupConversionEventListeners();
                updateDebugArea();
                toggleCoverOptions();
                activateSection('bookInfoSection', document.querySelector('.sidebar-icon[data-section="bookInfoSection"]'));
                updateMainContentMargin(); 
            }

            // --- UI Event Listeners ---
            function setupUIEventListeners() {
                sidebarIcons.forEach(icon => {
                    icon.addEventListener('click', function() {
                        const sectionId = this.getAttribute('data-section');
                        const isCurrentlyActive = this.classList.contains('active');
                        const isSidebarContentCurrentlyExpanded = sidebarContent.classList.contains('expanded');

                        if (isCurrentlyActive && isSidebarContentCurrentlyExpanded) {
                            sidebarContent.classList.remove('expanded');
                            if(sidebarIcons) sidebarIcons.forEach(icon => icon.classList.remove('active'));
                        } else if (!isSidebarContentCurrentlyExpanded) {
                            sidebarContent.classList.add('expanded');
                            activateSection(sectionId, this);
                        } else if (!isCurrentlyActive && isSidebarContentCurrentlyExpanded){
                            activateSection(sectionId, this);
                        }
                        updateMainContentMargin();
                    });
                });

                if (toggleSidebarBtn) {
                    toggleSidebarBtn.addEventListener('click', function() {
                        if (sidebar) sidebar.classList.toggle('sidebar-visible');
                        if(sidebar && sidebar.classList.contains('sidebar-visible') && sidebarContent) {
                            sidebarContent.classList.add('expanded');
                             // If opening sidebar on mobile, ensure the first tab is active if none are
                            if (!document.querySelector('.sidebar-icon.active')) {
                                activateSection('bookInfoSection', document.querySelector('.sidebar-icon[data-section="bookInfoSection"]'));
                            }
                        }
                        updateMainContentMargin();
                    });
                }
                
                document.addEventListener('click', function(event) {
                    if (window.innerWidth <= 992) { 
                        if (sidebar && sidebar.classList.contains('sidebar-visible') && 
                            !sidebar.contains(event.target) && 
                            toggleSidebarBtn && !toggleSidebarBtn.contains(event.target)) {
                            sidebar.classList.remove('sidebar-visible');
                            updateMainContentMargin(); 
                        }
                    }
                    // This logic for closing sidebar on desktop was a bit aggressive.
                    // Commenting out for now, as it might interfere with interactions within the main content.
                    // else if (window.innerWidth > 992 && sidebarContent && sidebarContent.classList.contains('expanded')) {
                    //     if (!uploadCard.contains(event.target) && sidebarContent.classList.contains('expanded') && !sidebar.contains(event.target) && !mainContent.contains(event.target)) {
                    //         sidebarContent.classList.remove('expanded');
                    //         if(sidebarIcons) sidebarIcons.forEach(icon => icon.classList.remove('active'));
                    //         updateMainContentMargin(); 
                    //     }
                    // }
                });

                window.addEventListener('resize', handleResize);
                handleResize(); 

                if (changeCoverInSummaryBtn) {
                    changeCoverInSummaryBtn.addEventListener('click', (event) => { // 传入 event 对象
                        event.stopPropagation(); // 阻止事件冒泡
                        activateSection('bookInfoSection', document.querySelector('.sidebar-icon[data-section="bookInfoSection"]'));
                        if (window.innerWidth <= 992 && sidebar && !sidebar.classList.contains('sidebar-visible')) {
                            sidebar.classList.add('sidebar-visible');
                        }
                        if (sidebarContent && !sidebarContent.classList.contains('expanded')) {
                            sidebarContent.classList.add('expanded');
                        }
                        updateMainContentMargin();
                    });
                }
            }

            function toggleCoverOptions() {
                const coverSearchChecked = coverSearch && coverSearch.checked;
                const coverUploadChecked = coverUpload && coverUpload.checked;

                if (coverUploadArea) coverUploadArea.style.display = coverUploadChecked ? 'block' : 'none';
                if (coverPreviewArea) coverPreviewArea.style.display = (coverSearchChecked || coverUploadChecked) ? 'block' : 'none';

                // 新增逻辑: 控制在线来源选择区域的显示
                if (onlineSourceSelectionArea) {
                    onlineSourceSelectionArea.style.display = coverSearchChecked ? 'block' : 'none';
                }

                if (coverNone && coverNone.checked) {
                    if (coverPreview) { coverPreview.src = ''; coverPreview.style.display = 'none'; }
                    coverDataUrl = null;
                    onlineCoverResults = []; // (假设 qidianCoverResults 已重命名为 onlineCoverResults)
                    currentOnlineCoverIndex = 0; // (假设 currentOnlineCoverIndex 已重命名)
                }
                if (!coverUploadChecked) {
                    if(coverFileName) { coverFileName.textContent = ''; coverFileName.style.display = 'none'; }
                }
                updateCoverNavigation();
                updateSummary();
            }

            function activateSection(sectionId, iconElement) {
                const sectionElement = document.getElementById(sectionId);
                if (!sectionElement) {
                    log(`Section with ID ${sectionId} not found`, 'error');
                    return;
                }
                if(settingsSections) settingsSections.forEach(section => section.classList.remove('active'));
                if(sidebarIcons) sidebarIcons.forEach(icon => icon.classList.remove('active'));
                
                sectionElement.classList.add('active');
                if (iconElement) iconElement.classList.add('active');
                
                if (sidebarContent && !sidebarContent.classList.contains('expanded')) {
                    sidebarContent.classList.add('expanded');
                }
                 updateMainContentMargin(); // Call this after ensuring content is expanded
            }

            function handleResize() {
                if (window.innerWidth > 992) {
                    if (sidebar) sidebar.classList.remove('sidebar-visible');
                }
                updateMainContentMargin(); 
            }

            function updateMainContentMargin() {
                if (!mainContent || !sidebar || !sidebarContent) return;

                if (window.innerWidth > 992) { 
                    // Desktop: Margin depends on whether the detailed content panel is open
                    if (sidebarContent.classList.contains('expanded')) {
                        mainContent.style.marginLeft = `var(--sidebar-width)`;
                    } else {
                        mainContent.style.marginLeft = `var(--icons-width)`;
                    }
                } else { 
                    // Mobile: Margin depends on whether the icon bar itself is visible (sliding out)
                    // No margin needed if sidebar is hidden, icons-width if it's visible.
                    // The sidebarContent panel is always full width on mobile when expanded.
                     mainContent.style.marginLeft = '0px'; // Default for mobile when sidebar is hidden
                }
            }


            // --- File Handling ---
            function setupFileEventListeners() {
                if (!dropArea || !fileInput || !selectFileBtn || !removeTxtBtn) return;
                dropArea.addEventListener('click', (e) => { if (e.target !== selectFileBtn && !selectFileBtn.contains(e.target)) fileInput.click(); });
                selectFileBtn.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });
                fileInput.addEventListener('change', handleFileSelect);
                removeTxtBtn.addEventListener('click', (e) => { e.stopPropagation(); removeFile(); });
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => dropArea.addEventListener(ev, preventDefaults, false));
                ['dragenter', 'dragover'].forEach(ev => dropArea.addEventListener(ev, highlight, false));
                ['dragleave', 'drop'].forEach(ev => dropArea.addEventListener(ev, unhighlight, false));
                dropArea.addEventListener('drop', handleDrop, false);
            }
            function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
            function highlight() { if (dropArea) dropArea.classList.add('active'); }
            function unhighlight() { if (dropArea) dropArea.classList.remove('active'); }
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    let txtFileFound = false;
                    for (let i = 0; i < files.length; i++) {
                        if (files[i].name.toLowerCase().endsWith('.txt')) {
                            const dataTransfer = new DataTransfer(); dataTransfer.items.add(files[i]); fileInput.files = dataTransfer.files;
                            handleFileSelect(); txtFileFound = true; break;
                        }
                    }
                    if (coverUpload && coverUpload.checked) {
                        for (let i = 0; i < files.length; i++) {
                            if (files[i].type.startsWith('image/')) {
                                const dataTransfer = new DataTransfer(); dataTransfer.items.add(files[i]); coverInput.files = dataTransfer.files;
                                handleCoverSelect(); break;
                            }
                        }
                    }
                    if (!txtFileFound) log('No .txt file found in dropped files.', 'warning');
                }
            }

            // 在 handleFileSelect 函数中
            async function handleFileSelect() {
                if (fileInput.files.length > 0) {
                    selectedFile = fileInput.files[0];
                    if (!selectedFile.name.toLowerCase().endsWith('.txt')) {
                        log('错误: 不是 .txt 文件', 'error');
                        showCustomAlert('请选择一个有效的 .txt 文件。', '文件类型错误', 'error');
                        removeFile(); // removeFile 函数会重置 UI
                        return;
                    }

                    // 更新UI显示文件名和大小
                    if (txtFileName) txtFileName.textContent = selectedFile.name;
                    if (txtFileSize) txtFileSize.textContent = formatFileSize(selectedFile.size);
                    if (txtPreview) txtPreview.style.display = 'flex';
                    if (fileInfo) fileInfo.style.display = 'block';
                    if (dropArea) dropArea.style.display = 'none';
                    if (txtEncoding) txtEncoding.textContent = '检测中...';

                    try {
                        // 1. 读取文件为 ArrayBuffer (已有逻辑)
                        fileArrayBuffer = await readFileAsArrayBuffer(selectedFile);

                        // 2. 检测文件编码 (已有逻辑)
                        const encodingInfo = await detectEncoding(selectedFile); // detectEncoding 内部已设置 fileArrayBuffer
                        detectedEncoding = encodingInfo.encoding;
                        if (txtEncoding) txtEncoding.textContent = `${encodingInfo.encoding}`;
                        log(`检测到编码: ${encodingInfo.encoding} 置信度 ${Math.round(encodingInfo.confidence * 100)}%`);

                        // 3. 首先尝试从文件名提取书名和作者 (您原有的 extractTitleAuthor 函数会直接修改 DOM 元素)
                        extractTitleAuthor(selectedFile.name); // 这个函数会设置 bookTitle.value 和 bookAuthor.value


                        // 4. 解码文件头部的一小部分文本样本
                        const textSample = await decodeSampleText(fileArrayBuffer, detectedEncoding);

                        // 5. 尝试从文本内容中提取书名和作者
                        if (textSample) {
                            const contentMeta = extractTitleAuthorFromContent(textSample);
                            if (!bookTitle.value && contentMeta.title) {
                                bookTitle.value = contentMeta.title; // 用内容提取的结果覆盖
                                log(`从内容中提取到书名并更新: "${contentMeta.title}"`);
                            }
                            if (!bookAuthor.value && contentMeta.author) {
                                bookAuthor.value = contentMeta.author; // 用内容提取的结果覆盖
                                log(`从内容中提取到作者并更新: "${contentMeta.author}"`);
                            }
                        }

                        // 6. 更新摘要信息和触发封面搜索 (已有逻辑)
                        updateSummary();
                        if (coverSearch && coverSearch.checked) {
                            searchOnlineCover();
                        }
                    } catch (error) {
                        log(`处理文件选择时出错: ${error.message}`, 'error');
                        showCustomAlert(`处理文件失败: ${error.message}`, '处理错误', 'error');
                        if (txtEncoding) txtEncoding.textContent = '错误';
                        // 即使出错，也尝试用文件名提取一次（如果之前没做或想重试）
                        extractTitleAuthor(selectedFile.name); // 确保至少有基于文件名的尝试
                        updateSummary(); // 更新摘要显示
                    }
                }
            }
            function handleCoverSelect() {
                if (coverInput.files.length > 0) {
                    coverFile = coverInput.files[0];
                    if (!coverFile.type.startsWith('image/')) {
                        log('Error: Not an image file', 'error'); showCustomAlert('请选择一个有效的图片文件。', '文件类型错误', 'error');
                        coverFile = null; coverInput.value = ''; if(coverFileName) coverFileName.textContent = ''; if(coverFileName) coverFileName.style.display = 'none'; if(coverPreview) coverPreview.src = ''; if(coverPreview) coverPreview.style.display = 'none'; 
                        onlineCoverResults = []; currentOnlineCoverIndex = 0; updateCoverNavigation();
                        updateSummary(); return;
                    }
                    if(coverFileName) coverFileName.textContent = `已选择: ${coverFile.name}`; if(coverFileName) coverFileName.style.display = 'block';
                    const reader = new FileReader();
                    reader.onload = (e) => { 
                        coverDataUrl = e.target.result; 
                        onlineCoverResults = []; currentOnlineCoverIndex = 0; // Reset Qidian search if local is chosen
                        updateCoverNavigation(); // Hide Qidian nav
                        if(coverPreview) { coverPreview.src = coverDataUrl; coverPreview.style.display = 'block';} 
                        updateSummary(); 
                        log('Local cover image loaded.'); 
                    };
                    reader.onerror = (error) => { log(`Error reading cover file: ${error}`, 'error'); coverDataUrl = null; updateSummary(); };
                    reader.readAsDataURL(coverFile);
                }
            }
            function removeFile() {
                selectedFile = null; fileArrayBuffer = null; processedText = null; epubBlob = null; detectedEncoding = null;
                if (fileInput) fileInput.value = ''; if (txtPreview) txtPreview.style.display = 'none'; if (fileInfo) fileInfo.style.display = 'none'; if (dropArea) dropArea.style.display = 'block'; if (txtFileName) txtFileName.textContent = ''; if (txtFileSize) txtFileSize.textContent = ''; if (txtEncoding) txtEncoding.textContent = '';
                coverFile = null; coverDataUrl = null; if (coverInput) coverInput.value = ''; if (coverFileName) { coverFileName.textContent = ''; coverFileName.style.display = 'none'; } if (coverPreview) { coverPreview.src = ''; coverPreview.style.display = 'none'; }
                onlineCoverResults = []; currentOnlineCoverIndex = 0; updateCoverNavigation();
                if (bookTitle) bookTitle.value = ''; if (bookAuthor) bookAuthor.value = '';
                updateSummary(); log('File and associated data cleared.');
            }

            // --- Settings Logic ---
            function setupSettingsEventListeners() {
                const coverOptionRadios = document.querySelectorAll('input[name="coverOption"]');
                coverOptionRadios.forEach(radio => radio.addEventListener('change', () => { 
                    toggleCoverOptions(); 
                    if (selectedFile && coverSearch && coverSearch.checked) {
                        searchOnlineCover(); 
                    } else if (coverSearch && !coverSearch.checked) {
                        onlineCoverResults = []; // Clear Qidian results if not active
                        currentOnlineCoverIndex = 0;
                        if (!coverUpload.checked || !coverFile) { // If not uploading or no file, clear preview
                             coverDataUrl = null;
                        }
                        updateCoverNavigation();
                    }
                    updateSummary();
                    saveUserSettings(); // Save the selected cover option 
                }));
                if (selectCoverBtn && coverInput) { selectCoverBtn.addEventListener('click', () => coverInput.click()); coverInput.addEventListener('change', handleCoverSelect); }
                if (bookTitle) bookTitle.addEventListener('input', updateSummary);
                if (bookAuthor) bookAuthor.addEventListener('input', updateSummary);
                // 更简洁的方式：将需要监听的元素放入数组统一处理
                const settingsToTrack = [
                    // Selects
                    chapterPattern, volumePattern, titleAlign, paragraphSpacing, debugMode,
                    (typeof onlineSourceSelect !== 'undefined' ? onlineSourceSelect : null), // 条件性添加
                    // Inputs (text/number)
                    customChapterPattern, customVolumePattern, indent
                ].filter(el => el != null); // 过滤掉可能未定义的元素

                settingsToTrack.forEach(element => {
                    const eventType = (element.tagName === 'INPUT' && (element.type === 'text' || element.type === 'number')) || element.tagName === 'TEXTAREA'
                                    ? 'input'
                                    : 'change';
                    element.addEventListener(eventType, () => {
                        // 特定于元素更改的UI更新逻辑 (如果未在其他地方处理)
                        if (element === chapterPattern && customChapterArea) {
                            customChapterArea.style.display = element.value === 'custom' ? 'block' : 'none';
                        }
                        if (element === volumePattern && customVolumeArea) {
                            customVolumeArea.style.display = element.value === 'custom' ? 'block' : 'none';
                        }
                        if (element === debugMode) {
                            updateDebugArea();
                        }
                        updateSummary(); // 根据需要决定是否在此处统一调用，或在各元素自己的逻辑中调用
                        saveUserSettings();
                    });
                });

                if (prevCoverBtn) prevCoverBtn.addEventListener('click', () => navigateQidianCovers(-1));
                if (nextCoverBtn) nextCoverBtn.addEventListener('click', () => navigateQidianCovers(1));
                // 在 setupSettingsEventListeners 函数内
                if (onlineSourceSelect) {
                    onlineSourceSelect.addEventListener('change', () => {
                        // 如果当前封面选项是在线搜索，且有书名，则重新搜索
                        if (coverSearch.checked && selectedFile && bookTitle.value) {
                            searchOnlineCover(); // 这是重构后的主要搜索函数
                        }
                        updateSummary(); // 更新概要中显示的封面来源文字
                        saveUserSettings(); // 保存用户设置
                    });
                }
                if (googleBooksApiKeyInput) {
                    googleBooksApiKeyInput.addEventListener('input', () => {
                        saveUserSettings();
                        updateGoogleBooksOptionStatus(); // 当API Key更改时，也更新选项状态
                    });
                }
            }

            // 原 searchQidianCover 函数需要重构/替换为此函数
            async function searchOnlineCover() {
                if (isSearchingCover) { log('Cover search already in progress.', 'info'); return; }
                const bookname = bookTitle.value;
                if (!bookname) {
                    log('Cannot search for cover: No book title provided.', 'warning');
                    if (coverPreview) { coverPreview.src = ''; coverPreview.style.display = 'none'; }
                    coverDataUrl = null;
                    onlineCoverResults = [];
                    currentOnlineCoverIndex = 0;
                    updateCoverNavigation();
                    updateSummary();
                    return;
                }

                isSearchingCover = true;
                if (convertBtn) convertBtn.disabled = true; // 保持原有逻辑
                const searchingPlaceholder = 'https://placehold.co/150x225/e9ecef/6c757d?text=Searching...';
                if (coverPreview) { coverPreview.src = searchingPlaceholder; coverPreview.style.display = 'block'; }

                onlineCoverResults = []; // 清空之前的任何来源的结果
                currentOnlineCoverIndex = 0;
                updateCoverNavigation(); // 先隐藏导航，除非有结果
                updateSummary(); // 更新概要，可能显示“搜索中”

                const currentSource = onlineSourceSelect.value; // 获取用户选择的来源
                log(`搜索封面: "${bookname}" 使用: ${currentSource}`);

                try {
                    switch (currentSource) {
                        case '起点网':
                            await fetchQidianCoversInternal(bookname); // 提取出的起点特定逻辑
                            break;
                        case 'openlibrary':
                            await fetchOpenLibraryCoversInternal(bookname); // 新的Open Library逻辑
                            break;
                        case 'googlebooks':
                            await fetchGoogleBooksCoversInternal(bookname); // 新的Google Books逻辑
                            break;
                        default:
                            log(`Unknown online source selected: ${currentSource}`, 'warning');
                            throw new Error(`未知的在线封面来源: ${currentSource}`);
                    }

                    if (onlineCoverResults.length > 0) {
                        displayCurrentOnlineCover(); // 重命名的显示函数
                    } else {
                        log('No cover images found from selected source.', 'info');
                        const noResultsPlaceholder = `https://placehold.co/150x225/e9ecef/6c757d?text=No+Results+from+${currentSource.charAt(0).toUpperCase() + currentSource.slice(1)}`;
                        if (coverPreview) { coverPreview.src = noResultsPlaceholder; coverPreview.style.display = 'block'; }
                        coverDataUrl = null; // 确保没有旧的 coverDataUrl 残留
                    }

                } catch (error) {
                    log(`Online cover search error (${currentSource}): ${error.message}`, 'error');
                    coverDataUrl = null;
                    const errorPlaceholder = `https://placehold.co/150x225/ef476f/ffffff?text=Error+(${currentSource.charAt(0).toUpperCase() + currentSource.slice(1)})`;
                    if (coverPreview) { coverPreview.src = errorPlaceholder; coverPreview.style.display = 'block'; }
                } finally {
                    isSearchingCover = false;
                    if (convertBtn) convertBtn.disabled = !selectedFile; // 保持原有逻辑
                    updateCoverNavigation(); // 根据是否有结果更新导航按钮
                    updateSummary();
                }
            }

            async function fetchQidianCoversInternal(bookname) {
                // const corsProxy = 'https://corsproxy.io/?'; 
                // const targetUrl = encodeURIComponent(`https://m.qidian.com/soushu/${encodeURIComponent(bookname)}.html`); 
                // const proxyUrl = corsProxy + targetUrl;
                // log(`Connecting to Qidian search URL: ${proxyUrl}`); // Log proxied URL
                // const netlifyCorsProxy = 'https://cors-anywhere.herokuapp.com/'; // 备用代理
                // const proxyUrlFallback = netlifyCorsProxy + targetUrl; // 备用代理URL
                const netlifyFunctionUrl = `/.netlify/functions/fetch-qidian?bookname=${encodeURIComponent(bookname)}`;
                log(`正在获取起点数据...`);
                

                const response = await fetch(netlifyFunctionUrl); 
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: "无法解析错误响应" }));
                    throw new Error(`Netlify函数调用失败 (状态 ${response.status}): ${errorData.error || response.statusText}`);
                }
                const htmlContent = await response.text(); 
                log('成功接收到封面数据！');

                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                const imageElements = doc.querySelectorAll('.y-list__item img[data-src]'); // More specific selectors
                
                onlineCoverResults = [];
                imageElements.forEach(img => {
                    let rawUrl = img.dataset.src || img.getAttribute('data-src');
                    if (rawUrl) {
                        if (rawUrl.startsWith('//')) {
                            rawUrl = 'https:' + rawUrl;
                        }
                        // Attempt to get a larger image if a pattern like /150 or /180 is at the end
                        let largeUrl = rawUrl.replace(/\/(150|180|90|100|120)$/, '/600');
                        if (!onlineCoverResults.includes(largeUrl)) { // Avoid duplicates if regex isn't perfect
                            onlineCoverResults.push(largeUrl);
                        }
                    }
                });
            }

            async function fetchOpenLibraryCoversInternal(bookname) {
                const searchUrl = `https://openlibrary.org/search.json?q=${encodeURIComponent(bookname)}&fields=key,title,author_name,cover_i,isbn&limit=10`; // 限制结果数量
                log(`Workspaceing from Open Library: ${searchUrl}`);
                const response = await fetch(searchUrl);
                if (!response.ok) throw new Error(`Open Library search failed: ${response.statusText}`);
                const data = await response.json();
                if (data.docs && data.docs.length > 0) {
                    for (const doc of data.docs) {
                        if (doc.cover_i) {
                            onlineCoverResults.push(`https://covers.openlibrary.org/b/id/${doc.cover_i}-L.jpg`);
                        } else if (doc.isbn && doc.isbn.length > 0) {
                            // Try with first ISBN that might have a cover
                            onlineCoverResults.push(`https://covers.openlibrary.org/b/isbn/${doc.isbn[0]}-L.jpg`);
                        }
                    }
                }
                // 过滤掉可能无效的URL或添加错误处理以验证图片是否存在
                // (可选: 使用 checkImageExists 或类似的逻辑来验证图片URL是否真的有效)
                log(`Open Library: Found ${onlineCoverResults.length} potential cover(s).`);
            }

            async function fetchGoogleBooksCoversInternal(bookname) {
                const userApiKey = googleBooksApiKeyInput ? googleBooksApiKeyInput.value.trim() : "";

                if (!userApiKey) {
                    log("Google Books API Key 未在设置中配置。将跳过 Google Books 搜索。", "warning");
                    // 通知用户API Key缺失，所以Google Books源不可用
                    showCustomAlert("Google Books 封面搜索需要您在“调试选项”中配置有效的API Key。", "API Key缺失", "warning");
                    // 清空可能存在的旧结果，并直接返回
                    onlineCoverResults = []; // 确保结果数组被清空
                    // 注意：这里不抛出错误，而是静默失败，searchOnlineCover 会处理无结果的情况
                    return;
                }

                const searchUrl = `https://www.googleapis.com/books/v1/volumes?q=intitle:${encodeURIComponent(bookname)}&key=${userApiKey}&maxResults=10`;
                log(`Workspaceing from Google Books with user API Key: ${searchUrl}`);

                try {
                    const response = await fetch(searchUrl);
                    if (!response.ok) {
                        // 如果API Key无效或服务有问题，Google API会返回错误
                        const errorData = await response.json().catch(() => null); // 尝试解析错误详情
                        let errorMessage = `Google Books API请求失败: ${response.status} ${response.statusText}`;
                        if (errorData && errorData.error && errorData.error.message) {
                            errorMessage += `\n详情: ${errorData.error.message}`;
                            if (errorData.error.errors && errorData.error.errors[0] && errorData.error.errors[0].reason === 'keyInvalid') {
                                showCustomAlert("您提供的 Google Books API Key 无效或权限不足。请检查您的API Key设置。", "API Key无效", "error");
                            }
                        }
                        throw new Error(errorMessage);
                    }
                    const data = await response.json();
                    if (data.items && data.items.length > 0) {
                        for (const item of data.items) {
                            if (item.volumeInfo && item.volumeInfo.imageLinks) {
                                const links = item.volumeInfo.imageLinks;
                                const coverUrl = links.large || links.medium || links.thumbnail || links.smallThumbnail || links.small || links.extraLarge;
                                if (coverUrl) {
                                    onlineCoverResults.push(coverUrl.replace(/^http:/, 'https:'));
                                }
                            }
                        }
                    }
                    log(`Google Books: Found ${onlineCoverResults.length} potential cover(s).`);
                } catch (error) {
                    log(`Error fetching from Google Books: ${error.message}`, 'error');
                    // 可以在此处决定是否向用户显示一个更通用的错误，因为具体的API Key无效错误已在上面处理
                    // showCustomAlert(`从Google Books获取封面失败：<br>${error.message}`, "Google Books错误", "error");
                    onlineCoverResults = []; // 确保出错时清空结果
                    // 不再向上抛出错误，让 searchOnlineCover 处理空结果的情况
                }
            }

            function updateGoogleBooksOptionStatus() {
                if (!onlineSourceSelect || !googleBooksApiKeyInput) return;

                const googleBooksOption = onlineSourceSelect.querySelector('option[value="googlebooks"]');
                if (!googleBooksOption) return; // 如果HTML中没有这个选项，则跳过

                const apiKey = googleBooksApiKeyInput.value.trim();

                if (!apiKey) {
                    googleBooksOption.textContent = "Google Books (需API Key)";
                    // 可选：如果当前选中的就是Google Books且没有API Key，可以提示用户或切换到默认源
                    if (onlineSourceSelect.value === 'googlebooks' && coverSearch.checked) {
                        // 避免在仅仅加载设置时就弹出alert，这个逻辑可能需要更细致地放在用户尝试搜索时
                        // log("Google Books selected but no API key.", "warning");
                    }
                } else {
                    googleBooksOption.textContent = "Google Books (已配置Key)"; // 或者只显示 "Google Books"
                }
            }

            // 在 initializeApp 末尾，以及 loadUserSettings 末尾调用一次 updateGoogleBooksOptionStatus()
            // 也在 googleBooksApiKeyInput 的 'input' 事件监听器中调用它。

            function displayCurrentOnlineCover() {
                if (onlineCoverResults.length > 0 && coverSearch.checked) {
                    coverDataUrl = onlineCoverResults[currentOnlineCoverIndex];
                    if (coverPreview) {
                        coverPreview.src = ''; // Clear src first to ensure onload fires for same URL if re-selected
                        coverPreview.src = coverDataUrl;
                        coverPreview.style.display = 'block';

                        // Add error handling for individual image load
                        coverPreview.onerror = () => {
                            log(`Failed to load image: ${coverDataUrl}`, 'error');
                            coverPreview.src = 'https://placehold.co/150x225/f0f0f0/cc0000?text=Load+Error'; // Show load error
                            // Optionally, try to remove this image from results and move to next
                            // onlineCoverResults.splice(currentOnlineCoverIndex, 1);
                            // if (currentOnlineCoverIndex >= onlineCoverResults.length) currentOnlineCoverIndex = 0;
                            // if (onlineCoverResults.length > 0) displayCurrentOnlineCover(); else updateCoverNavigation();
                        };
                    }
                    log(`Displaying ${onlineSourceSelect.options[onlineSourceSelect.selectedIndex].text.split(' (')[0]} cover ${currentOnlineCoverIndex + 1} of ${onlineCoverResults.length}: ${coverDataUrl}`);
                } else if (!coverUpload.checked || !coverFile) { // If not Qidian and no local upload
                    coverDataUrl = null;
                    if (coverPreview) {
                        coverPreview.src = '';
                        coverPreview.style.display = 'none';
                    }
                }
                // If coverUpload is checked and coverFile exists, coverDataUrl is already set by handleCoverSelect
                updateCoverNavigation();
                updateSummary();
            }

            function navigateQidianCovers(direction) {
                if (!coverSearch.checked || onlineCoverResults.length === 0) return;

                currentOnlineCoverIndex += direction;

                if (currentOnlineCoverIndex < 0) {
                    currentOnlineCoverIndex = onlineCoverResults.length - 1;
                } else if (currentOnlineCoverIndex >= onlineCoverResults.length) {
                    currentOnlineCoverIndex = 0;
                }
                displayCurrentOnlineCover();
            }

            function updateCoverNavigation() {
                if (coverSearch.checked && onlineCoverResults.length > 0) {
                    if (coverNavigationControls) coverNavigationControls.style.display = 'flex';
                    if (coverIndicator) coverIndicator.textContent = `${currentOnlineCoverIndex + 1} / ${onlineCoverResults.length}`;
                    if (prevCoverBtn) prevCoverBtn.disabled = onlineCoverResults.length <= 1;
                    if (nextCoverBtn) nextCoverBtn.disabled = onlineCoverResults.length <= 1;
                } else {
                    if (coverNavigationControls) coverNavigationControls.style.display = 'none';
                }
            }


            function checkImageExists(url) { 
                 return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Image not found or failed to load from URL: ' + url));
                    img.src = url;
                });
            }
            function updateSummary() {
                if (summaryTitle) summaryTitle.textContent = bookTitle?.value || '未设置';
                if (summaryAuthor) summaryAuthor.textContent = bookAuthor?.value || '未设置';
                
                let coverSourceTextVal = '无封面';
                if (coverUpload?.checked && coverFile) {
                    coverSourceTextVal = '本地上传';
                } else if (coverSearch?.checked) {
                    // 获取当前选中的在线来源的显示文本
                    const selectedOption = onlineSourceSelect.options[onlineSourceSelect.selectedIndex];
                    coverSourceTextVal = selectedOption ? selectedOption.text.split(' (')[0] : '在线搜索'; // 例如 "起点小说" 或 "Open Library"
                }
                if (summaryCoverSourceText) summaryCoverSourceText.textContent = coverSourceTextVal;
                if (summaryCoverPreview && summaryCoverPlaceholder) {
                    let currentDisplaySrc = null;

                    if (coverUpload?.checked && coverFile && coverDataUrl?.startsWith('data:')) {
                         currentDisplaySrc = coverDataUrl;
                    } else if (coverSearch?.checked && onlineCoverResults.length > 0) {
                         currentDisplaySrc = onlineCoverResults[currentOnlineCoverIndex];
                    } else if (coverSearch?.checked && coverDataUrl && !coverDataUrl.includes('placehold.co') && onlineCoverResults.length === 0) {
                        // This case handles if a single coverDataUrl was set before multiple results logic
                        currentDisplaySrc = coverDataUrl;
                    }


                    if (currentDisplaySrc && !currentDisplaySrc.includes('placehold.co')) {
                        summaryCoverPreview.src = currentDisplaySrc;
                        summaryCoverPreview.style.display = 'block';
                        summaryCoverPlaceholder.style.display = 'none';
                    } else if (isSearchingCover && coverSearch?.checked) {
                        summaryCoverPreview.src = 'https://placehold.co/150x225/e9ecef/6c757d?text=Searching...';
                        summaryCoverPreview.style.display = 'block'; // Show searching placeholder
                        summaryCoverPlaceholder.style.display = 'none';
                    }
                     else {
                        summaryCoverPreview.src = '';
                        summaryCoverPreview.style.display = 'none';
                        summaryCoverPlaceholder.textContent = (coverNone?.checked) ? '无封面' : '等待封面...';
                        summaryCoverPlaceholder.style.display = 'block';
                    }
                }
            }

            // --- Conversion Logic ---
            function setupConversionEventListeners() { 
                if (convertBtn) convertBtn.addEventListener('click', startConversion);
                if (downloadBtn) downloadBtn.addEventListener('click', downloadEpub);
                if (convertNewBtn) convertNewBtn.addEventListener('click', resetConverter);
            }
            function updateProgressBarUI(percentage, statusText) {
                if (progressBar) { // progressBar 是全局获取的DOM元素
                    progressBar.style.width = `${Math.min(100, Math.max(0, percentage.toFixed(1)))}%`;
                }
                if (progressStatus) { // progressStatus 是全局获取的DOM元素
                    progressStatus.textContent = statusText;
                }
                log(`Progress: ${percentage.toFixed(1)}% - ${statusText}`, 'info'); // 调试日志
            }

            async function startConversion() { 
                if (!selectedFile) { showCustomAlert('请先选择一个 TXT 文件，然后再开始转换。', '操作提示', 'warning'); return; }
                const title = bookTitle?.value || '未知标题'; const author = bookAuthor?.value || '未知作者'; const language = 'zh-CN';
                const options = {
                    title, author, language,
                    chapterPattern: getChapterPatternRegex(), volumePattern: getVolumePatternRegex(),
                    maxTitleLength: 35, unknownTitleName: '章节',
                    indent: parseFloat(indent?.value) || 2, titleAlign: titleAlign?.value || 'center', fontFamily: 'default',
                    fontSize: '1em', lineHeight: '1.6', paragraphSpacing: paragraphSpacing?.value || '1em',
                    minEmptyLinesForFallbackTitle: 2, fallbackTitleMaxLength: 20
                };
                if (uploadCard) uploadCard.style.display = 'none'; if (debugAreaDOM) debugAreaDOM.style.display = (debugMode?.value === 'on') ? 'block' : 'none'; if (progressCard) progressCard.style.display = 'block'; if (convertBtn) convertBtn.disabled = true;
                updateProgressBarUI(0, '正在初始化...'); 
                try {
                    let text; if (!fileArrayBuffer && selectedFile) { log('File ArrayBuffer not found, reading file again.', 'warning'); fileArrayBuffer = await readFileAsArrayBuffer(selectedFile); } if (!fileArrayBuffer) throw new Error("无法读取文件内容。");
                    updateProgressBarUI(2, '文件读取完毕...');
                    text = await decodeText(fileArrayBuffer, detectedEncoding || 'UTF-8');updateProgressBarUI(10, '文件解码完成...'); text = cleanText(text); text=removeMetadataLinesFromContent(text, title, author); text = "\n\n" + text;updateProgressBarUI(20, '文件内容准备就绪...');
                    processedText = processText(text, options); updateProgressBarUI(35, `书籍结构分析完毕: 共 ${countSections(processedText)} 章节/卷`);
                    
                    let finalCoverDataUrl = null;const coverProgressStart = 35; const coverProgressEnd = 45; 
                    if (coverUpload?.checked && coverFile) { 
                        updateProgressBarUI(coverProgressStart, '正在处理本地封面...');finalCoverDataUrl = await readFileAsDataURL(coverFile); updateProgressBarUI(coverProgressEnd, '本地封面处理完毕.');
                    } else if (coverSearch?.checked && onlineCoverResults.length > 0) {
                        updateProgressBarUI(coverProgressStart, '正在处理在线封面...');const selectedQidianUrl = onlineCoverResults[currentOnlineCoverIndex];
                        if (selectedQidianUrl) {
                            if (selectedQidianUrl.startsWith('http')) finalCoverDataUrl = await fetchImageAsDataURL(selectedQidianUrl);
                            else if (selectedQidianUrl.startsWith('data:')) finalCoverDataUrl = selectedQidianUrl; // Should not happen for Qidian
                        }
                    } else if (coverSearch?.checked && coverDataUrl && !coverDataUrl.includes('placehold.co')) {
                         // Fallback for single coverDataUrl if onlineCoverResults is empty but a valid URL exists
                         if (coverDataUrl.startsWith('http')) finalCoverDataUrl = await fetchImageAsDataURL(coverDataUrl);
                         else if (coverDataUrl.startsWith('data:')) finalCoverDataUrl = coverDataUrl;updateProgressBarUI(coverProgressEnd, '在线封面处理完毕.');
                    } else {updateProgressBarUI(coverProgressEnd, '无封面或跳过封面处理.');}

                    if (typeof JSZip === 'undefined') throw new Error('JSZip library not found.');const epubGenerationStartProgress = coverProgressEnd; const epubCompressionEndProgress = 95;
                    epubBlob = await generateEpub(processedText, finalCoverDataUrl, options, (stageProgress, stageStatus) => {
                        const overallProgress = epubGenerationStartProgress + (stageProgress / 100) * (epubCompressionEndProgress - epubGenerationStartProgress);
                        updateProgressBarUI(overallProgress, stageStatus);
                    }); log(`完成！. 大小为: ${formatFileSize(epubBlob.size)}`, 'success');
                    updateProgressBarUI(100, '转换完成！');
                    setTimeout(() => { if (progressCard) progressCard.style.display = 'none'; if (resultCard) resultCard.style.display = 'block'; if (resultFileName) resultFileName.textContent = `${sanitizeFilename(title)}.epub`; if (resultFileSize) resultFileSize.textContent = formatFileSize(epubBlob.size); if (convertBtn) convertBtn.disabled = false; }, 500);
                } catch (error) {
                    log(`Conversion error: ${error.message}`, 'error');updateProgressBarUI(0, `转换失败: ${error.message.substring(0, 50)}...`); showCustomAlert(`转换过程中发生错误: <br>${error.message}`, '转换失败', 'error', () => {
                            // resetConverter(); // 如果 resetConverter 会清除其他状态，确保这是期望的行为
                            // 或者仅重置UI到可以重新尝试的状态
                            if (uploadCard) uploadCard.style.display = 'block';
                            if (progressCard) progressCard.style.display = 'none';
                            if (convertBtn) convertBtn.disabled = !selectedFile; // 只有当有文件时才解禁
                        }); 
                }
            }
            function resetConverter() { 
                 if (uploadCard) uploadCard.style.display = 'block'; if (dropArea) dropArea.style.display = 'block'; if (fileInfo) fileInfo.style.display = 'none'; if (progressCard) progressCard.style.display = 'none'; if (resultCard) resultCard.style.display = 'none'; if (progressBar) progressBar.style.width = '0%'; if (progressStatus) progressStatus.textContent = '';
                 updateDebugArea(); removeFile(); // This already clears coverFile, coverDataUrl, qidianResults
                 if (chapterPattern && customChapterPattern) { chapterPattern.value = 'auto'; customChapterPattern.value = ''; if (customChapterArea) customChapterArea.style.display = 'none'; } if (volumePattern && customVolumePattern) { volumePattern.value = 'auto'; customVolumePattern.value = ''; if (customVolumeArea) customVolumeArea.style.display = 'none'; }
                 if (coverSearch) coverSearch.checked = true; 
                 toggleCoverOptions(); // This will re-evaluate display of nav etc.
                 epubBlob = null; if (convertBtn) convertBtn.disabled = false; 
                 log('Converter reset to initial state', 'info');
            }
            function downloadEpub() { 
                 if (!epubBlob) { log('Download error: No EPUB file generated', 'error'); showCustomAlert('没有可供下载的 EPUB 文件。请先成功转换一个文件。', '下载错误', 'error'); return; } const title = bookTitle?.value || 'Untitled_Book'; const filename = `${sanitizeFilename(title)}.epub`; if (typeof saveAs === 'undefined') { log('FileSaver.js not found, using fallback download method', 'warning'); const url = URL.createObjectURL(epubBlob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100); } else { saveAs(epubBlob, filename); } log(`EPUB downloaded as: ${filename}`, 'success');
            }

            // --- Text Processing & EPUB Generation ---
            function getChapterPatternRegex() { 
                 if (!chapterPattern) return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; switch (chapterPattern.value) { case 'auto': return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; case 'chinese': return /^第[0-9一二三四五六七八九十百千万亿零〇]+[章节回集幕部篇](\s|$)/; case 'english': return /^(Chapter|CHAPTER)\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; case 'numbered': return /^\d+\.\s+/; case 'custom': try { if (customChapterPattern?.value) return new RegExp(customChapterPattern.value, 'i'); else { log('Empty custom chapter pattern, using auto-detect instead', 'warning'); return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; } } catch (e) { log(`Invalid chapter regex pattern: ${e.message}`, 'error'); showCustomAlert('您输入的自定义章节模式无效。<br>系统将自动切换回默认的章节检测模式。', '模式格式警告', 'warning'); return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; } default: return /^第[0-9一二三四五六七八九十零〇百千两 ]+[章回节集幕]|^[Ss]ection.{0,20}$|^[Cc]hapter.{0,20}$|^[Pp]age.{0,20}$|^\d{1,4}\.?\s*$|^引子$|^楔子$|^序章$|^序幕$|^尾声$|^最终章|^番外\d?\w{0,20}|^后记$|^完本感言.{0,4}$/i; }
            }
            function getVolumePatternRegex() { 
                if (!volumePattern || volumePattern.value === 'disabled') return null; switch (volumePattern.value) { case 'auto': return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; case 'chinese': return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)/; case 'english': return /^(Volume|Book)\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; case 'custom': try { if (customVolumePattern?.value) return new RegExp(customVolumePattern.value, 'i'); else { log('Empty custom volume pattern, using auto-detect instead', 'warning'); return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; } } catch (e) { log(`Invalid volume regex pattern: ${e.message}`, 'error'); alert('无效的自定义卷/部模式。将使用自动检测。'); return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; } default: return /^第[0-9一二三四五六七八九十零〇百千两 ]+[卷部篇集](\s|$)|^Volume\s+([0-9]+|[IVXLCDM]+)(\s|$)|^Book\s+([0-9]+|[IVXLCDM]+)(\s|$)/i; }
            }
            function cleanText(text) {
                log('正在清理文本...');
                if (!text) return "";

                // 1. 移除从 "多----" 开始到 "---" 结束的整个文本块
                //    - ^\s*-{10,}\s*$ : 匹配一个由至少10个短横线组成的行 (前后可有空白)
                //    - [\s\S]*?       : 非贪婪匹配中间的所有字符 (包括换行符)
                //    - ^\s*-{3,}\s*$  : 匹配一个由至少3个短横线组成的行 (作为结束标记)
                //    - gm 标志        : 全局匹配 (移除所有此类块), 多行模式 (使^和$匹配行首尾)
                // const blockRemovalRegex = /^\s*[-—=]{10,}\s*$[\s\S]*?^\s*[-—=]{3,}\s*$/gm;
                // 如果上面的 [\s\S] 在某些环境下表现不佳，可以尝试使用 s (dotall) 标志，但这需要 ES2018+ 环境：
                // const blockRemovalRegexWithSFlag = /^\s*-{10,}\s*$.*?^\s*-{3,}\s*$/gms;
                // 为确保兼容性，我们这里使用 [\s\S]

                // text = text.replace(blockRemovalRegex, '');
                // log('Text after block removal (first 200 chars): ' + text.substring(0, 200));

                // 2. 保留现有的初始字符清理步骤
                text = text.replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\x7F\uFFFE\uFFFF]/g, '');
                text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                text = text.replace(/\uFFFD/g, '');

                // 3. 定义并应用其他逐行或特定模式的垃圾信息移除
                // 注意：之前移除纯分隔线的模式 /^\s*[-—=]{10,}\s*$/gm 如果在 blockRemovalRegex 之后运行，
                // 可能会清理掉一些未被块移除正确捕获的、单独存在的分隔线。
                // 如果块移除已处理，该模式可能不再需要，或者作为补充。
                const junkPatterns = [
                    // 原有模式 (保留或根据需要调整)
                    /^\s*(最新章节请到|请收藏本站|看最新章节|手机用户请到).*?\.com\s*$/gim,
                    /^\s*www\..*?\.(com|net|org)\s*$/gim,
                    /^\s*(小说来源|下载地址|本书首发来自|更多精校小说尽在|【本作品来自互联网|本书由).*$/gim,
                    /^\s*ps\s*[:：].*$/gim,
                    /^\s*小说下载尽在\s*.*?书香中文网.*?$/gim,
                    /^\s*-+.*?《.*?校对.*?》.*?-+\s*$/gim, // 这个模式可能与上面的块移除有重叠，但可以保留以处理不同风格的校对标记
                    /^\s*本书由\s*.*?整理上传.*?$/gim,
                    /^\s*TXT小说下载网\s*.*?提供下载.*?$/gim,
                    /^\s*所有资源部分转载自互联网.*?$/gim,
                    /^\s*友情提示：.*?$/gim,
                    /^\s*[-—=]{10,}\s*$/gm, // 移除“纯粹由分隔符组成的行”，如果它们未被块移除捕获
                    /ρо-18,cом/gim,

                ];

                junkPatterns.forEach(pattern => {
                    text = text.replace(pattern, '');
                });

                // 移除其他特定行
                text = text.replace(/^\s*本文来自.*$/gm, '');
                text = text.replace(/^\s*(正文|序章|章节目录|最新章节|作品相关|第一卷|VIP卷)\s*$/gim, '');
                text = text.replace(/^\s*(赞助商链接|AD)\s*$/gim, '');
                text = text.replace(/ρΘ-㈠8,cΘм/gim, '——');


                // 4. 清理因移除产生的多余空行：将多个连续换行符合并为一个，并移除开头和结尾的空白
                text = text.replace(/\n\s*\n/g, '\n\n');
                return text.trim();
            }
            /**
             * Processes the full text to identify volumes, chapters, and their content.
             * Includes logic for standard chapter/volume regex matching and a fallback
             * mechanism for titling chapters based on preceding empty lines and short first lines.
             * @param {string} text - The full text content to process.
             * @param {object} options - Configuration options.
             * @returns {Array<object>} - An array of section objects (chapters or volumes).
             */
             function processText(text, options) {
                log('正在处理章节和卷...');
                const lines = text.split('\n');
                const sections = [];
                let currentVolume = null;
                let currentChapter = { title: options.unknownTitleName, type: 'text', content: [] };
                let hasContentSinceLastTitle = false; // Tracks if the currentChapter has actual content lines

                const chapterRegex = options.chapterPattern;
                const volumeRegex = options.volumePattern;
                const standardTitleMaxLength = options.maxTitleLength || 35;
                const fallbackTitleMinEmptyLines = options.minEmptyLinesForFallbackTitle || 2; // Default to 2 if not provided
                const fallbackTitleMaxLength = options.fallbackTitleMaxLength || 50;         // Default to 50 if not provided

                let emptyLineStreak = 0;

                function finalizeCurrentChapter() {
                    if (hasContentSinceLastTitle && currentChapter.content.length > 0) {
                        if (currentVolume) {
                            currentVolume.chapters.push(currentChapter);
                        } else {
                            sections.push(currentChapter);
                        }
                        return true; // Chapter was finalized
                    }
                    return false; // No meaningful content to finalize
                }

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i]; // Keep original for potential pushing, trim for checks
                    const trimmedLine = line.trim();

                    if (!trimmedLine) { // Line is empty or whitespace only
                        emptyLineStreak++;
                        continue; // Move to the next line
                    }

                    // At this point, trimmedLine is a non-empty string

                    let isPotentialStandardTitle = trimmedLine.length > 0 && trimmedLine.length <= standardTitleMaxLength;
                    let isVolumeTitle = volumeRegex && volumeRegex.test(trimmedLine) && isPotentialStandardTitle;
                    let isChapterTitle = chapterRegex && chapterRegex.test(trimmedLine) && isPotentialStandardTitle;
                    let isFallbackTitleCandidate = false;

                    if (!isVolumeTitle && !isChapterTitle) { // Only consider fallback if not a standard title
                        isFallbackTitleCandidate = emptyLineStreak >= fallbackTitleMinEmptyLines &&
                                                 trimmedLine.length > 0 &&
                                                 trimmedLine.length <= fallbackTitleMaxLength;
                    }

                    if (isVolumeTitle) {
                        finalizeCurrentChapter();
                        if (currentVolume) { // Finalize previous volume if it exists
                            sections.push(currentVolume);
                        }
                        currentVolume = { title: trimmedLine, type: 'volume', chapters: [] };
                        currentChapter = { title: options.unknownTitleName, type: 'text', content: [] }; // Reset for chapters within new volume
                        hasContentSinceLastTitle = false;
                    } else if (isChapterTitle) {
                        finalizeCurrentChapter();
                        currentChapter = { title: trimmedLine, type: 'chapter', content: [] };
                        hasContentSinceLastTitle = false;
                    } else if (isFallbackTitleCandidate) {
                        let potentialTitle = trimmedLine;
                        // Remove trailing colon if present (Chinese or English)
                        if (potentialTitle.endsWith(':') || potentialTitle.endsWith('：')) {
                            potentialTitle = potentialTitle.slice(0, -1).trim();
                        }

                        if (potentialTitle.length > 0) { // Ensure title is still valid
                            finalizeCurrentChapter();
                            currentChapter = { title: potentialTitle, type: 'chapter', content: [] };
                            hasContentSinceLastTitle = false;
                            log(`New Chapter (Fallback Heuristic after ${emptyLineStreak} empty lines): ${potentialTitle}`);
                        } else {
                            // Line became empty after removing colon, or was just a colon. Treat as content or skip.
                            // For simplicity, we'll let it fall through to be added as content if it's not filtered out.
                            if (trimmedLine.length > 0) { // Push the original trimmed line (with colon if it was just a colon)
                                currentChapter.content.push(trimmedLine); // Add the original line
                                hasContentSinceLastTitle = true;
                            }
                        }
                    } else {
                        // Line is content
                        // Filter out common "end of chapter" markers or other noise before adding to content
                        if (trimmedLine.toLowerCase().includes("本章未完") || trimmedLine.toLowerCase().includes("点击下一页")) {
                            // Skip this line
                        } else if (trimmedLine.startsWith("（本章完）")) {
                            // Skip this line
                        } else {
                            currentChapter.content.push(line); // Push the original line with its leading/trailing spaces if desired, or trimmedLine
                            hasContentSinceLastTitle = true;
                        }
                    }
                    emptyLineStreak = 0; // Reset for any non-empty line processed
                }

                // After the loop, finalize the last chapter/volume
                finalizeCurrentChapter();
                if (currentVolume) { // If a volume was being processed, add it
                    sections.push(currentVolume);
                }

                // Post-processing to assign default titles to unnamed chapters and process paragraphs
                const finalSections = [];
                let chapterCounter = 1; // Used for fallback chapter numbering if a title is still unknownTitleName

                sections.forEach(section => {
                    if (section.type === 'volume') {
                        if (section.chapters && section.chapters.length > 0) {
                            section.chapters.forEach(chap => {
                                if (!chap.title || chap.title === options.unknownTitleName) {
                                    chap.title = `${options.unknownTitleName} ${chapterCounter++}`;
                                }
                                chap.paragraphs = processParagraphs(chap.content); // Process paragraphs for each chapter
                            });
                            finalSections.push(section);
                        } else {
                            log(`Skipping empty volume: ${section.title}`, 'warning');
                        }
                    } else { // It's a chapter directly under sections
                        if (!section.title || section.title === options.unknownTitleName) {
                            section.title = `${options.unknownTitleName} ${chapterCounter++}`;
                        }
                        section.paragraphs = processParagraphs(section.content); // Process paragraphs
                        if (section.paragraphs.length > 0 || section.title !== `${options.unknownTitleName} ${chapterCounter-1}`) { // Keep if it has content or a meaningful title
                           finalSections.push(section);
                        } else {
                            log(`Skipping empty chapter or chapter with default name and no content: ${section.title}`, 'warning');
                        }
                    }
                });

                return finalSections;
            }

            function countSections(sections) { 
                let count = 0; for (let i = 0; i < sections.length; i++) { if (sections[i].type === 'volume') count += 1 + sections[i].chapters.length; else count++; } return count;
            }
            /**
             * 将文本行处理成段落。
             * 如果一行以终止性标点符号结尾，则当前段落结束。
             * 否则，该行将与后续行合并，直到遇到终止性标点、空行或文本末尾。
             * @param {string[]} lines - 输入的文本行数组。
             * @returns {string[]} - 处理后的段落数组。
             */
            function processParagraphs(lines) { 
                if (!lines || lines.length === 0) return []; const paragraphs = [];  let currentParagraphLines = []; const terminatingPunctuationRegex = /[。！…：\.!\?”]$/u; for (let i = 0; i < lines.length; i++) { const line = lines[i].trim(); if (line === "") {if (currentParagraphLines.length > 0) {paragraphs.push(currentParagraphLines.join('')); currentParagraphLines = []} continue; } currentParagraphLines.push(line); if (terminatingPunctuationRegex.test(line)) { paragraphs.push(currentParagraphLines.join('')); currentParagraphLines = [];}} if(currentParagraphLines.length>0) paragraphs.push(currentParagraphLines.join('')); return paragraphs; 
            }
            async function generateEpub(sections, coverImageDataUrl, options, progressCallback) {
                try {
                    if (typeof JSZip === 'undefined') {
                        progressCallback(0, 'Error: JSZip library not found.');
                        throw new Error('JSZip library not found');
                    }
                    progressCallback(0, '正在初始化 EPUB 生成器...'); // generateEpub 内部进度 0%

                    const zip = new JSZip();
                    // 1. MIMETYPE
                    zip.file('mimetype', 'application/epub+zip', { compression: "STORE" });

                    // 2. META-INF/container.xml
                    const metaInf = zip.folder('META-INF');
                    metaInf.file('container.xml', '<?xml version="1.0" encoding="UTF-8"?><container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container"><rootfiles><rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/></rootfiles></container>');

                    const oebps = zip.folder('OEBPS');
                    const imagesFolder = oebps.folder('images'); // Create images folder early

                    progressCallback(5, 'EPUB 核心结构已创建...'); // 内部进度 5%

                    // 3. OEBPS/stylesheet.css
                    const fontFamilyCSS = getFontFamilyCSS(options.fontFamily); // Assumes getFontFamilyCSS is defined
                    const titleAlignCSS = `text-align: ${options.titleAlign};`;
                    const indentVal = `${options.indent}em`;
                    const styleContent = `body { ${fontFamilyCSS} margin: 20px; line-height: ${options.lineHeight}; font-size: ${options.fontSize};} h1, h2, h3 { margin-top: 1.5em; margin-bottom: 0.8em; font-weight: bold; ${titleAlignCSS} } h1 { font-size: 2em; } h2 { font-size: 1.6em; } h3 { font-size: 1.3em; } p { text-indent: ${indentVal}; margin: 0 0 ${options.paragraphSpacing} 0; hyphens: auto; text-align: justify; } p.no-indent { text-indent: 0; } .title-page .book-title { font-size: 2.5em; margin-bottom: 0.5em; ${titleAlignCSS} } .title-page .author { font-size: 1.5em; margin-bottom: 3em; ${titleAlignCSS} font-style: italic; } .cover-page img { max-width: 100%; height: auto; display: block; margin: 0 auto; max-height: 95vh; } .volume-title { page-break-before: always; margin-top: 3em; } .chapter-title { page-break-before: always; margin-top: 2em; } .special-title { font-style: italic; } nav ol { list-style-type: none; padding-left: 0; } nav ol ol { padding-left: 1.5em; } nav a { text-decoration: none; color: var(--primary-color, #4361ee); } nav a:hover { text-decoration: underline; } @media amzn-kf8 { body { font-family: "Amazon Ember", "Bookerly", serif; } p { text-align: justify; -webkit-hyphens: auto; -moz-hyphens: auto; hyphens: auto; } } @media amzn-mobi { body { font-family: serif; } p { text-align: left; } }`;
                    oebps.file('stylesheet.css', styleContent);

                    // 4. OEBPS/title.xhtml
                    oebps.file('title.xhtml', `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>${escapeXML(options.title)}</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body class="title-page"><div id="title_page_main" class="book-title">${escapeXML(options.title)}</div><div class="author">${escapeXML(options.author)}</div></body></html>`);

                    // 5. Cover Image and OEBPS/cover.xhtml (if cover exists)
                    let coverImagePath = null;
                    let coverImageType = 'image/jpeg'; // Default
                    if (coverImageDataUrl?.startsWith('data:')) {
                        const match = coverImageDataUrl.match(/^data:(image\/(?:png|jpeg|gif|webp|svg\+xml));base64,(.+)$/);
                        if (match?.[1] && match?.[2]) {
                            coverImageType = match[1];
                            const base64Data = match[2];
                            const ext = coverImageType.split('/')[1].replace('svg+xml', 'svg') || 'jpg';
                            coverImagePath = `images/cover.${ext}`;
                            imagesFolder.file(`cover.${ext}`, base64Data, { base64: true });
                            log(`Cover image added: ${coverImagePath} (Type: ${coverImageType})`);
                            oebps.file('cover.xhtml', `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>Cover</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body class="cover-page"><div id="cover_image_container"><img src="${coverImagePath}" alt="Cover Image" /></div></body></html>`);
                        } else {
                            log(`Invalid cover image data URL format: ${coverImageDataUrl.substring(0, 100)}... Skipping cover.`, 'warning');
                        }
                    } else if (coverImageDataUrl) { // This case might occur if fetchImageAsDataURL returned null or a non-dataURL string
                        log(`Cover image data is not a Data URL. Skipping cover. URL (or part of it): ${String(coverImageDataUrl).substring(0, 100)}`, 'warning');
                    }

                    progressCallback(10, '基础 EPUB 页面已生成...'); // 内部进度 10%

                    // Initialize for manifest, spine, nav, ncx
                    const uuid = 'urn:uuid:' + generateUUID(); // Assumes generateUUID is defined
                    let manifestItems = '';
                    let spineItems = '';
                    const navDocLinks = [];
                    let ncxNavPoints = '';
                    let playOrder = 1;

                    // Add cover to manifest and spine (if exists)
                    if (coverImagePath) {
                        manifestItems += `<item id="cover-img" href="${coverImagePath}" media-type="${coverImageType}" properties="cover-image"/>\n`;
                        manifestItems += `<item id="cover-page" href="cover.xhtml" media-type="application/xhtml+xml"/>\n`;
                        spineItems += `<itemref idref="cover-page" linear="yes"/>\n`; // Some readers prefer 'linear="yes"' for the cover
                    }

                    // Add title page
                    manifestItems += `<item id="title-page" href="title.xhtml" media-type="application/xhtml+xml"/>\n`;
                    spineItems += `<itemref idref="title-page"/>\n`;
                    navDocLinks.push({ title: '书名页', href: `title.xhtml#title_page_main`, level: 1 });
                    ncxNavPoints += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>书名页</text></navLabel><content src="title.xhtml#title_page_main"/></navPoint>\n`;

                    // Add CSS
                    manifestItems += `<item id="css" href="stylesheet.css" media-type="text/css"/>\n`;

                    // --- Content Chapters/Volumes Processing ---
                    // This section will contribute from 10% to 70% of generateEpub's internal progress.
                    const chapterProcessingStartInternalProgress = 10;
                    const chapterProcessingTotalInternalWeight = 60; // 60% of internal progress for content files

                    // Calculate total number of "content units" (each volume title page + each chapter page) for progress calculation
                    let totalContentUnits = 0;
                    sections.forEach(section => {
                        totalContentUnits++; // For the section itself (either a chapter or a volume title)
                        if (section.type === 'volume') {
                            totalContentUnits += section.chapters.length; // For each chapter within the volume
                        }
                    });
                    if (totalContentUnits === 0) totalContentUnits = 1; // Avoid division by zero if sections is empty

                    let contentUnitsProcessed = 0;

                    sections.forEach((section, sectionIndex) => {
                        const sectionBaseId = `s_${sectionIndex + 1}`;

                        if (section.type === 'volume') {
                            const volumeAnchorId = `${sectionBaseId}_vol_title`;
                            const volumeFilename = `${sectionBaseId}_vol.xhtml`;
                            let volumePageContent = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>${escapeXML(section.title)}</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body><h1 id="${volumeAnchorId}" class="volume-title" epub:type="volume z3998:roman">${escapeXML(section.title)}</h1></body></html>`;
                            oebps.file(volumeFilename, volumePageContent);
                            manifestItems += `<item id="${sectionBaseId}-vol" href="${volumeFilename}" media-type="application/xhtml+xml"/>\n`;
                            spineItems += `<itemref idref="${sectionBaseId}-vol"/>\n`;
                            const volumeNavEntry = { title: escapeXML(section.title), href: `${volumeFilename}#${volumeAnchorId}`, level: 1, children: [] };
                            navDocLinks.push(volumeNavEntry);
                            let currentVolumeNcxNavPoint = `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(section.title)}</text></navLabel><content src="${volumeFilename}#${volumeAnchorId}"/>`;
                            let volumeNcxChildren = '';

                            contentUnitsProcessed++;
                            const currentProgressWithinLoop = chapterProcessingStartInternalProgress + (contentUnitsProcessed / totalContentUnits) * chapterProcessingTotalInternalWeight;
                            progressCallback(currentProgressWithinLoop, `正在生成卷: ${escapeXML(section.title).substring(0, 30)}...`);

                            section.chapters.forEach((chapter, chapterIndex) => {
                                const chapterAnchorId = `${sectionBaseId}_ch${chapterIndex + 1}_title`;
                                const chapterFilename = `${sectionBaseId}_ch${chapterIndex + 1}.xhtml`;
                                let chapterHtml = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>${escapeXML(chapter.title)}</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body><h2 id="${chapterAnchorId}" class="chapter-title ${chapter.type === 'special' ? 'special-title' : ''}" epub:type="chapter ${chapter.type === 'special' ? 'z3998:credits' : ''}">${escapeXML(chapter.title)}</h2>`;
                                chapter.paragraphs.forEach(p => { chapterHtml += `<p>${escapeXML(p)}</p>\n`; });
                                chapterHtml += `</body></html>`;
                                oebps.file(chapterFilename, chapterHtml);
                                manifestItems += `<item id="${sectionBaseId}-ch${chapterIndex + 1}" href="${chapterFilename}" media-type="application/xhtml+xml"/>\n`;
                                spineItems += `<itemref idref="${sectionBaseId}-ch${chapterIndex + 1}"/>\n`;
                                volumeNavEntry.children.push({ title: escapeXML(chapter.title), href: `${chapterFilename}#${chapterAnchorId}`, level: 2 });
                                volumeNcxChildren += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(chapter.title)}</text></navLabel><content src="${chapterFilename}#${chapterAnchorId}"/></navPoint>\n`;

                                contentUnitsProcessed++;
                                const currentProgressWithinChapterLoop = chapterProcessingStartInternalProgress + (contentUnitsProcessed / totalContentUnits) * chapterProcessingTotalInternalWeight;
                            });
                            currentVolumeNcxNavPoint += volumeNcxChildren + `</navPoint>\n`;
                            ncxNavPoints += currentVolumeNcxNavPoint;
                        } else { // Section is a chapter
                            const chapterAnchorId = `${sectionBaseId}_title`;
                            const chapterFilename = `${sectionBaseId}.xhtml`;
                            let chapterHtml = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><meta charset="UTF-8" /><title>${escapeXML(section.title)}</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /></head><body><h2 id="${chapterAnchorId}" class="chapter-title ${section.type === 'special' ? 'special-title' : ''}" epub:type="chapter ${section.type === 'special' ? 'z3998:credits' : ''}">${escapeXML(section.title)}</h2>`;
                            section.paragraphs.forEach(p => { chapterHtml += `<p>${escapeXML(p)}</p>\n`; });
                            chapterHtml += `</body></html>`;
                            oebps.file(chapterFilename, chapterHtml);
                            manifestItems += `<item id="${sectionBaseId}" href="${chapterFilename}" media-type="application/xhtml+xml"/>\n`;
                            spineItems += `<itemref idref="${sectionBaseId}"/>\n`;
                            navDocLinks.push({ title: escapeXML(section.title), href: `${chapterFilename}#${chapterAnchorId}`, level: 1 });
                            ncxNavPoints += `<navPoint id="navpoint-${playOrder}" playOrder="${playOrder++}"><navLabel><text>${escapeXML(section.title)}</text></navLabel><content src="${chapterFilename}#${chapterAnchorId}"/></navPoint>\n`;

                            contentUnitsProcessed++;
                            const currentProgressWithinLoop = chapterProcessingStartInternalProgress + (contentUnitsProcessed / totalContentUnits) * chapterProcessingTotalInternalWeight;
                        }
                    });
                    progressCallback(chapterProcessingStartInternalProgress + chapterProcessingTotalInternalWeight, '所有内容文件已生成.'); // At 70% of internal progress

                    // --- Navigation Files (nav.xhtml, toc.ncx) and content.opf ---
                    // This section from 70% to 80% of internal progress
                    // OEBPS/nav.xhtml (EPUB 3 Table of Contents)
                    let navDocHtml = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="${options.language}"><head><title>Table of Contents</title><meta charset="utf-8"/><link rel="stylesheet" type="text/css" href="stylesheet.css"/></head><body><nav epub:type="toc" id="toc"><h1>目录</h1><ol>`;
                    navDocLinks.forEach(item => {
                        navDocHtml += `<li><a href="${item.href}">${item.title}</a>`;
                        if (item.children?.length > 0) {
                            navDocHtml += `<ol>`;
                            item.children.forEach(child => {
                                navDocHtml += `<li><a href="${child.href}">${child.title}</a></li>\n`;
                            });
                            navDocHtml += `</ol>`;
                        }
                        navDocHtml += `</li>\n`;
                    });
                    navDocHtml += `</ol></nav><nav epub:type="landmarks" hidden="hidden"><h2>Landmarks</h2><ol>`;
                    if (coverImagePath) navDocHtml += `<li><a epub:type="cover" href="cover.xhtml#cover_image_container">封面</a></li>\n`;
                    const firstContentItem = navDocLinks.find(item => item.href?.includes("_vol.xhtml#") || item.href?.includes("_ch") || (item.href?.includes("s_") && !item.href.startsWith("title.xhtml")));
                    const bodyMatterHref = firstContentItem ? firstContentItem.href : (navDocLinks.length > 1 && !navDocLinks[1].href.startsWith("title.xhtml") ? navDocLinks[1].href : (navDocLinks.length > 0 && !navDocLinks[0].href.startsWith("title.xhtml") ? navDocLinks[0].href : "title.xhtml#title_page_main"));
                    navDocHtml += `<li><a epub:type="bodymatter" href="${bodyMatterHref}">开始阅读</a></li>\n`;
                    navDocHtml += `<li><a epub:type="toc" href="nav.xhtml#toc">目录</a></li>\n`;
                    navDocHtml += `</ol></nav></body></html>`;
                    oebps.file('nav.xhtml', navDocHtml);
                    manifestItems += `<item id="nav" href="nav.xhtml" media-type="application/xhtml+xml" properties="nav"/>\n`;

                    // OEBPS/toc.ncx (EPUB 2 Table of Contents)
                    let maxNavDepth = 0;
                    navDocLinks.forEach(item => {
                        if (item.level > maxNavDepth) maxNavDepth = item.level;
                        if (item.children && item.children.length > 0) {
                            item.children.forEach(child => { if (child.level > maxNavDepth) maxNavDepth = child.level; });
                        }
                    });
                    if (maxNavDepth === 0 && navDocLinks.length > 0) maxNavDepth = 1;

                    const ncxContent = `<?xml version="1.0" encoding="UTF-8"?><ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1"><head><meta name="dtb:uid" content="${uuid}"/><meta name="dtb:depth" content="${maxNavDepth}"/><meta name="dtb:totalPageCount" content="0"/><meta name="dtb:maxPageNumber" content="0"/></head><docTitle><text>${escapeXML(options.title)}</text></docTitle><navMap>${ncxNavPoints}</navMap></ncx>`;
                    oebps.file('toc.ncx', ncxContent);
                    manifestItems += `<item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>\n`;

                    // OEBPS/content.opf
                    const contentOpf = `<?xml version="1.0" encoding="UTF-8"?><package xmlns="http://www.idpf.org/2007/opf" version="3.0" unique-identifier="BookId"><metadata xmlns:dc="http://purl.org/dc/elements/1.1/"><dc:title>${escapeXML(options.title)}</dc:title><dc:creator id="creator">${escapeXML(options.author)}</dc:creator><dc:language>${options.language}</dc:language><dc:identifier id="BookId">${uuid}</dc:identifier><meta property="dcterms:modified">${new Date().toISOString().split('.')[0] + "Z"}</meta>${coverImagePath ? '<meta name="cover" content="cover-img"/>' : ''}</metadata><manifest>${manifestItems}</manifest><spine toc="ncx">${spineItems}</spine></package>`;
                    oebps.file('content.opf', contentOpf);

                    progressCallback(80, 'EPUB 导航及元数据已完成.'); // At 80% of internal progress

                    // --- Zipping Phase ---
                    // This section from 80% to 100% of internal progress
                    const compressionPhaseStartInternalProgress = 80;
                    const compressionPhaseTotalInternalWeight = 20; // 20% of internal progress for zipping
                    progressCallback(compressionPhaseStartInternalProgress, '准备压缩 EPUB 文件...');

                    const epubData = await zip.generateAsync(
                        { type: 'blob', mimeType: 'application/epub+zip', compression: 'DEFLATE', compressionOptions: { level: 9 } },
                        (metadata) => { // JSZip's onUpdate callback
                            const zipSpecificProgress = metadata.percent; // 0-100 for zipping itself
                            const currentCompressionProgress = (zipSpecificProgress / 100) * compressionPhaseTotalInternalWeight;
                            
                        }
                    );

                    progressCallback(100, 'EPUB 文件压缩完毕.'); // generateEpub internal progress 100%
                    return epubData;

                } catch (error) {
                    log(`Error generating EPUB: ${error.message}`, 'error');
                    console.error("EPUB Generation Error Details:", error);
                    // Report error via progress callback if it's available
                    if (progressCallback && typeof progressCallback === 'function') {
                        progressCallback(0, `EPUB 生成错误: ${error.message.substring(0, 70)}...`);
                    }
                    throw error; // Re-throw the error so startConversion's catch block can handle it
                }
            }
            
            // --- Utility Functions ---
            function getFontFamilyCSS(fontType) { 
                 switch (fontType) { case 'serif': return 'font-family: "Georgia", "Times New Roman", "Noto Serif SC", serif;'; case 'sans': return 'font-family: "Helvetica", "Arial", "Noto Sans SC", sans-serif;'; case 'mono': return 'font-family: "Courier New", "Menlo", "Noto Sans Mono SC", monospace;'; default: return 'font-family: "Noto Serif SC", "Songti SC", "SimSun", serif;'; }
            }
            function escapeXML(text) { 
                if (typeof text !== 'string') return ''; return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
            }
            function generateUUID() { 
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { const r = Math.random() * 16 | 0; const v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); });
            }
            function updateDebugArea() { 
                if (debugMode && debugAreaDOM) debugAreaDOM.style.display = debugMode.value === 'on' ? 'block' : 'none';
            }
            function log(message, level = 'info') { 
                 const timestamp = new Date().toLocaleTimeString(); if (level === 'error') console.error(message); else if (level === 'warning') console.warn(message); else console.log(message); if (debugLog && debugMode?.value === 'on') { const logEntry = document.createElement('div'); let color = '#e0e0e0'; if (level === 'error') color = '#ef476f'; else if (level === 'warning') color = '#f7b801'; else if (level === 'success') color = '#34a853'; logEntry.style.color = color; logEntry.textContent = `[${timestamp}] ${level.toUpperCase()}: ${message}`; debugLog.appendChild(logEntry); debugLog.scrollTop = debugLog.scrollHeight; }
            }
            function formatFileSize(bytes) { 
                if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            function extractTitleAuthor(filename) { 
                let name = filename.replace(/\.txt$/i, ''); const chineseTitleAuthorPattern = /《([^》]+)》[^作者]*作者[：:]\s*([^.]+)(?:\.txt)?$/; const chineseMatch = name.match(chineseTitleAuthorPattern); if (chineseMatch) { if (bookTitle) bookTitle.value = chineseMatch[1].trim(); if (chineseMatch[2] && bookAuthor) bookAuthor.value = chineseMatch[2].trim(); log(`解析到标题: "${bookTitle.value}" 和作者: "${bookAuthor?.value || 'N/A'}"`); return; } const englishTitleAuthorPattern = /(.+?)(?:\s+-\s+|\s+by\s+)(.+)/i; const englishMatch = name.match(englishTitleAuthorPattern); if (englishMatch) { if (bookTitle) bookTitle.value = englishMatch[1].trim(); if (bookAuthor) bookAuthor.value = englishMatch[2].trim(); log(`解析到标题: "${bookTitle?.value || 'N/A'}" 和作者: "${bookAuthor?.value || 'N/A'}"`); return; } if (bookTitle) bookTitle.value = name.trim(); if (bookAuthor) bookAuthor.value = ''; log(`Using filename as title: "${bookTitle?.value || 'N/A'}", author cleared.`);
            }
            /**
             * 解码文件 ArrayBuffer 的一个样本为文本字符串。
             * @param {ArrayBuffer} arrayBuffer - 文件的 ArrayBuffer。
             * @param {string} encoding - 用于解码的字符编码。
             * @param {number} [maxLength=4096] - 要解码的最大字节数（样本大小）。
             * @returns {Promise<string>} - 解码后的文本样本。
             */
             async function decodeSampleText(arrayBuffer, encoding, maxLength = 4096) {
                if (!arrayBuffer || arrayBuffer.byteLength === 0) return "";
                const sampleBuffer = arrayBuffer.slice(0, Math.min(arrayBuffer.byteLength, maxLength));
                try {
                    const decoder = new TextDecoder(encoding, { fatal: false }); // fatal:false 避免因样本中少量坏字符中断
                    return decoder.decode(sampleBuffer);
                } catch (e) {
                    log(`解码样本文本时出错 (编码 ${encoding}), 尝试UTF-8: ${e.message}`, 'warning');
                    try {
                        const decoder = new TextDecoder('UTF-8', { fatal: false });
                        return decoder.decode(sampleBuffer);
                    } catch (eUtf8) {
                        log(`UTF-8回退解码样本文本时也出错: ${eUtf8.message}`, 'error');
                        return ""; // 解码失败
                    }
                }
            }

            /**
             * 从文本样本（通常是文件的前几行）中提取书名和作者。
             * @param {string} textSample - 文本样本。
             * @returns {{title: string|null, author: string|null}} - 提取到的书名和作者对象。
             */
            function extractTitleAuthorFromContent(textSample) {
                if (!textSample) return { title: null, author: null };

                const lines = textSample.split('\n').slice(0, 20); // 分析文件的前20行
                let extractedTitle = null;
                let extractedAuthor = null;

                const titleRegex = /《([^》]+)》/; // 匹配 《书名》
                // 匹配 作者：姓名 或 著：姓名 (更宽松)
                const authorRegex = /(?:作者|著者|著|编著)[:：\s]*([^\s\n\r（(《》]+)/;


                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    // 尝试在当前行匹配书名
                    if (!extractedTitle) {
                        const titleMatch = line.match(titleRegex);
                        if (titleMatch && titleMatch[1]) {
                            extractedTitle = titleMatch[1].trim();
                            // 如果书名和作者在同一行，例如 "《书名》 作者：某某"
                            const remainingLineAfterTitle = line.substring(line.indexOf(titleMatch[0]) + titleMatch[0].length);
                            const authorMatchSameLine = remainingLineAfterTitle.match(authorRegex);
                            if (authorMatchSameLine && authorMatchSameLine[1]) {
                                extractedAuthor = authorMatchSameLine[1].trim();
                            }
                        }
                    }

                    // 尝试在当前行匹配作者 (如果尚未从书名行获取)
                    if (!extractedAuthor) {
                        const authorMatch = line.match(authorRegex);
                        if (authorMatch && authorMatch[1]) {
                            extractedAuthor = authorMatch[1].trim();
                            // 如果作者信息在书名之前，例如 "作者：某某 《书名》"
                            // 并且书名还没找到，尝试在当前行找书名
                            if (!extractedTitle) {
                                const titleMatchSameLine = line.match(titleRegex);
                                if (titleMatchSameLine && titleMatchSameLine[1]) {
                                    extractedTitle = titleMatchSameLine[1].trim();
                                }
                            }
                        }
                    }
                    
                    // 如果书名和作者都找到了，可以提前退出以提高效率
                    // if (extractedTitle && extractedAuthor) break;
                }
                
                // 处理特殊情况：如 "《书名 作者 作者名》" 或 "《书名 作者：作者名》"
                if (extractedTitle && !extractedAuthor) {
                    const specialAuthorMatch = extractedTitle.match(/^(.*?)[\s　]*(?:作者|著者|著|编著)[:：\s]*([^\s（(《》]+)$/);
                    if (specialAuthorMatch && specialAuthorMatch[1] && specialAuthorMatch[2]) {
                        extractedTitle = specialAuthorMatch[1].trim();
                        extractedAuthor = specialAuthorMatch[2].trim();
                    }
                }


                return { title: extractedTitle, author: extractedAuthor };
            }
            /**
             * Removes lines from the beginning of the text content if they match the given title, author,
             * or common metadata keywords.
             * @param {string} textContent - The full text content.
             * @param {string} finalTitle - The determined book title.
             * @param {string} finalAuthor - The determined book author.
             * @param {number} [linesToCheck=10] - How many lines from the beginning to check.
             * @returns {string} - The text content with metadata lines removed.
             */
             function removeMetadataLinesFromContent(textContent, finalTitle, finalAuthor, linesToCheck = 10) {
                if (!textContent) return ""; // 返回空字符串，而不是原始的 textContent
                let lines = textContent.split('\n');
                let linesRemovedCount = 0;

                const patterns = [];
                const titleKeywords = ['书名', 'title'];
                const authorLabelKeywords = ['作者', 'author', '著', '编著'];
                // standaloneAuthorKeywords 用于匹配单独一行的 "作者" 标签
                const standaloneKeywords = ['书名', 'title', '作者', 'author']; // Combined for simplicity


                // Helper to escape regex special characters in a string
                function escapeRegExp(string) {
                    if (typeof string !== 'string') return '';
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                }

                // Modified addFieldPatterns to handle core values and 《》 wrapped values
                function addFieldPatterns(value, keywordsForLabel) {
                    if (value && value.trim() !== "") {
                        const coreValue = value.trim();
                        const escapedCoreValue = escapeRegExp(coreValue);

                        // Pattern 1a: The core value itself (e.g., "金瓶梅")
                        patterns.push(new RegExp(`^\\s*${escapedCoreValue}\\s*$`, 'i'));
                        // Pattern 1b: The core value wrapped in 《》 (e.g., "《金瓶梅》")
                        patterns.push(new RegExp(`^\\s*《${escapedCoreValue}》\\s*$`, 'i'));

                        // Pattern 2a: "Keyword: core_value" or "Keyword core_value" (e.g., "书名: 金瓶梅")
                        patterns.push(new RegExp(`^\\s*(?:${keywordsForLabel.join('|')})(?:[:：]\\s*|\\s+)${escapedCoreValue}\\s*$`, 'i'));
                        // Pattern 2b: "Keyword: 《core_value》" or "Keyword 《core_value》" (e.g., "书名: 《金瓶梅》")
                        patterns.push(new RegExp(`^\\s*(?:${keywordsForLabel.join('|')})(?:[:：]\\s*|\\s+)《${escapedCoreValue}》\\s*$`, 'i'));
                    }
                }

                addFieldPatterns(finalTitle, titleKeywords);
                addFieldPatterns(finalAuthor, authorLabelKeywords); // Pass authorLabelKeywords here

                // --- NEW: Add patterns for combined Title and Author on one line ---
                if (finalTitle && finalTitle.trim() !== "" && finalAuthor && finalAuthor.trim() !== "") {
                    const coreTitle = finalTitle.trim();
                    const escapedCoreTitle = escapeRegExp(coreTitle);
                    const coreAuthor = finalAuthor.trim();
                    const escapedCoreAuthor = escapeRegExp(coreAuthor);

                    // Regex part for the title, allowing it to be plain or wrapped in 《》
                    const titleRegexPart = `(?:${escapedCoreTitle}|《${escapedCoreTitle}》)`;
                    // Regex part for "AuthorKeyword Separator AuthorName"
                    const authorFullPartRegex = `(?:${authorLabelKeywords.join('|')})(?:[:：]\\s*|\\s+)${escapedCoreAuthor}`;

                    // Combined pattern: Title (mandatory space) AuthorPart
                    // Example: "凡人修仙传 作者：忘语"
                    patterns.push(new RegExp(`^\\s*${titleRegexPart}\\s+${authorFullPartRegex}\\s*$`, 'i'));
                }
                // --- END NEW ---

                // Add patterns for standalone keywords (e.g., a line just containing "书名" or "作者")
                const allStandaloneKeywordsToRegister = [...new Set(standaloneKeywords)]; // Use the combined list
                for (const keyword of allStandaloneKeywordsToRegister) {
                    patterns.push(new RegExp(`^\\s*${escapeRegExp(keyword)}\\s*$`, 'i'));
                }

                if (patterns.length === 0) {
                    // Return original textContent if it was non-empty but patterns are empty
                    // Or return empty string if textContent was initially empty (handled at the top)
                    return textContent;
                }

                let currentIndex = 0;
                let numOriginalLinesInspected = 0;

                while (currentIndex < lines.length && numOriginalLinesInspected < linesToCheck) {
                    const currentLineOriginal = lines[currentIndex];
                    const currentLineTrimmed = currentLineOriginal.trim();

                    numOriginalLinesInspected++;

                    if (currentLineTrimmed === "") {
                        currentIndex++;
                        continue;
                    }

                    let matchedThisLine = false;
                    for (const pattern of patterns) {
                        if (pattern.test(currentLineTrimmed)) {
                            matchedThisLine = true;
                            break;
                        }
                    }

                    if (matchedThisLine) {
                        log(`从内容开头移除元数据行: "${currentLineOriginal}"`, 'info');
                        lines.splice(currentIndex, 1);
                        linesRemovedCount++;
                        // Do NOT increment currentIndex here. The next line has shifted into lines[currentIndex].
                    } else {
                        log(`首个非元数据行 (trimmed): "${currentLineTrimmed}". 停止移除。`, 'info');
                        break;
                    }
                }

                if (linesRemovedCount > 0) {
                    log(`共从内容开头移除了 ${linesRemovedCount} 行元数据。`);
                }
                // return lines.join('\n\n'); // <<< BUG: This adds an extra newline between every line
                return lines.join('\n');    // <<< CORRECTED: Join with a single newline
            }
            async function detectEncoding(file) { 
                log('开始检测文件编码...'); try { const arrayBuffer = await readFileAsArrayBuffer(file); fileArrayBuffer = arrayBuffer; if (typeof jschardet === 'undefined') { log('jschardet library not found, using UTF-8 as default encoding', 'warning'); return { encoding: 'UTF-8', confidence: 0.9 }; } const sampleSize = Math.min(4096, arrayBuffer.byteLength); const sampleData = new Uint8Array(arrayBuffer, 0, sampleSize); const result = jschardet.detect(sampleData); let encoding = result.encoding || 'UTF-8'; if (encoding === 'ascii' || encoding === 'windows-1252') { const possibleChinese = detectChineseEncoding(sampleData); if (possibleChinese) { encoding = 'GB18030'; result.confidence = 0.85; } } const mappedEncoding = mapEncodingName(encoding); return { encoding: mappedEncoding, confidence: result.confidence || 0.5 }; } catch (error) { log(`编码检测失败: ${error.message}`, 'error'); throw error; }
            }
            function detectChineseEncoding(data) { 
                let gbkPatternCount = 0; for (let i = 0; i < data.length - 1; i++) { if (data[i] >= 0x81 && data[i] <= 0xFE) { if (data[i+1] >= 0x40 && data[i+1] <= 0xFE) gbkPatternCount++; } } return gbkPatternCount > 20;
            }
            function mapEncodingName(encoding) { 
                if (!encoding) return 'UTF-8'; const lowerEncoding = encoding.toLowerCase(); const encodingMap = { 'gb2312': 'GB18030', 'gbk': 'GB18030', 'gb18030': 'GB18030', 'windows-1252': 'windows-1252', 'ascii': 'UTF-8', 'utf-8': 'UTF-8', 'utf8': 'UTF-8', 'big5': 'Big5' }; return encodingMap[lowerEncoding] || encoding;
            }
            async function readFileAsArrayBuffer(file) { 
                 return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(new Error('Failed to read file as ArrayBuffer.')); reader.readAsArrayBuffer(file); });
            }
            async function decodeText(arrayBuffer, encodingName) { 
                try { const decoder = new TextDecoder(encodingName, { fatal: true }); return decoder.decode(arrayBuffer); } catch (error) { log(`TextDecoder failed for ${encodingName}: ${error.message}. Falling back to UTF-8.`, 'warning'); try { const fallbackDecoder = new TextDecoder('UTF-8', { fatal: false }); return fallbackDecoder.decode(arrayBuffer); } catch (fallbackError) { log(`Fallback UTF-8 decoding also failed: ${fallbackError.message}`, 'error'); throw new Error(`Failed to decode text with ${encodingName} and fallback UTF-8.`); } }
            }
            async function readFileAsDataURL(file) { 
                 return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = (error) => reject(new Error(`Failed to read file as DataURL: ${error}`)); reader.readAsDataURL(file); });
            }
            async function fetchImageAsDataURL(imageUrl) {
                log(`Fetching image as DataURL (direct/canvas method): ${imageUrl}`, 'info');
                try {
                    const img = new Image();
                    const imageLoaded = new Promise((resolve, reject) => {
                        img.crossOrigin = 'Anonymous'; 

                        const timeoutDuration = 10000; 
                        let timeoutId = setTimeout(() => {
                            reject(new Error(`Timeout loading image from URL (after ${timeoutDuration/1000}s): ${imageUrl}`));
                        }, timeoutDuration);

                        img.onload = () => {
                            clearTimeout(timeoutId);
                            resolve(img);
                        };
                        img.onerror = () => {
                            clearTimeout(timeoutId);
                            reject(new Error('Failed to load image from URL: ' + imageUrl));
                        };

                        img.src = imageUrl; 
                    });

                    const loadedImg = await imageLoaded;

                    const canvas = document.createElement('canvas');
                    canvas.width = loadedImg.width;
                    canvas.height = loadedImg.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(loadedImg, 0, 0);

                    try {
                        return canvas.toDataURL('image/jpeg'); 
                    } catch (e) {
                        throw new Error(`Canvas toDataURL failed (tainted canvas?): ${e.message} for ${imageUrl}`);
                    }
                } catch (error) {
                    log(`Error in fetchImageAsDataURL (direct/canvas): ${error.message}. The searched cover will not be used.`, 'error');
                    return null; 
                }
            }
            function sanitizeFilename(name) { 
                if (!name) return 'Untitled'; return name.replace(/[\/\\:*?"<>|]/g, '_').replace(/\s+/g, '_').replace(/__+/g, '_').replace(/^_+|_+$/g, '');
            }
            loadUserSettings();
            updateGoogleBooksOptionStatus();
        });
    </script>
</body>
</html>